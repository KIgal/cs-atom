<!--Generated by a crappy script that Craig Andera wrote : https://github.com/candera/cs-atom--><feed xmlns="http://www.w3.org/2005/Atom" xmlns:thr="http://purl.org/syndication/thread/1.0"><id>feed-id</id><updated>2011-12-25T08:45:14.981-05:00</updated><title type="text">Blog Title Here</title><generator version="7.00" uri="http://www.blogger.com">Blogger</generator><entry><id>15087</id><published>2005-09-29T10:42:00.0-05:00</published><updated>2005-09-29T10:42:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#post"></category><title type="text">PDC 2005 - COM430 Demos posted</title><content type="html">&lt;p&gt;It's taken a while, but it's finally there.&lt;/p&gt;
&lt;p&gt;&lt;a href="http://commnet.microsoftpdc.com/downloads.aspx"&gt;http://commnet.microsoftpdc.com/downloads.aspx&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Look for COM430.zip&lt;/p&gt;</content><author><name>doug-walter</name></author></entry><entry><id>15091</id><published>2005-09-29T12:28:00.0-05:00</published><updated>2005-09-29T12:28:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#post"></category><title type="text">PDC2005 - COM214 - What happened?</title><content type="html">&lt;p&gt;&lt;font face="Verdana"&gt;If you attended John Shewchuck's talk COM214 - you probably remember all sorts of things going wrong with my demo. I know this is going to sound largely apologetic, but my real intent is to highlight what &lt;em&gt;not &lt;/em&gt;to do with a demo in front of a whole bunch of people.&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;&lt;font face="Verdana"&gt;Here's what I learned:&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;&lt;font face="Verdana"&gt;1. Don't run on beta versions of the OS unless you have to!&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;&lt;font face="Verdana"&gt;2. Split screen demos just don't work! Craning my neck to see what the audience was seeing, pop-up dialogs appearing on the wrong screen, and finding the mouse pointer made it all but impossible to show what was going on.&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;&lt;font face="Verdana"&gt;3. Have a backup machine that's booted, and ready to resume your demo!&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;&lt;font face="Verdana"&gt;4. If your demo involves writing code, keep snapshots of all key points along the way! See #3.&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;&lt;font face="Verdana"&gt;5. Tech check all machines you might use, backups included!&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;&lt;font face="Verdana"&gt;6. Don't share demo machines! It's tempting, especially if it's a 64-bit Ferrari; nonetheless, resist!&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;&lt;font face="Verdana"&gt;7. Show less, not more!&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;&lt;font face="Verdana"&gt;I want to thank Nigel Watling who, in a moment of brilliance and forethought, reminded me that InfoCard would only draw on the primary screen of the demo machine. Had I continued running on the backup machine, along with its split screen configuration, the InfoCard part of the demo would have been a complete flop! Imagine, me holding a laptop high over my head, and pointing “See, isn't it beautiful”?&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;&lt;font face="Verdana"&gt;Anyways, lessons learned...&lt;/font&gt;&lt;/p&gt;</content><author><name>doug-walter</name></author><thr:total>1</thr:total></entry><entry><id>15101</id><published>2005-09-30T15:37:00.0-05:00</published><updated>2005-09-30T15:37:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">re: PDC2005 - COM214 - What happened?</title><content type="html">7. Assume all your demos will tank, then be happily surprised when they work :-)</content><author><name>Anonymous</name></author><thr:in-reply-to ref="15091"></thr:in-reply-to></entry><entry><id>17448</id><published>2005-12-13T21:36:00.0-05:00</published><updated>2005-12-13T21:36:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#post"></category><title type="text">Application Identity</title><content type="html">&lt;p style="MARGIN: 0in 0in 0pt" class="MsoNormal"&gt;&lt;span style="FONT-SIZE: 10pt; FONT-FAMILY: Tahoma"&gt;There’s this fantasy that applications will someday be able to identify themselves. That is, they will be able to act as a “principal”, just like you or me. This doesn't make sense.&lt;o:p&gt;&lt;/o:p&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p style="MARGIN: 0in 0in 0pt" class="MsoNormal"&gt;&lt;span style="FONT-SIZE: 10pt; FONT-FAMILY: Tahoma"&gt;&lt;o:p&gt; &lt;/o:p&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p style="MARGIN: 0in 0in 0pt" class="MsoNormal"&gt;&lt;span style="FONT-SIZE: 10pt; FONT-FAMILY: Tahoma"&gt;In reality, applications are agents; agents of a real user. That is, applications (aka. code) acts because a user told it to. If this was not universally true, then someone has figured out true AI (artificial intelligence) and the landscape of computer systems as we know it is forever changed. I’ve been watching the 5 O’clock news. There haven’t been any major breakthroughs in AI lately. Until that day, software is simply an agent of a user, period.&lt;o:p&gt;&lt;/o:p&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p style="MARGIN: 0in 0in 0pt" class="MsoNormal"&gt;&lt;span style="FONT-SIZE: 10pt; FONT-FAMILY: Tahoma"&gt;&lt;o:p&gt; &lt;/o:p&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p style="MARGIN: 0in 0in 0pt" class="MsoNormal"&gt;&lt;span style="FONT-SIZE: 10pt; FONT-FAMILY: Tahoma"&gt;Some people think that if only you could identify the app, then you cold hold the app-writer accountable and therefore hold harmless the user who unwittingly invoked the app.&lt;o:p&gt;&lt;/o:p&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p style="MARGIN: 0in 0in 0pt" class="MsoNormal"&gt;&lt;span style="FONT-SIZE: 10pt; FONT-FAMILY: Tahoma"&gt;&lt;o:p&gt; &lt;/o:p&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p style="MARGIN: 0in 0in 0pt" class="MsoNormal"&gt;&lt;span style="FONT-SIZE: 10pt; FONT-FAMILY: Tahoma"&gt;But wait a second, how dumb could a crook be to let you know who he is? Let’s say he writes this awesome worm that completely messes with everything in your system. Is he going to sign the app as “Crook”? Is he going to place a return address on his app? “Here, I’m at &lt;st1:Street w:st="on"&gt;&lt;st1:address w:st="on"&gt;1111 Stupid Lane&lt;/st1:address&gt;&lt;/st1:Street&gt;, come and get me!” Absolutely not! Hackers have always focused on those vulnerabilities which leave no trace back to them. That’s just common sense.&lt;o:p&gt;&lt;/o:p&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p style="MARGIN: 0in 0in 0pt" class="MsoNormal"&gt;&lt;span style="FONT-SIZE: 10pt; FONT-FAMILY: Tahoma"&gt;&lt;o:p&gt; &lt;/o:p&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p style="MARGIN: 0in 0in 0pt" class="MsoNormal"&gt;&lt;span style="FONT-SIZE: 10pt; FONT-FAMILY: Tahoma"&gt;Let’s say you’re a good company, conscientious in every way. What’s the first thing you’re going to place on your license agreement? I’m no lawyer, but I expect it will read something like “XXX corporation is not responsible for any damages the user might encounter while using this software…” etc. etc. etc.&lt;/span&gt;&lt;/p&gt;
&lt;p style="MARGIN: 0in 0in 0pt" class="MsoNormal"&gt;&lt;span style="FONT-SIZE: 10pt; FONT-FAMILY: Tahoma"&gt;&lt;o:p&gt; &lt;/o:p&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p style="MARGIN: 0in 0in 0pt" class="MsoNormal"&gt;&lt;span style="FONT-SIZE: 10pt; FONT-FAMILY: Tahoma"&gt;Now back to application IDs. I’m not saying that signing software isn’t a good idea. On the contrary! More and more applications are being delivered online. Signing the application manifest including a digest of all binaries is just common sense. But remember the disclaimer. The signatures are just there to enable you to 1) make an informed decision about whether the package you got came from who you thought it did and 2) that any attempt to modify the application in transit can and will be detected. You can also use the manifest to ensure that the application remains unchanged over time.&lt;o:p&gt;&lt;/o:p&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p style="MARGIN: 0in 0in 0pt" class="MsoNormal"&gt;&lt;span style="FONT-SIZE: 10pt; FONT-FAMILY: Tahoma"&gt;&lt;o:p&gt; &lt;/o:p&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p style="MARGIN: 0in 0in 0pt" class="MsoNormal"&gt;&lt;span style="FONT-SIZE: 10pt; FONT-FAMILY: Tahoma"&gt;What I object to is the notion that an application can act on its own. I object to the notion that an app can authenticate to a remote party. This makes no sense. On the other hand, if the user (eg. person) wants to cough up the manifest associated with the application he’s running, that’s certainly his prerogative. In fact, a relying party may require this. However, the trust, the liability, the responsibility is on the user to ensure that A) his system is functioning within parameters, B) the application he’s running is the one he wants and C) the actions taken on his behalf by the application are ultimately his responsibility.&lt;o:p&gt;&lt;/o:p&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p style="MARGIN: 0in 0in 0pt" class="MsoNormal"&gt;&lt;span style="FONT-SIZE: 10pt; FONT-FAMILY: Tahoma"&gt;&lt;o:p&gt; &lt;/o:p&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p style="MARGIN: 0in 0in 0pt" class="MsoNormal"&gt;&lt;span style="FONT-SIZE: 10pt; FONT-FAMILY: Tahoma"&gt;Won’t this mean that users will be held accountable for stuff they have no control over? No. They can always choose not to run a piece of software, not to use a computer, or to use a different operating system. In fact, because software runs under the context of the user and the user most likely has the potential to do whatever it wants with the software, this actually creates a completely new problem. What’s to prevent a malicious user from intentionally modifying the software in such a way as to damage the reputation of the software publisher, or even to hold the software publisher accountable for actions taken with that software?&lt;o:p&gt;&lt;/o:p&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p style="MARGIN: 0in 0in 0pt" class="MsoNormal"&gt;&lt;span style="FONT-SIZE: 10pt; FONT-FAMILY: Tahoma"&gt;&lt;o:p&gt; &lt;/o:p&gt;&lt;/span&gt;&lt;/p&gt;
&lt;p style="MARGIN: 0in 0in 0pt" class="MsoNormal"&gt;&lt;span style="FONT-SIZE: 10pt; FONT-FAMILY: Tahoma"&gt;In short, applications are not principals. They do not act on their own. Software publishers are not responsible for the actions taken by a user. Users must always be held accountable for the actions they take, no matter the agent. Let’s make operating systems and software that enable users to make informed decisions about which agents to invoke, and allow them to control the rights and privileges afforded to the agent. This makes sense.&lt;/span&gt;&lt;/p&gt;</content><author><name>doug-walter</name></author><thr:total>3</thr:total></entry><entry><id>17468</id><published>2005-12-14T14:31:00.0-05:00</published><updated>2005-12-14T14:31:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">re: Application Identity</title><content type="html">Although I agree with you for the most part, I think you over simplified the story.
&lt;br /&gt;
&lt;br /&gt;What if user actions are deferred in time. Is the program still assuming the identity of the user ? I guess so .. But what if there's more then one user ? Take an Interpay batch. That processes payments issued by thousands of people. Is it a thousand identities ? Or is its identity the bank ? Or the guy at the bank who started it ..
&lt;br /&gt;
&lt;br /&gt;And what about computers. Are they identities ? They seem to think so, nowadays. But what distinguishes the program called operating system from a user application ?
&lt;br /&gt;
&lt;br /&gt;In short, I think you're right. Kind of. But only for interactive on-line apps ;-).</content><author><name>Anonymous</name></author><thr:in-reply-to ref="17448"></thr:in-reply-to></entry><entry><id>17494</id><published>2005-12-15T12:53:00.0-05:00</published><updated>2005-12-15T12:53:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">re: Application Identity</title><content type="html">Thanks for the comments. You bring up some very good points.
&lt;br /&gt;
&lt;br /&gt;I agree this is somewhat of an over-simplification.
&lt;br /&gt;
&lt;br /&gt;I still hold true that software always acts on behalf of a user.
&lt;br /&gt;
&lt;br /&gt;Users must be held liable for actions taken on their behalf. The burden is on the user to proove that he or she acted in good faith. I believe we need to enable users to identify faults in applications, and hold application wrtiers accountable for their negligence. This is the same in my mind as something so mundane as a car. That is, if a driver gets in an accident, it is up to the driver to prove he acted appropriately. If the driver believes that the car (aka. agent or tool) was to blame, the driver must provide evidence to support that. If the car is found to be faulty, then the burden is still on the driver to prove that the manufacturer of the car was guilty of negligence. In all these exchanges, the driver assumes liability until responsibility can be placed elsewhere.
&lt;br /&gt;
&lt;br /&gt;I believe all assets, whether real or ephemeral, have an identity. In fact, anything you can identify (that is which have measurable characteristics that can uniquely distinguish the entity from others) has an identity. All software, therefore, has an identity. In fact, packages of software, also have an identity which can be established by creating a manifest of the composition of the package.
&lt;br /&gt;
&lt;br /&gt;As to actions deferred in time. Imagine if we had robots which followed complex instructions from users. If the robot ended up doing something wrong, who's the first person to get blamed? Until we have systems which think for themselves, the blame of course will go to the programmer/user. Even if things happen while you're not around, if you were the instigator, then you're responsible.
&lt;br /&gt;
&lt;br /&gt;As for batch jobs, I believe it's the organization that runs the service that is responsible. Take for example, if the batch processing agent, the exact same code, deployment, configuration, etc. was run by two organizations. Let's say one was run by a government recognized corporation that had been in business for several decades. The other, run by a couple of unknowns out of their basement. Remember, it's the same code. If I had the choice, of course I'd go with the more well-known company, especially if it's my finances at stake. Software itself does not define responsibility.
&lt;br /&gt;
&lt;br /&gt;I know the question you posed was somewhat different. Since a batch agent is doing work on behalf of a thousand users. Which one is the agent operating under. Ultimately, it's whoever takes the fall if something goes wrong. Presumably, the agent is under contract with each of the users for which the batch agent is doing work. The items which are the agent's organization's responsibility under contract are the things under which the organization's identity should be used. Those things which are the user's responsibility are the users. In your specific example, the agent is responsible for faithfully executing transactions based on the parameters of the contracts with each user. If the transaction involves illegal transfer of funds, presumably there is some obligation on the agent itself to report to the government any activity which seems suspicious, as well the user is responsible for initiating the action. In none of these transactions is the software responsible or liable. The fact that the agent's organization has entrusted its functions to a computer, in no way relieves it of its obligations to the user under contract, or to the government(s) in whose jurisdiction these transactions are taking place.
&lt;br /&gt;
&lt;br /&gt;I believe the notion of software as a principal is flawed. This applies even to the operating system and the hardware it runs on.
&lt;br /&gt;
&lt;br /&gt;But then, that's just my opinion... :)
&lt;br /&gt;
&lt;br /&gt;-Doug</content><author><name>Anonymous</name></author><thr:in-reply-to ref="17448"></thr:in-reply-to></entry><entry><id>17565</id><published>2005-12-19T16:26:00.0-05:00</published><updated>2005-12-19T16:26:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">re: Application Identity</title><content type="html">Security is increased when certificates are treated as GUIDs. We need to move past the model of charging for security as this will always result in insecurity...
&lt;br /&gt;
&lt;br /&gt;http://duckdown.blogspot.com/</content><author><name>Anonymous</name></author><thr:in-reply-to ref="17448"></thr:in-reply-to></entry><entry><id>32645</id><published>2006-07-28T10:02:00.0-05:00</published><updated>2006-07-28T10:02:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#post"></category><title type="text">AsyncCalls and Internet Explorer / JavaScript</title><content type="html">&lt;p&gt;&lt;font face="Tahoma"&gt;A friend of mine asked me recently if I knew of an elegant way to handle asynchronous calls in Internet Explorer. Basically the problem starts with some event like “load a page” then “do something” after the page is done loading. With the emergence of AJAX-style applications which exploit this asynchronous behavior quite heavily, it's interesting to have some way to write code that handles async calls. This is especially true if you want to write automated test scripts.&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;&lt;font face="Tahoma"&gt;In any case, I sat down this morning and wrote up the following. It's only the solution. I'll let you work out how to integrate it in with a real problem:&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;&lt;font face="Courier New"&gt;function AsyncCall(action, condition, callback, timeout) {&lt;br /&gt;  action();&lt;br /&gt;  window.setTimeout("onTimer(" + condition + ", " + callback + ", " + timeout + ")", timeout);&lt;br /&gt;}&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;&lt;font face="Courier New"&gt;function onTimer(condition, callback, timeout) {&lt;br /&gt;  if (condition()) {&lt;br /&gt;    callback();&lt;br /&gt;  }&lt;br /&gt;  else {&lt;br /&gt;    window.setTimeout("onTimer(" + condition + ", " + callback + ")", timeout);&lt;br /&gt;  }&lt;br /&gt;}&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;&lt;font face="Tahoma"&gt;You would then introduce a call like:&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;&lt;font face="Courier New"&gt;AsyncCall(setUrl, checkFrame, notifyDone, 100);&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;&lt;font face="Tahoma"&gt;This invokes the “action“ function, then periodically checks the “condition“ function. When the condition returns true, then it calls the “callback“ function.&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;&lt;font face="Tahoma"&gt;Here's a simple web page that lets you set the SRC property of an IFrame, then notifies you when the page is completely loaded:&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;&lt;font face="Courier New"&gt;&amp;lt;html&amp;gt;&lt;br /&gt;&amp;lt;head&amp;gt;&lt;br /&gt;&amp;lt;title&amp;gt;Async Test&amp;lt;/title&amp;gt;&lt;br /&gt;&amp;lt;/head&amp;gt;&lt;br /&gt;&amp;lt;script language="JScript" src="asynccall.js"&amp;gt;&amp;lt;/script&amp;gt;&lt;br /&gt;&amp;lt;script language="JScript"&amp;gt;&lt;br /&gt;function updatePage() {&lt;br /&gt;  AsyncCall(setUrl, checkFrame, notifyDone, 100);&lt;br /&gt;}&lt;br /&gt;function setUrl() {&lt;br /&gt;  document.all["myFrame"].src=myForm.url.value;&lt;br /&gt;}&lt;br /&gt;function checkFrame() {&lt;br /&gt;  return document.all["myFrame"].readyState == "complete";&lt;br /&gt;}&lt;br /&gt;function notifyDone() {&lt;br /&gt;  alert("Done!");&lt;br /&gt;}&lt;br /&gt;&amp;lt;/script&amp;gt;&lt;br /&gt;&amp;lt;body&amp;gt;&lt;br /&gt;&amp;lt;form id="myForm"&amp;gt;&lt;br /&gt;&amp;lt;input type="text" name="url" /&amp;gt;&lt;br /&gt;&amp;lt;input type="button" value="Go" onClick="updatePage()" /&amp;gt;&lt;br /&gt;&amp;lt;/form&amp;gt;&lt;br /&gt;&amp;lt;iframe id="myFrame" src="about:blank" height="100%" width="100%"&amp;gt;&amp;lt;/iframe&amp;gt;&lt;br /&gt;&amp;lt;/body&amp;gt;&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;&lt;font face="Tahoma"&gt;Happy async calling!&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;&lt;font face="Tahoma"&gt;-Doug&lt;/font&gt;&lt;/p&gt;</content><author><name>doug-walter</name></author><thr:total>3</thr:total></entry><entry><id>32649</id><published>2006-07-28T15:32:00.0-05:00</published><updated>2006-07-28T15:32:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">re: AsyncCalls and Internet Explorer / JavaScript</title><content type="html">I believe Selenium (since you mention automated testing...) has a very similar feature. Check out:
&lt;br /&gt;http://wiki.openqa.org/display/SEL/waitForCondition
&lt;br /&gt;</content><author><name>Anonymous</name></author><thr:in-reply-to ref="32645"></thr:in-reply-to></entry><entry><id>32650</id><published>2006-07-28T22:27:00.0-05:00</published><updated>2006-07-28T22:27:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">Interesting Finds: July 28, 2006</title><content type="html"></content><author><name>Anonymous</name></author><thr:in-reply-to ref="32645"></thr:in-reply-to></entry><entry><id>32651</id><published>2006-07-28T22:30:00.0-05:00</published><updated>2006-07-28T22:30:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">Interesting Finds: July 28, 2006</title><content type="html"></content><author><name>Anonymous</name></author><thr:in-reply-to ref="32645"></thr:in-reply-to></entry><entry><id>45505</id><published>2006-12-29T20:45:00.0-05:00</published><updated>2006-12-29T20:45:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#post"></category><title type="text">Authenticated Keyboards</title><content type="html">&lt;p&gt;&lt;font face="Tahoma"&gt;I've been thinking, why aren't identities tied to the input devices rather than to the process, or “session”?&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;&lt;font face="Tahoma"&gt;Here's the problem. At home, I often leave the computer running. In fact, I don't see any reason to log off just because I'm going to get a drink from the fridge. I have a 4 year old and a 2 year old. Turns out, the 2 year old is incredibly fast at A) identifying when a computer is on, and B) when I'm not using it. I have this fear that she'll accidentally hit “format c:“, or “Delete All“, or some such.&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;&lt;font face="Tahoma"&gt;Wouldn't it be nice of the system said “no, you don't have permission to format C: because you are not Doug“? I think it would.&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;&lt;font face="Tahoma"&gt;I say restrict the action, not the actee. That is, it's more important to control the avenues through which actions are taken than to control the applications which execute them.&lt;/font&gt;&lt;/p&gt;
&lt;p&gt;&lt;font face="Tahoma"&gt;OK, how does this work? Well, for one, we could have proximity-sensing input devices that transmitted a “user“ signal along with the input signal. The proximity sensor could detect a person wearing an RFID tag inbedded in, let's say, a watch. Yes, you could go hog-wild and have a microchip implanted but hey, let's not get crazy. The point is, it's not necessarily the application that “does“ things, but rather the input devices we use to direct the them.&lt;/font&gt;&lt;/p&gt;</content><author><name>doug-walter</name></author><thr:total>2</thr:total></entry><entry><id>45520</id><published>2007-01-01T20:43:00.0-05:00</published><updated>2007-01-01T20:43:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">re: Authenticated Keyboards</title><content type="html">Isnt locking the computer sufficient here?</content><author><name>Anonymous</name></author><thr:in-reply-to ref="45505"></thr:in-reply-to></entry><entry><id>45521</id><published>2007-01-01T21:27:00.0-05:00</published><updated>2007-01-01T21:27:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">re: Authenticated Keyboards</title><content type="html">I'm looking for a better solution. Locking the computer is, as you say, sufficient. But why should I have to? We have built-in safeguards for who we allow to touch us. That is, if you were at a hospital and another patient tried to touch your arm, you'd probably have some words. However, if your doctor did the same activity, you'd probably welcome the attention. We recognize who is doing things to us or to our surroundings. Why shouldn't the computer be equally equipped? I feel I shouldn't have to tell my computer to say no to unwanted input. It should have a way to do so automatically on my behalf. Wouldn't that be an improvement at least?</content><author><name>Anonymous</name></author><thr:in-reply-to ref="45505"></thr:in-reply-to></entry></feed>