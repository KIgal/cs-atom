<!--Generated by a crappy script that Craig Andera wrote : https://github.com/candera/cs-atom--><feed xmlns="http://www.w3.org/2005/Atom" xmlns:thr="http://purl.org/syndication/thread/1.0"><id>feed-id</id><updated>2011-12-25T08:45:15.102-05:00</updated><title type="text">Blog Title Here</title><generator version="7.00" uri="http://www.blogger.com">Blogger</generator><entry><id>2615</id><published>2004-10-04T13:25:00.0-05:00</published><updated>2004-10-04T13:25:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#post"></category><title type="text">Movin' In</title><content type="html">This is it: A (hopefully) long-term home for my blog. Thanks to &lt;a href="http://pluralsight.com/blogs/dbox/"&gt;Don&lt;/a&gt; for prodding, &lt;a href="http://pluralsight.com/blogs/fritz/default.aspx"&gt;Fritz&lt;/a&gt; for hosting, and retroactive thanks to all the folks at MSDN and GDN for hosting my initial blog home.</content><author><name>herb-sutter</name></author><thr:total>2</thr:total></entry><entry><id>2630</id><published>2004-10-04T11:56:00.0-05:00</published><updated>2004-10-04T11:56:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">re: Movin' In</title><content type="html">Good gawd!  The pluralsight community has some jaw-dropping names of the industry.  Between you guys a wealth of information is being disseminated.  Long live Blogs!</content><author><name>Anonymous</name></author><thr:in-reply-to ref="2615"></thr:in-reply-to></entry><entry><id>2721</id><published>2004-10-08T07:05:00.0-05:00</published><updated>2004-10-08T07:05:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">re: Movin' In</title><content type="html">nice to have such quality blogs, be sure that such an initiative is highly appreciated, thanks to share some "real-time" (given your schedule this sounds quite optimistic) impressions,
&lt;br /&gt;
&lt;br /&gt;Alex
&lt;br /&gt;
&lt;br /&gt;(and nice to read your, too scarce, comments on fr.comp.lang.c++) ...
&lt;br /&gt;</content><author><name>Anonymous</name></author><thr:in-reply-to ref="2615"></thr:in-reply-to></entry><entry><id>2616</id><published>2004-10-04T13:34:00.0-05:00</published><updated>2004-10-04T13:34:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#post"></category><title type="text">SimpleBlogger</title><content type="html">&lt;div align="left"&gt;I'm trying out the &lt;a href="http://weblogs.asp.net/guowu/archive/2004/07/20/187990.aspx"&gt;SimpleBlogger&lt;/a&gt; InfoPath blog editor. Seems fine so far.&lt;/div&gt;
&lt;div align="left"&gt; &lt;/div&gt;
&lt;div align="left"&gt;A promising feature is composing blog posts offline, which should be cool given the amount of time I spend offline on airplanes and such. Next time I’m at 35,000 feet (which is sure to be soon) I'll give that a whirl.&lt;/div&gt;
&lt;div align="left"&gt; &lt;/div&gt;
&lt;div align="left"&gt;(Of course, it might be more interesting to try it at 350,000 feet, but I'll have to wait for &lt;a href="http://www.virgingalactic.com"&gt;Virgin Galactic&lt;/a&gt; to start serious passenger operations for that. &lt;a href="http://news.google.com/news?sourceid=navclient&amp;amp;ie=UTF-8&amp;amp;q=spaceshipone"&gt;Go, Rutan!&lt;/a&gt;)&lt;/div&gt;
&lt;div align="left"&gt; &lt;/div&gt;</content><author><name>herb-sutter</name></author></entry><entry><id>2619</id><published>2004-10-04T13:53:00.0-05:00</published><updated>2004-10-04T13:53:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#post"></category><title type="text">The annual Fall Madness: Books, conferences, talks, and (possibly) a little sleep</title><content type="html">&lt;div&gt;I hope to move my previous blog articles over here. No ETA on when, though.&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt;Things are crazy. I'm just about done the indexing on the &lt;em&gt;&lt;a href="http://www.gotw.ca/publications/c++cs.htm"&gt;C++ Coding Standards&lt;/a&gt;&lt;/em&gt; book. That will go to the printer's by Thursday this week. I hope to have the first few copies ready to hand-carry across the border to &lt;a href="http://www.oopsla.org/2004/ShowPage.do?id=Home"&gt;OOPSLA&lt;/a&gt; toward the end of this month.&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt;After that, the fall 2004 C++ standards meeting will be held in Redmond on Oct 17-22. I'll probably spend the rest of this week and next preparing for that. I haven't read all the &lt;a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2004/#mailing2004-07"&gt;papers&lt;/a&gt; yet (see the 2004-07 and 2004-09 mailings). I may still write some of my own.&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt;After that, I have &lt;a href="http://www.gotw.ca/presentations.htm"&gt;some upcoming talks&lt;/a&gt; (not all of which are listed on that link), including &lt;a href="http://www.oopsla.org/2004/ShowEvent.do?id=804"&gt;this one at OOPSLA&lt;/a&gt;.&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt;(Of course, during all that time I'm still working on the &lt;a href="http://www.gotw.ca/microsoft"&gt;C++/CLI&lt;/a&gt; design and implementation.)&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt;When the October/November madness is behind me, there'll be more time. Probably. (I always think there'll be more time someday. I've thought that for years now. I guess it's good to stay optimistic.) Maybe I'll even get around to posting old not-yet-on-the-web &lt;a href="http://www.gotw.ca/conv"&gt;Conversations&lt;/a&gt; articles someday. I keep hoping to. Could happen.&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;</content><author><name>herb-sutter</name></author></entry><entry><id>2620</id><published>2004-10-04T14:57:00.0-05:00</published><updated>2004-10-04T14:57:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#post"></category><title type="text">std::map and erase</title><content type="html">&lt;div&gt;This morning, a friend asked me:&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div style="PADDING-LEFT: 50px"&gt;&lt;font face="Arial"&gt;What is the standard implementation of the return value for map&amp;lt;&amp;gt;::erase? Is it supposed to return an iterator to the next element of the map or nothing (void)? &lt;/font&gt;&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt;Knowing nothing more than that, I'll bet he's using &lt;a href="http://www.dinkumware.com"&gt;Dinkumware's STL&lt;/a&gt; (probably via Microsoft &lt;a href="http://www.msdn.microsoft.com/visualc"&gt;Visual C++&lt;/a&gt;) and trying to port to another compiler/STL.&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div style="PADDING-RIGHT: 0in; MARGIN-TOP: 0in; PADDING-LEFT: 0in; FONT-SIZE: 12pt; MARGIN-BOTTOM: 0pt"&gt;&lt;font size="2"&gt;&lt;span style="FONT-SIZE: 10pt"&gt;The standard version of map&amp;lt;&amp;gt;::erase returns void, and that’s all you can portably rely on. Dinkumware in particular, however, chooses to return an iterator as a (slightly nonconforming) extension. Code that uses an extension like this will fail to compile other standard library implementations (including STLport, Gnu, etc.).&lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div style="PADDING-RIGHT: 0in; MARGIN-TOP: 0in; PADDING-LEFT: 0in; FONT-SIZE: 12pt; MARGIN-BOTTOM: 0pt"&gt;&lt;font size="2"&gt;&lt;span style="FONT-SIZE: 10pt"&gt;&lt;/span&gt;&lt;/font&gt; &lt;/div&gt;
&lt;div style="PADDING-RIGHT: 0in; MARGIN-TOP: 0in; PADDING-LEFT: 0in; FONT-SIZE: 12pt; MARGIN-BOTTOM: 0pt"&gt;&lt;font size="2"&gt;&lt;span style="FONT-SIZE: 10pt"&gt;Background: I happen to think that Dinkumware’s decision is more consistent with what the other containers do (e.g., vector&amp;lt;&amp;gt;::erase). The only reason that strictly speaking it’s nonstandard is a corner case: Technically, a pathological conforming program could break in the presence of this extension if it formed a pointer to function (which must specify the exact signature and return type) to point to map&amp;lt;&amp;gt;::erase (yeah, pretty unlikely, but imaginable). This was the subject of some discussion in committee a year or three ago, and &lt;a href="http://www.plauger.com"&gt;Bill Plauger&lt;/a&gt; decided that even though technically his extension was a little nonconforming, the nonconformance was such a corner case that he felt the utility of allowing it as an extension outweighed the slight nonconformance so he was going to keep supplying it. Of course, like all extensions, this is an annoyance to people trying to migrate code that compiles on one STL to compile also on other STLs.&lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div style="PADDING-RIGHT: 0in; MARGIN-TOP: 0in; PADDING-LEFT: 0in; FONT-SIZE: 12pt; MARGIN-BOTTOM: 0pt"&gt;&lt;font size="2"&gt;&lt;span style="FONT-SIZE: 10pt"&gt;&lt;/span&gt;&lt;/font&gt; &lt;/div&gt;
&lt;div style="PADDING-RIGHT: 0in; MARGIN-TOP: 0in; PADDING-LEFT: 0in; FONT-SIZE: 12pt; MARGIN-BOTTOM: 0pt"&gt;&lt;font size="2"&gt;&lt;span style="FONT-SIZE: 10pt"&gt;I personally think the standard ought to be changed to have map&amp;lt;&amp;gt;::erase return an iterator so that the containers are more consistent, but today it doesn’t. Caveat emptor.&lt;/span&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;</content><author><name>herb-sutter</name></author><thr:total>2</thr:total></entry><entry><id>2623</id><published>2004-10-04T10:51:00.0-05:00</published><updated>2004-10-04T10:51:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">re: std::map and erase</title><content type="html">Is Dinkumware's extension really non-conforming? C++ standard 17.4.4.4/2 allows implementations to add arguments with default values to any non-virtual member function of a library class. Footnote 172 specifically says: "Hence, taking the address of a member function has an unspecified type."
&lt;br /&gt;
&lt;br /&gt;Thus, a conforming program cannot detect the wrong return type by forming a pointer to member. Is there another way to detect an incorrect return type?
&lt;br /&gt;
&lt;br /&gt;I guess, it is formally non-conforming, because it changes the signature in a way not explicitly allowed by 17.4.4.4/2. But I don't see how a conforming program can actually detect the presence of this extension.</content><author><name>Anonymous</name></author><thr:in-reply-to ref="2620"></thr:in-reply-to></entry><entry><id>2635</id><published>2004-10-04T13:16:00.0-05:00</published><updated>2004-10-04T13:16:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">re: std::map and erase</title><content type="html">Yes, it's really nonconforming.
&lt;br /&gt;
&lt;br /&gt;Thanks for the note. My point about the extension's nonconformance was correct, but when dashing off the note I inserted the wrong example. (Interestingly, the very point you make is covered in detail in my other new book, Exceptional C++ Style, released about two months ago. It's Item 4, "Standard Library Member Functions.")
&lt;br /&gt;
&lt;br /&gt;But my point about nonconformance is valid. Here is some conforming code that breaks in the presence of this extension:
&lt;br /&gt;
&lt;br /&gt;  void f( map&amp;lt;int,int&amp;gt;&amp;amp;m ) {
&lt;br /&gt;    assert(m.size()&amp;gt;0);
&lt;br /&gt;    return m.erase(m.begin()); // breaks
&lt;br /&gt;  }
&lt;br /&gt;
&lt;br /&gt;It's a corner case, but the extension can cause conforming code (like the above) to fail to compile, hence it's technically not a conforming extension.
&lt;br /&gt;
&lt;br /&gt;(Note that a return of an expression with void type is legal per 3.9.1/9. Among other things, this makes it possible to write templates more easily, including expression templates and binders.)</content><author><name>Anonymous</name></author><thr:in-reply-to ref="2620"></thr:in-reply-to></entry><entry><id>2672</id><published>2004-10-05T22:21:00.0-05:00</published><updated>2004-10-05T22:21:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#post"></category><title type="text">The VC++ 2005 (and C++/CLI) elevator pitch</title><content type="html">&lt;div&gt;Yesterday, I had occasion to come up with a two-minute "elevator pitch" for how Visual C++ relates to .NET in Whidbey (the 2005 release now in beta). Here's what I said:&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt;In VS 2005, C++ is the systems programming language for .NET. If you already know C++, there is no need to use another language, although you're free to use whatever language you like for all or any part of your application. C++ is not the simplest .NET language, just the most powerful one that exposes the most .NET CLR features and that usually generates the best optimized IL. The CLR's promise is to be a &lt;em&gt;Common&lt;/em&gt; Language Runtime that works well for many programming languages, and in VS 2005 it achieves that goal across all the Microsoft language products.&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt;That's about two minutes.&lt;/div&gt;</content><author><name>herb-sutter</name></author><thr:total>9</thr:total></entry><entry><id>2675</id><published>2004-10-05T19:44:00.0-05:00</published><updated>2004-10-05T19:44:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">re: The VC++ 2005 (and C++/CLI) elevator pitch</title><content type="html">Herb, instead of saying that "C++ is not the simplest .NET language", shouldn't you state that C++/CLI is the most complex .NET language?
&lt;br /&gt;
&lt;br /&gt;BTW, when will your new C++ come out? I am looking forward to it.
&lt;br /&gt;
&lt;br /&gt;Kevin</content><author><name>Anonymous</name></author><thr:in-reply-to ref="2672"></thr:in-reply-to></entry><entry><id>2678</id><published>2004-10-05T23:37:00.0-05:00</published><updated>2004-10-05T23:37:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">re: The VC++ 2005 (and C++/CLI) elevator pitch</title><content type="html">&amp;gt; usually generates the best optimized IL
&lt;br /&gt;
&lt;br /&gt;Being more of a Java background, I thought the days of optimizing the bytecode are basically over and that's the job of the runtime compiler. javac's '-O' switch has shown to be useless and isn't used by anyone.
&lt;br /&gt;
&lt;br /&gt;Is JVM bytecode more primitive? Or is it because (hearsay) CLR is not as profound as the hotspot JVM on profile-directed inlining and such?
&lt;br /&gt;
&lt;br /&gt;Matthias
&lt;br /&gt;</content><author><name>Anonymous</name></author><thr:in-reply-to ref="2672"></thr:in-reply-to></entry><entry><id>2685</id><published>2004-10-06T10:10:00.0-05:00</published><updated>2004-10-06T10:10:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">re: The VC++ 2005 (and C++/CLI) elevator pitch</title><content type="html">Kevin: It's now in beta and will be released in the summer. You can try it out today -- see &lt;a href="http://blogs.msdn.com/hsutter/archive/2004/09/04/225736.aspx" target="_new"&gt;http://blogs.msdn.com/hsutter/archive/2004/09/04/225736.aspx&lt;/a&gt; for the links, and be sure to download the refresh too.
&lt;br /&gt;
&lt;br /&gt;Matthias: Yes, JVM bytecode doesn't have all the constructs in CLI IL. The larger issue is that there's only so much optimization you can do at JIT time because a JIT has to be fast; VC++ runs through its advanced optimizing back-end at compile time and spits out what is often better IL for that reason. There are also profile-guided optimizations in VC++ 2005; see the VC++ home page at &lt;a href="http://www.msdn.microsoft.com/visualc" target="_new"&gt;http://www.msdn.microsoft.com/visualc&lt;/a&gt; and you'll find links.</content><author><name>Anonymous</name></author><thr:in-reply-to ref="2672"></thr:in-reply-to></entry><entry><id>2686</id><published>2004-10-06T11:13:00.0-05:00</published><updated>2004-10-06T11:13:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">re: The VC++ 2005 (and C++/CLI) elevator pitch</title><content type="html">When comparing the compilation of IL to managed native code to the JIT compilers used by some JVMs, it's important to remember that they are doing two very different things.
&lt;br /&gt;
&lt;br /&gt;The JVM defaults to an interpretive mode, with some portions of the code being compiled to native instructions when "hot spots" are identified by the JVM.  The CLR never executes IL in an interpretive mode -- a .NET class is completely compiled to managed native code before any of the methods are executed.</content><author><name>Anonymous</name></author><thr:in-reply-to ref="2672"></thr:in-reply-to></entry><entry><id>2692</id><published>2004-10-06T18:37:00.0-05:00</published><updated>2004-10-06T18:37:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">re: The VC++ 2005 (and C++/CLI) elevator pitch</title><content type="html">As to JIT, even after I read Don Box's book (Essential .NET), I am still not clear how it works. I guess that the result of JIT compilation stays in memory. In other words, every time one runs an exe file (which is MSIL), it will be JIT-compiled to the native machine code. Would it make sense if the JIT-compiled code stays on the harddrive so that there would be no need to recompile the IL code everytime?</content><author><name>Anonymous</name></author><thr:in-reply-to ref="2672"></thr:in-reply-to></entry><entry><id>2694</id><published>2004-10-06T21:02:00.0-05:00</published><updated>2004-10-06T21:02:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">re: The VC++ 2005 (and C++/CLI) elevator pitch</title><content type="html">Re: JIT. See my blog entry posted a few moments ago.
&lt;br /&gt;</content><author><name>Anonymous</name></author><thr:in-reply-to ref="2672"></thr:in-reply-to></entry><entry><id>2719</id><published>2004-10-08T05:10:00.0-05:00</published><updated>2004-10-08T05:10:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">re: The VC++ 2005</title><content type="html">Apart from the C++/CLI extensions, does VC++ 2005 offer any improvements to the non-.NET standard C++ (such as, better standard conformance)?
&lt;br /&gt;</content><author><name>Anonymous</name></author><thr:in-reply-to ref="2672"></thr:in-reply-to></entry><entry><id>7691</id><published>2005-04-24T00:15:00.0-05:00</published><updated>2005-04-24T00:15:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">re: The VC++ 2005 (and C++/CLI) elevator pitch</title><content type="html">will C++/CLI be included as a choice of language for MCAD/MCSD certifications in future?</content><author><name>Anonymous</name></author><thr:in-reply-to ref="2672"></thr:in-reply-to></entry><entry><id>10541</id><published>2005-06-06T05:43:00.0-05:00</published><updated>2005-06-06T05:43:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">re: The VC++ 2005 (and C++/CLI) elevator pitch</title><content type="html">Hi, I am a new developer in VC++ .net environment, i have succesfully compiled my vc++ application and the build was successful. when i run from the .NET environs(F5) it works fine but how do i send it as a setup file to my colleague? please help me</content><author><name>Anonymous</name></author><thr:in-reply-to ref="2672"></thr:in-reply-to></entry><entry><id>2693</id><published>2004-10-07T02:59:00.0-05:00</published><updated>2004-10-07T02:59:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#post"></category><title type="text">JIT compilation and NGEN</title><content type="html">&lt;div&gt;A commenter to a recent blog entry asked:&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div style="PADDING-LEFT: 50px"&gt;&lt;font size="2"&gt;
&lt;/font&gt;&lt;div&gt;As to JIT, even after I read Don Box's book (Essential .NET), I am still not clear how it works. I guess that the result of JIT compilation stays in memory. In other words, every time one runs an exe file (which is MSIL), it will be JIT-compiled to the native machine code. Would it make sense if the JIT-compiled code stays on the harddrive so that there would be no need to recompile the IL code everytime?&lt;/div&gt;&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt;You can do both.&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt;JIT is, by definition, "just in time" compilation. So, yes, it's done on each load of the image. A JIT must first and foremost be blazingly fast, which reduces its opportunities for optimization.&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt;If you want to precompile down to native code once up front, typically at application installation time, you use NGEN, which stands for Native code GENeration. (This is sometimes referred to colloquially within Microsoft by the horrid name "pre-JIT" -- descriptive, I grant you, but think about what it's really saying.) Because NGEN isn't as performance-critical, it can and does perform more optimizations and gives some better native code generation than the JITter.&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;</content><author><name>herb-sutter</name></author><thr:total>8</thr:total></entry><entry><id>2697</id><published>2004-10-07T01:21:00.0-05:00</published><updated>2004-10-07T01:21:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">re: JIT compilation and NGEN</title><content type="html">"A JIT must first and foremost be blazingly 
&lt;br /&gt;fast, which reduces its opportunities for optimization."
&lt;br /&gt;
&lt;br /&gt;OTOH, a JIT compiler has runtime information available, which enables a lot of additional opportunities.
&lt;br /&gt;
&lt;br /&gt;Examples I've heard about from the Java world include: Inlining virtual functions if it is known that only one derived class has been used to actually create objects of that base class type so far, and optimizing away some special-case conditional logic within a loop if it is clear that the looping range excludes all special cases (a prominent specific example of this is removing range-checking for array accesses if the loop isn't going "too far" anyway).
&lt;br /&gt;
&lt;br /&gt;In C++, another nice idea would be to detect lack of pointer aliasing and enable fortranesque optimizations without "restrict"ions. 
&lt;br /&gt;
&lt;br /&gt;But of course, you know that already (In fact, I learned some of it from your wonderful "Inlining" article).
&lt;br /&gt;</content><author><name>Anonymous</name></author><thr:in-reply-to ref="2693"></thr:in-reply-to></entry><entry><id>2705</id><published>2004-10-07T09:16:00.0-05:00</published><updated>2004-10-07T09:16:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">re: JIT compilation and NGEN</title><content type="html">Uwe, as I mentioned yesterday in my feedback to Herb's post on VS2005, JIT compiling in the Java world is a different animal than in .NET.  When .NET compiles a class upon loading it, it compiles the entire class and will only execute the compiled code, sometimes called "managed native code".  The .NET CLR never operates in an interpretive mode on the IL.
&lt;br /&gt;
&lt;br /&gt;Most of the JIT optimizations you mention assume that the VM is running in interpretive mode by default, and compiling when it detects "hot spots".  This is the way the Java VM and JIT compiler work, but not the way the CLR works.</content><author><name>Anonymous</name></author><thr:in-reply-to ref="2693"></thr:in-reply-to></entry><entry><id>2712</id><published>2004-10-07T18:46:00.0-05:00</published><updated>2004-10-07T18:46:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">re: JIT compilation and NGEN</title><content type="html">"Because NGEN isn't as performance-critical, it can and does perform more optimizations and gives some better native code generation than the JITter." -- make a lot of sense!
&lt;br /&gt;
&lt;br /&gt;According the Jeffrey Richter´s article at
&lt;br /&gt;&lt;a href="http://www.codeguru.com/Csharp/.NET/net_general/toolsand3rdparty/article.php/c4651" target="_new"&gt;http://www.codeguru.com/Csharp/.NET/net_general/toolsand3rdparty/article.php/c4651&lt;/a&gt; , we have to use NGEN only to client apps if we have issues with load time. However server apps can be optimized better by JIT than NGEN.
&lt;br /&gt;
&lt;br /&gt;Is the previous phrase correct to server applications, too?</content><author><name>Anonymous</name></author><thr:in-reply-to ref="2693"></thr:in-reply-to></entry><entry><id>2718</id><published>2004-10-08T04:26:00.0-05:00</published><updated>2004-10-08T04:26:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">re: JIT compilation and NGEN</title><content type="html">"Most of the JIT optimizations you mention assume that the VM is running in interpretive mode by default, and compiling when it detects "hot spots". This is the way the Java VM and JIT compiler work, but not the way the CLR works. "
&lt;br /&gt;
&lt;br /&gt;There's nothing that limits on-the-fly profiling and recompilation to interpreting VMs.  The CLR already maintains a mapping between native code and IL (though it's currently a bit weak; 2.0 will make it more consistent).  It could certainly detect hotspots and recompile accordingly, and it probably should, too.
&lt;br /&gt;</content><author><name>Anonymous</name></author><thr:in-reply-to ref="2693"></thr:in-reply-to></entry><entry><id>2722</id><published>2004-10-08T07:36:00.0-05:00</published><updated>2004-10-08T07:36:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">re: JIT compilation and NGEN</title><content type="html">Chip, I don't see a difference there. IBM's Jikes VM, for example, uses a compile-only approach, too, plus optimized recompilation of hotspots. The question is, how badly do you need compilation, say of your main entry point which is run exactly once.
&lt;br /&gt;
&lt;br /&gt;There's nothing in the CLR that prevents it from doing so, too.
&lt;br /&gt;
&lt;br /&gt;The question was, how much can the CLR JIT profit from Source-to-IL compilers anyway? E.g. if Herb's C++ compiler finds out it can eliminate some array bounds checks, can it encode that into the IL? And can I ship that IL to people whose CLR doesn't trust me?
&lt;br /&gt;</content><author><name>Anonymous</name></author><thr:in-reply-to ref="2693"></thr:in-reply-to></entry><entry><id>2724</id><published>2004-10-08T08:31:00.0-05:00</published><updated>2004-10-08T08:31:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">re: JIT compilation and NGEN</title><content type="html">Matthias: I spun your question off into a new blog entry, just posted.</content><author><name>Anonymous</name></author><thr:in-reply-to ref="2693"></thr:in-reply-to></entry><entry><id>2726</id><published>2004-10-08T09:03:00.0-05:00</published><updated>2004-10-08T09:03:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">re: JIT compilation and NGEN</title><content type="html">"Chip, I don't see a difference there. IBM's Jikes VM, for example, uses a compile-only approach, too, plus optimized recompilation of hotspots. The question is, how badly do you need compilation, say of your main entry point which is run exactly once. "
&lt;br /&gt;
&lt;br /&gt;Jikes compiles Java source code to Java bytecode, which is the equivalent of CSC compiling C# source code into IL.  Jikes does not generate native code; CSC does not generate native code.  The Java VM can run in a purely interpretive mode, where bytecodes are never compiled into native machine instructions.  The CLR always compiles IL into native instructions before the code can be executed.</content><author><name>Anonymous</name></author><thr:in-reply-to ref="2693"></thr:in-reply-to></entry><entry><id>2734</id><published>2004-10-09T02:50:00.0-05:00</published><updated>2004-10-09T02:50:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">re: JIT compilation and NGEN</title><content type="html">Chip, Jikes RVM is a Virtual Machine and is a totally different project from the Jikes compiler.</content><author><name>Anonymous</name></author><thr:in-reply-to ref="2693"></thr:in-reply-to></entry><entry><id>2709</id><published>2004-10-07T21:27:00.0-05:00</published><updated>2004-10-07T21:27:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#post"></category><title type="text">C++ Coding Standards -- Contents and ETA</title><content type="html">&lt;div&gt;The &lt;a href="http://www.gotw.ca/publications/c++cs.htm"&gt;&lt;em&gt;C++ Coding Standards&lt;/em&gt; book&lt;/a&gt; is done, done, done (whew) and en route to the printer as I write this. I still hope to get a few of the very first copies couriered to me during OOPSLA week. You can &lt;a href="http://www.amazon.com/exec/obidos/ASIN/0321113586/gotwca-20"&gt;order it on Amazon&lt;/a&gt;, or get it on local bookstore shelves in North America at the end of this month.&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt;Andrei and I both had high hopes for this book, and we're bemusedly amazed that they have been both reached and exceeded. A lot of the credit goes to having Bjarne so actively involved in the production of the book, and to an awesome who's-who list of reviewers.&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt;This is, by far, the most heavily peer- and expert-reviewed book I have ever done, or have ever heard about. Most books you see on the shelves (at least, the good ones) go through review cycles where the publisher picks experts who individually go through one or more iterations of the manuscript and offer feedback, but the experts don't talk to each other. This book marks a huge departure. When you get the book, look at the Preface and its who's-who-in-C++ list of Acknowledgements -- nearly all of those people were actively involved in a combined review on an email discussion list I set up for that purpose, to the tune of about 1,000 thoughtful and detailed emails over the course of the past year. That is just hands-down the most thorough and interactive review cycle I've ever heard of for any book, well beyond the normally thorough review cycles all Addison-Wesley books experience. I like to think the book would already have been wonderful, but this really has made a remarkable difference in the richness, focus, and quality of the material -- and the avoidance of controversy, a chief aim for a book such as this that needs to focus on tried-and-true wisdom. We are incredibly grateful to all of these people for taking the time to go through the book with a fine-tooth comb.&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt;This is the book I wish I'd had on every C++ project I've worked on in the past decade. (Actually, back in the mid-1990s I started putting together an early coding standard &lt;em&gt;because&lt;/em&gt; of the lack, in my opinion, of a complete and solid coding standard. That coding standard became the basis for this book, so I guess this book had better be the book I wanted then.)&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt;We're glad it's done. We hope you'll like it and that it will benefit your team directly.&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt;I've posted a Table of Contents on the book's home page, above. Enjoy!&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;</content><author><name>herb-sutter</name></author><thr:total>6</thr:total></entry><entry><id>2711</id><published>2004-10-07T18:21:00.0-05:00</published><updated>2004-10-07T18:21:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">re: C++ Coding Standards -- Contents and ETA</title><content type="html">Nice! One more exceptional C++ book in my bookshelf.
&lt;br /&gt;
&lt;br /&gt;I pre-order this book some months ago :)
&lt;br /&gt;</content><author><name>Anonymous</name></author><thr:in-reply-to ref="2709"></thr:in-reply-to></entry><entry><id>2715</id><published>2004-10-08T02:32:00.0-05:00</published><updated>2004-10-08T02:32:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">This is the book I've been waiting for</title><content type="html">Excellent news; Herb Sutter and Andrei Alexandrescu's &amp;lt;a href="http://pluralsight.com/blogs/hsutter/archive/2004/10/07/2709.aspx"&amp;gt;C++ Coding Standards book&amp;lt;/a&amp;gt; is done!&lt;br /&gt;&lt;br /&gt;This is the book I've been wanting for ages. Whilst there are other C++ coding standard books out there but, well, they just don't have the gravitas of a book written by these two and included in Bjarne Stroustrup's C++ In Depth Series. &lt;br /&gt;&lt;br /&gt;The table of contents is &amp;lt;a href="http://www.gotw.ca/publications/c++cs.htm"&amp;gt;here&amp;lt;/a&amp;gt;. I hope the book's heavy enough to hit people with ;)</content><author><name>Anonymous</name></author><thr:in-reply-to ref="2709"></thr:in-reply-to></entry><entry><id>2736</id><published>2004-10-09T11:39:00.0-05:00</published><updated>2004-10-09T11:39:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">C   Coding Standards</title><content type="html"></content><author><name>Anonymous</name></author><thr:in-reply-to ref="2709"></thr:in-reply-to></entry><entry><id>2748</id><published>2004-10-10T12:32:00.0-05:00</published><updated>2004-10-10T12:32:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">re: C++ Coding Standards -- Contents and ETA</title><content type="html">Hmm, I wish your trackback handler didn't include the entire excerpt... In fact, I didn't even expect the second link to ping you :( 
&lt;br /&gt;
&lt;br /&gt;Sorry for making your comments look such a mess...</content><author><name>Anonymous</name></author><thr:in-reply-to ref="2709"></thr:in-reply-to></entry><entry><id>2968</id><published>2004-10-22T16:44:00.0-05:00</published><updated>2004-10-22T16:44:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">re: C++ Coding Standards -- Contents and ETA</title><content type="html">There is one very well written, in my opinion, "off-the-shelf" "C++ codding standard" - &lt;a href="http://www.programmingresearch.com/HICPP" target="_new"&gt;http://www.programmingresearch.com/HICPP&lt;/a&gt;
&lt;br /&gt;What is your opinion of it?</content><author><name>Anonymous</name></author><thr:in-reply-to ref="2709"></thr:in-reply-to></entry><entry><id>3131</id><published>2004-11-01T16:28:00.0-05:00</published><updated>2004-11-01T16:28:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">re: C++ Coding Standards -- Contents and ETA</title><content type="html">The table of contents has me drooling.
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;</content><author><name>Anonymous</name></author><thr:in-reply-to ref="2709"></thr:in-reply-to></entry><entry><id>2723</id><published>2004-10-08T14:30:00.0-05:00</published><updated>2004-10-08T14:30:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#post"></category><title type="text">Optimization + JIT/NGEN</title><content type="html">&lt;div&gt;Matthias asked:&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div style="PADDING-LEFT: 50px"&gt;The question was, how much can the CLR JIT profit from Source-to-IL compilers anyway? E.g. if Herb's C++ compiler finds out it can eliminate some array bounds checks, can it encode that into the IL? And can I ship that IL to people whose CLR doesn't trust me?&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt;If the array bounds checks are never used, eliminating them doesn't change the meaning of the program, right? :-)&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt;You're asking about verifiability and partial trust scenarios. The short answer is that optimization doesn't affect verifiability. Right now, we actually turn off a few of our optimizer's normal optimizations when optimizing IL in order to preserve verifiability.&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt;The longer answer begins with noting that optimization doesn't (had better not) ever change the meaning or effect of the code, regardless of what kind of optimization we're talking about. If it did, that would seem broken. For example, consider common optimizations like loop unrolling, code hoisting, dead branch elimination, variable folding, and so forth. Clearly those optimizations are rearrangements of the code that make the code and/or data tighter, but they do not change the visible effects of the code. The C++ standard is pretty strict about the few places where it permits optimizations that would observably change the meaning of a program, such as elision of copy constructors.&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt;C++ with its static typing and templates is very well suited to doing a great job of optimization. For example, templates are usually inlined and that gives the optimizer an easier time of seeing enough context to make better decisions (e.g., in cases like those I mentioned above) without doing more expensive analysis, up to and including whole-program analysis.&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt;In our internal testing, we regularly run various benchmarks in the different .NET languages. The benchmarks compiled in C++ usually range from -5% to +30% in execution speed (in some cases even much higher, in some corner cases lower) compared to the IL generated by other languages for the equivalent program. (What we're measuring here is VC++ -&amp;gt; back-end optimizer -&amp;gt; IL -&amp;gt; JIT -&amp;gt; native, compared to VC#/VB -&amp;gt; IL -&amp;gt; JIT -&amp;gt; native; i.e., everybody shares the JIT, it's a question of who generates better IL going into the JIT.) Of course, the performance difference matters most in code that's actually CPU-bound, but you want a compiler to generate tight code all the time so that it will do it also for your performance-critical paths.&lt;/div&gt;</content><author><name>herb-sutter</name></author></entry><entry><id>2725</id><published>2004-10-08T14:47:00.0-05:00</published><updated>2004-10-08T14:47:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#post"></category><title type="text">Bringing C++ to CLI</title><content type="html">&lt;div&gt;On the newsgroups, some folks (in particular Gerhard Menzl) asked about whether C++ features were being dropped/deemphasized by C++/CLI. The answer is no.&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt;I wrote two longer answers &lt;a href="http://groups.google.com/groups?hl=en&amp;amp;lr=&amp;amp;selm=9tgml0da1c4hf084nrsvvgi79dsqujgi01%404ax.com"&gt;here&lt;/a&gt; (Oct 1) and &lt;a href="http://groups.google.com/groups?hl=en&amp;amp;lr=&amp;amp;selm=i188m018dd4ogm3p64tq6uoa9liqd1hat0%404ax.com"&gt;here&lt;/a&gt; (Oct 6) about some of them. Further questions followed, mostly repeating the same feature requests, and just now I responded again as follows:&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div style="PADDING-LEFT: 50px"&gt;We couldn't do it all in one release, but all of the features you would like are indeed already not just planned but designed. Some are already in this release (including directly embedding managed types as directly held members of other managed types, with destructors hooked up automatically as per C++ usual). Others are on deck for to start on after this release goes out the door (including full const support on managed types, and mixed types where any type can inherit from or directly embed members of any other type). Since not everything would fit into one release, there had to be a bar, and that bar focused on MC++ parity (else we couldn't replace MC++ with the new syntax) and on key features to credibly position C++ as the systems programming language for .NET (e.g., dtors, templates).&lt;/div&gt;
&lt;div style="PADDING-LEFT: 50px"&gt; &lt;/div&gt;
&lt;div style="PADDING-LEFT: 50px"&gt;There's already a lot of C++ injected into managed types in this release, notably templates, dtors, copy ctors, copy assignment, and directly embedding managed types as values with dtors hooked up, to name some highlights. I think you'll also have a nice surprise with how STL.NET is turning out (that's not yet in the beta though).&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt;This really is about bringing C++ to CLI, not just CLI to C++.&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt;I actually think it's great that people spontaneously keep on requesting the very features that we decided had to be core in the design. That's always a reassuring validation.&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;</content><author><name>herb-sutter</name></author><thr:total>2</thr:total></entry><entry><id>3080</id><published>2004-10-29T13:08:00.0-05:00</published><updated>2004-10-29T13:08:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">re: Bringing C++ to CLI</title><content type="html">I am a big fan of C++/CLI, however I would like to make some complaints.
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;Why are there many breaking changes with C++98? There are many parts that it looks like a different language.
&lt;br /&gt;
&lt;br /&gt;For example, the default scope of managed types is local. What is the purpose of writing
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;public ref class SomeClass
&lt;br /&gt;{
&lt;br /&gt; //...
&lt;br /&gt;};
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;explicitly all the time?
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;Why the default inheritance for ref classes is public? It may be more "right", but it breaks consistency with ISO C++ needlessly (and I do not think the main criteria was being more right here, given the above).
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;Why should we define copy constructors and assignment operators for trivial swallow copies of data members explicitly?
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;Why the implicit type  conversions via copy constructors become disabled?
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;These do not add any strengths, and they add more weaknesses. </content><author><name>Anonymous</name></author><thr:in-reply-to ref="2725"></thr:in-reply-to></entry><entry><id>3082</id><published>2004-10-29T14:44:00.0-05:00</published><updated>2004-10-29T14:44:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">re: Bringing C++ to CLI</title><content type="html">Thanks Ioannis. I've responded in a separate blog post.</content><author><name>Anonymous</name></author><thr:in-reply-to ref="2725"></thr:in-reply-to></entry><entry><id>2786</id><published>2004-10-14T13:16:00.0-05:00</published><updated>2004-10-14T13:16:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#post"></category><title type="text">GC-ness and the type system</title><content type="html">&lt;div&gt;This morning, on a &lt;a href="http://groups.google.com/groups?hl=en&amp;amp;lr=&amp;amp;threadm=ckl9fq%24vte%241%40newshispeed.ch&amp;amp;rnum=1&amp;amp;prev=/groups%3Fq%3Dg:thl37532350d%26dq%3D%26hl%3Den%26lr%3D%26selm%3Dckl9fq%2524vte%25241%2540newshispeed.ch"&gt;newsgroup thread&lt;/a&gt;, Ivan Vecerina asked a common question about C++ and GC environments, notably .NET/CLI:&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div style="PADDING-LEFT: 50px"&gt;But to be garbage-collectible, a C++/CLI class must belong to a parallel, independent hierarchy.  Is this required to support GC in C++?&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt;No. Not in C++/CLI, and that is a fundamental point: GC-ness should not be per type. It should be per object.&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt;In the Managed Extensions, GC-ness was per type. That happened precisely because those extensions didn't add additional declarators and just stuck with * for everything. Thus, in the Managed Extensions, a T* meant any of three different and fundamentally incompatible things depending on the type of T, and in particular it meant a pointer into GC memory if T was of a CLI reference type. Not only does that glue GC-ness to a type, but it falls squarely in the category of obscuring an important difference: It makes life very hard for the programmer who has to remember what he can do with this * over here isn't what he can do with that * over there because they point to different kinds of types and so they mean very different things (e.g., consider trying to write an agnostic template that works correctly with all *'s when you can't know which of three incompatible things the * means). This was a mistake that C++/CLI fixes.&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt;In C++/CLI, GC-ness is per object. Now, we didn't get to implementing all of it in this first round: In the &lt;a href="http://blogs.msdn.com/hsutter/archive/2004/09/04/225736.aspx"&gt;version now in beta&lt;/a&gt; you can already put an object of any type on the stack, but you can only gcnew a managed type and you can only new a native type. But the hooks are there, and intentionally so: After this release, we definitely intend to allow gcnew of any type (including native types, so that you will get GC for native objects too, at the usually minor cost of an under-the-covers proxy) and new of any type (including CLI types).&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt;Which is desirable, as Ivan went on to point out:&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div style="PADDING-LEFT: 50px"&gt;Shouldn't it be possible, in a C++-enabled GC, to allocate any type on the GC heap, just as any type can (now) be 'allocated' on the stack?&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt;Exactly. That's the whole point of adding gcnew and ^/% -- to make GC-ness orthogonal to the type system, so that these can be applied to any type.&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt;Now, I said it was a mistake for the Managed Extensions to make GC-ness part of the type. I should add that it was nevertheless an understandable mistake, because of course CLI reference types &lt;em&gt;are&lt;/em&gt; always allocated on the GC heap only, and under the covers that's still true. But C++ will now give the semantics of putting the object elsewhere. In this release, we support putting objects of any type on the stack. Under the covers, an object of a CLI reference type is still on the GC heap because after all must be, and what's physically on the stack is a handle (CLI object reference), and compiler knows about the lifetime and calls the destructor appropriately and then the GC has nothing to do but what it's best at, namely reclaiming the bits whenever it feels best.&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt;But the under-the-covers part really is an implementation detail. Semantically, a C++ programmer can just plunk down any object on the stack and not think twice about it.&lt;br /&gt;&lt;/div&gt;</content><author><name>herb-sutter</name></author><thr:total>5</thr:total></entry><entry><id>2793</id><published>2004-10-14T13:11:00.0-05:00</published><updated>2004-10-14T13:11:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">re: GC-ness and the type system</title><content type="html">Oh, dear god, that is so cool. I haven't given it much thought before, but the fact that you'll be able to stick any object onto the GC heap is just right.</content><author><name>Anonymous</name></author><thr:in-reply-to ref="2786"></thr:in-reply-to></entry><entry><id>2836</id><published>2004-10-15T21:28:00.0-05:00</published><updated>2004-10-15T21:28:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">re: GC-ness and the type system</title><content type="html">&amp;gt;&amp;gt;In this release, we support putting objects of any type on the stack. Under the covers, an object of a CLI reference type is still on the GC heap ..., and what's physically on the stack is a handle (CLI object reference)...&amp;lt;&amp;lt;
&lt;br /&gt;
&lt;br /&gt;So the actual object on the GC heap is instantiated when the reference is declared. In other words, there is no need to explicitly instantiate the object on the GC heap, right?
&lt;br /&gt;
&lt;br /&gt;Is it possible to have objects of a CLI reference type on the non-GC heap?
&lt;br /&gt;
&lt;br /&gt;</content><author><name>Anonymous</name></author><thr:in-reply-to ref="2786"></thr:in-reply-to></entry><entry><id>2847</id><published>2004-10-16T14:37:00.0-05:00</published><updated>2004-10-16T14:37:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">re: GC-ness and the type system</title><content type="html">Kevin asked:
&lt;br /&gt;
&lt;br /&gt;&amp;gt;&amp;gt;So the actual object on the GC heap is instantiated when the reference is declared. In other words, there is no need to explicitly instantiate the object on the GC heap, right?&amp;lt;&amp;lt;
&lt;br /&gt;
&lt;br /&gt;Right, that's what happens under the covers. So, for a ref class R, writing
&lt;br /&gt;
&lt;br /&gt;  {
&lt;br /&gt;    R r; // R on the stack
&lt;br /&gt;    r.SomeFunc();
&lt;br /&gt;    ...
&lt;br /&gt;  } // calls r.~R() == r.Dispose()
&lt;br /&gt;
&lt;br /&gt;behaves as expected, although the compiler is really emitting something like:
&lt;br /&gt;
&lt;br /&gt;  {
&lt;br /&gt;    R^ r = gcnew R;
&lt;br /&gt;    r-&amp;gt;SomeFunc();
&lt;br /&gt;    ...
&lt;br /&gt;    r-&amp;gt;~R(); // == r-&amp;gt;Dispose()
&lt;br /&gt;  }
&lt;br /&gt;
&lt;br /&gt;&amp;gt;&amp;gt;Is it possible to have objects of a CLI reference type on the non-GC heap?&amp;lt;&amp;lt;
&lt;br /&gt;
&lt;br /&gt;Not in this release, but that is a future direction. More generally, the intent is to directly allow the semantics of instantiating any type in any memory location -- stack, static/global, gc heap, and native heap.
&lt;br /&gt;</content><author><name>Anonymous</name></author><thr:in-reply-to ref="2786"></thr:in-reply-to></entry><entry><id>3204</id><published>2004-11-07T02:50:00.0-05:00</published><updated>2004-11-07T02:50:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">re: GC-ness and the type system</title><content type="html">&amp;gt;&amp;gt; although the compiler is really emitting something like:
&lt;br /&gt;&amp;gt;&amp;gt; 
&lt;br /&gt;&amp;gt;&amp;gt; {
&lt;br /&gt;&amp;gt;&amp;gt; R^ r = gcnew R;
&lt;br /&gt;&amp;gt;&amp;gt; r-&amp;gt;SomeFunc();
&lt;br /&gt;&amp;gt;&amp;gt; ...
&lt;br /&gt;&amp;gt;&amp;gt; r-&amp;gt;~R(); // == r-&amp;gt;Dispose()
&lt;br /&gt;&amp;gt;&amp;gt; }
&lt;br /&gt;
&lt;br /&gt;Er, doesn't the compiler actually emit something more like:
&lt;br /&gt;
&lt;br /&gt;{
&lt;br /&gt;  R^ r = gcnew R;
&lt;br /&gt;  try
&lt;br /&gt;  {
&lt;br /&gt;    r-&amp;gt;SomeFunc();
&lt;br /&gt;    ...
&lt;br /&gt;  }
&lt;br /&gt;  finally
&lt;br /&gt;  {
&lt;br /&gt;    r-&amp;gt;~R(); // == r-&amp;gt;Dispose()
&lt;br /&gt;  }
&lt;br /&gt;}
&lt;br /&gt;
&lt;br /&gt;(Hoping this formats ok...)</content><author><name>Anonymous</name></author><thr:in-reply-to ref="2786"></thr:in-reply-to></entry><entry><id>32824</id><published>2006-08-07T03:12:00.0-05:00</published><updated>2006-08-07T03:12:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">垃圾收集特性与类型系统[2004年10月14日]</title><content type="html">C  /CLI???????,?“CLI??”??????????“????”?gcnew?^?????????,?????????,??????CLI????</content><author><name>Anonymous</name></author><thr:in-reply-to ref="2786"></thr:in-reply-to></entry><entry><id>2828</id><published>2004-10-15T15:37:00.0-05:00</published><updated>2004-10-15T15:37:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#post"></category><title type="text">Unifying STL and .NET containers</title><content type="html">&lt;div&gt;Ivan also noted:&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div style="PADDING-LEFT: 50px"&gt;And it seems to only get worse when I see the explosion of the number of often overlapping container and algorithm libraries.&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt;That was a major problem in pre-standard C++, and the reason that C++ needed a standardized container library. I can understand the concern that now C++ has its standard containers, but .NET already has &lt;em&gt;its&lt;/em&gt; own containers -- so what is C++/CLI doing to avoid that "explosion" in container libraries?&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt;Answer: Wait till you see STL.NET, which is just short of magical in terms of unification to eliminate the container explosion. STL.NET isn't yet in the current beta compiler, but will be available in the Visual C++ 2005 release.&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt;In short, STL.NET brings C++'s very own containers, iterators, and algorithms straight to the managed world with full interoperability with the CLI container interfaces. This is what you can do (only) in a language that supports both templates and generics: Have a template, like stdcli::vector&amp;lt;T&amp;gt;, that implements a generic interface, like IList&amp;lt;T&amp;gt;. You can use it as a vector (it is one). You can use it as an IList (it is that, too).&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt;That's groovy, and it really brings together the best of both worlds: C++ code gets its usual full STL style of programming and full template specialization and everything else that makes the C++ standard library so hugely powerful. And you can still take one of those container objects and pass it directly to a C# or VB app that expects an IList&amp;lt;T&amp;gt; because it offers that interface too.&lt;br /&gt;&lt;/div&gt;
&lt;div&gt;I think the VC++ libraries team, together with Dinkumware, did a pretty nifty piece of engineering on this one. Kudos to those folks.&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt; &lt;/div&gt;</content><author><name>herb-sutter</name></author><thr:total>4</thr:total></entry><entry><id>2902</id><published>2004-10-19T21:29:00.0-05:00</published><updated>2004-10-19T21:29:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">re: Unifying STL and .NET containers</title><content type="html">Wonderful</content><author><name>Anonymous</name></author><thr:in-reply-to ref="2828"></thr:in-reply-to></entry><entry><id>4081</id><published>2004-12-25T02:02:00.0-05:00</published><updated>2004-12-25T02:02:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">re: Unifying STL and .NET containers</title><content type="html">Sounds very good, however I think a good idea would also be to make the entire standard library  managed, sometime in the future (why not, even cout).
&lt;br /&gt;
&lt;br /&gt;And place everything where it belongs in the std namespace.
&lt;br /&gt;
&lt;br /&gt;I am talking about sometime in the future, not for VS 2005 of course.</content><author><name>Anonymous</name></author><thr:in-reply-to ref="2828"></thr:in-reply-to></entry><entry><id>4083</id><published>2004-12-25T08:34:00.0-05:00</published><updated>2004-12-25T08:34:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">re: Unifying STL and .NET containers</title><content type="html">We thought of doing a /clr build of the standard C and C++ libraries themselves, and we might still do it in the future.
&lt;br /&gt;
&lt;br /&gt;The plus side would be that it would give you more portable executables that use the C/C++ stdlibs. In Whidbey, you can build portable executables, or you can seamlessly use the C/C++ stdlibs; you just can't do both at the same time, as I've mentioned in past blogs and newsgroup discussions (see Google and comp.lang.c++.moderated).
&lt;br /&gt;
&lt;br /&gt;The minus side right now is that the performance wouldn't be good enough, particular in a managed build of the low-level C runtime library functions that most everything in the C and C++ stdlibs is built on. It could probably be made to have acceptable performance, but not without significant engineering work we didn't have time to invest in this release.
&lt;br /&gt;
&lt;br /&gt;Good idea, though, and one that could well be pursued in the future.
&lt;br /&gt;
&lt;br /&gt;</content><author><name>Anonymous</name></author><thr:in-reply-to ref="2828"></thr:in-reply-to></entry><entry><id>4087</id><published>2004-12-26T03:21:00.0-05:00</published><updated>2004-12-26T03:21:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">re: Unifying STL and .NET containers</title><content type="html">&lt;br /&gt;Well, I guess one could start from the C++ newer facilities and leave the C subset facilities for the end.
&lt;br /&gt;
&lt;br /&gt;Now we have STL .NET which is very useful, then cout, cin, wcout, wcin etc could follow (perhaps some facilities could be implemented with Console facilities, like operator &amp;lt;&amp;lt; of cout by using Console::Write() or something), and then the C subset ones.
&lt;br /&gt;
&lt;br /&gt;That is, we could get a /clr:safe managed standard library gradually, and not in just one release.
&lt;br /&gt;
&lt;br /&gt;A completely managed C++ is what makes sense in   a managed environment (that is, CLR is the platform here).
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;So I think a completely managed C++ implementation would be great.
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;Also I want to repeat here that it is important that C++/CLI should preserve the C++ semantics, like default private inheritance for classes etc.
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;One very interesting rational that C++/CLI must follow is the one described by Dennis Ritchie regarding C90. You may check it here:
&lt;br /&gt;
&lt;br /&gt;&lt;a href="http://cm.bell-labs.com/cm/cs/who/dmr/chist.pdf" target="_new"&gt;http://cm.bell-labs.com/cm/cs/who/dmr/chist.pdf&lt;/a&gt;  [64 KB PDF]
&lt;br /&gt;
&lt;br /&gt;You may check there the "Standardization" section on pages 10-11, especially the part:
&lt;br /&gt;
&lt;br /&gt;"From the beginning, the X3J11 committee took a cautious, conservative view of language
&lt;br /&gt;extensions. Much to my satisfaction, they took seriously their goal: ‘to develop a clear, consistent, and unambiguous Standard for the C programming language which codifies the common,
&lt;br /&gt;existing definition of C and which promotes the portability of user programs across C language
&lt;br /&gt;environments.’ [ANSI 89] The committee realized that mere promulgation of a standard does not
&lt;br /&gt;make the world change."</content><author><name>Anonymous</name></author><thr:in-reply-to ref="2828"></thr:in-reply-to></entry><entry><id>2855</id><published>2004-10-17T21:30:00.0-05:00</published><updated>2004-10-17T21:30:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#post"></category><title type="text">Two new articles, and upcoming talks this month</title><content type="html">&lt;div&gt;I've just written &lt;a href="http://www.gotw.ca/publications"&gt;two new articles&lt;/a&gt;, which will be available in print around the third week of November:&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;ul type="disc" style="MARGIN-TOP: 0px; MARGIN-BOTTOM: 0px"&gt;
&lt;li&gt;&lt;font size="2"&gt;&lt;strong&gt;Compatibilities&lt;/strong&gt;,&lt;br /&gt;&lt;font color="#000080"&gt;&lt;em&gt;C/C++ Users Journal&lt;/em&gt;, 22(12), December 2004.&lt;/font&gt;&lt;br /&gt;C++, the real world, and link and binary compatibility. This article covers in detail some common, and commonly-reported, issues in sharing objects between separately compiled functions.&lt;/font&gt;&lt;/li&gt;&lt;/ul&gt;
&lt;div&gt; &lt;/div&gt;
&lt;ul type="disc" style="MARGIN-TOP: 0px; MARGIN-BOTTOM: 0px"&gt;
&lt;li&gt;&lt;strong&gt;Alias&lt;/strong&gt;&lt;font size="2"&gt; (with Jim Hyslop),&lt;br /&gt;&lt;font color="#000080"&gt;&lt;em&gt;C/C++ Users Journal&lt;/em&gt;, 22(12), December 2004.&lt;/font&gt;&lt;br /&gt;When are two variables really two variables? When the real problem can be aliasing, don’t be too quick to blame macros…&lt;/font&gt;&lt;/li&gt;&lt;/ul&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt;I'll also be &lt;a href="http://www.gotw.ca/news.htm"&gt;giving talks&lt;/a&gt; on October 27 in Vancouver, British Columbia, Canada:&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;ul type="disc" style="MARGIN-TOP: 0px; MARGIN-BOTTOM: 0px"&gt;
&lt;li&gt;&lt;a href="http://www.oopsla.org/2004/ShowEvent.do?id=804"&gt;OOPSLA&lt;/a&gt;: I'll be giving an invited talk titled "Concrete Languages on Virtual Platforms." The talk is about our experience with C++/CLI in not only bridging but beneficially merging two very different worlds: Enabling existing performance- and hardware-oriented languages to operate seamlessly and with first-class status in modern virtual-machine and garbage-collected environments, with strong benefits to both partners.&lt;/li&gt;&lt;/ul&gt;
&lt;div&gt; &lt;/div&gt;
&lt;ul type="disc" style="MARGIN-TOP: 0px; MARGIN-BOTTOM: 0px"&gt;
&lt;li&gt;Vancouver C++ Users Group: At 7:00pm the same day, I'll be giving another talk just a couple of blocks away from the OOPSLA site. The street address is 580 Granville St., at the ActiveState offices, and I believe it's a public meeting so do swing by if you're in town. The local C++UG has asked me to speak on my and Andrei's new book &lt;em&gt;&lt;a href="http://www.gotw.ca/publications/coding.htm"&gt;C++ Coding Standards&lt;/a&gt;&lt;/em&gt; which should be on bookstore shelves at the end of this month. I plan to give an informal talk with lots of interaction including an overview of the book, why I think coding standards and this book in particular are important, and selected Items that I think are particularly interesting. Finally, I hope to have some of the very first copies of &lt;em&gt;C++ Coding Standards&lt;/em&gt; with me, and if I do then I'll give away an autographed copy -- so come and join in the fun.&lt;/li&gt;&lt;/ul&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt;If you're coming to OOPSLA, or live near Vancouver, I hope to see you there!&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt; &lt;/div&gt;</content><author><name>herb-sutter</name></author><thr:total>3</thr:total></entry><entry><id>2876</id><published>2004-10-18T09:38:00.0-05:00</published><updated>2004-10-18T09:38:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">re: Two new articles, and upcoming talks this month</title><content type="html">Welcome to Beautiful British Columbia and Vancouver. I will definetely be there!</content><author><name>Anonymous</name></author><thr:in-reply-to ref="2855"></thr:in-reply-to></entry><entry><id>3057</id><published>2004-10-28T20:23:00.0-05:00</published><updated>2004-10-28T20:23:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">re: Two new articles, and upcoming talks this month</title><content type="html">For anyone who couldn't attend the OOPSLA conference, check out this URL: Programming Language of 2014 (&lt;a href="http://www.microsoft-watch.com/article2/0,1995,1684698,00.asp" target="_new"&gt;http://www.microsoft-watch.com/article2/0,1995,1684698,00.asp&lt;/a&gt;)</content><author><name>Anonymous</name></author><thr:in-reply-to ref="2855"></thr:in-reply-to></entry><entry><id>3110</id><published>2004-10-31T18:25:00.0-05:00</published><updated>2004-10-31T18:25:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">re: Two new articles, and upcoming talks this month</title><content type="html">Didn't recognize you without the moustache.  I hope you manage to keep that Microsoft-independent way of thinking you showed in the VM/C++ talk.</content><author><name>Anonymous</name></author><thr:in-reply-to ref="2855"></thr:in-reply-to></entry><entry><id>2972</id><published>2004-10-23T19:42:00.0-05:00</published><updated>2004-10-23T19:42:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#post"></category><title type="text">The fall 2004 ISO C++ standards meeting</title><content type="html">&lt;div&gt;Whew. We just finished up with the ISO C++ standards meeting, held in Redmond, WA, USA from October 17-22. There were long days; e.g., Monday went until 11pm with a presentation by Andrei Alexandrescu on thread/concurrency support for C++, based on &lt;a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2004/n1680.pdf"&gt;this paper&lt;/a&gt; by Andrei and highly-respected friends, and Wednesday went until after 9pm with a session led by Bjarne Stroustrup to organize meaningful subgroups to parallelize the C++0x evolution work. Briefly, we had good progress in two areas:&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt;First, the final technical changes were voted into the Library Extensions technical report (the pre-final version going into this meeting is &lt;a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2004/n1687.pdf"&gt;here&lt;/a&gt;), and this back of extensions to the C++ Standard Library is now essentially technically complete. An updated version will appear in the post-meeting mailing a few weeks from now and be available online. I'll try to remember to post a link when it appears. This batch of extensions includes stuff like shared_ptr, hash-based containers, regular expressions, and other stuff including a slew of mathematical functions.&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt;Second, the evolution working group moved forward on several proposals which are likely to be voted into Draft Standard C++ at our next meeting (Norway, April 2004). I'll report on those more when they're really "in." But to parallelize and speed up its work, Bjarne has organized the evolution working group into three chunks. Here they are, with the name of the person chairing each subgroup:&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;ul type="disc" style="MARGIN-TOP: 0px; MARGIN-BOTTOM: 0px"&gt;
&lt;li&gt;&lt;strong&gt;Support for library building (Bjarne Stroustrup):&lt;/strong&gt; This will focus on areas like better support for generic programming (e.g., concepts).&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Modularity and libraries (Pete Becker):&lt;/strong&gt; This will focus on standardizing support for libraries (including dynamic libraries) and providing a real module system in C++.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Safety, regularity, and performance (Herb Sutter):&lt;/strong&gt; This will focus on issues like security, threading, and garbage collection.&lt;/li&gt;&lt;/ul&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt;There's one more evolution-related group but which we want to fall mostly under the library working group because we'd like the extensions to primarily emphasize library extensions, not language extensions:&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div align="left"&gt;
&lt;ul type="disc" style="MARGIN-TOP: 0px; MARGIN-BOTTOM: 0px"&gt;
&lt;li&gt;&lt;strong&gt;Support for novices and incidental programmers (tbd;&lt;/strong&gt; for now it's Matt Austern&lt;strong&gt;):&lt;/strong&gt; In this area we want to heavily concentrate on providing simplification via libraries, so we'd like this to be led by the library working group.&lt;/li&gt;&lt;/ul&gt;
&lt;div&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div&gt;It'll be interesting to see how much progress we can make on these fronts between meetings over the next six months.&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt; &lt;/div&gt;</content><author><name>herb-sutter</name></author><thr:total>2</thr:total></entry><entry><id>3117</id><published>2004-11-01T02:41:00.0-05:00</published><updated>2004-11-01T02:41:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">re: The fall 2004 ISO C++ standards meeting</title><content type="html">The real problem is that the standards committee will never do what C++ really needs to have.
&lt;br /&gt;
&lt;br /&gt;The "C" in "C++" is no longer a feature; it's a liability.  It means that C++ inherits a braindead compilation model and syntax.  The syntax is limiting in all sorts of ways; it's frustrating for both novices and experts alike (gotchas like int* ptr, notAPtr; "most vexing parse", etc.); the difficulty of accurate parsing means that C++ is lacking e.g. good refactoring/code analysis/pretty-printing tools.
&lt;br /&gt;
&lt;br /&gt;The focus should be on the "++"; not the "C".
&lt;br /&gt;
&lt;br /&gt;But excising the Cness will never be done because it'll be a major breaking change, and so the language will be forever hobbled.
&lt;br /&gt;</content><author><name>Anonymous</name></author><thr:in-reply-to ref="2972"></thr:in-reply-to></entry><entry><id>3783</id><published>2004-12-08T11:29:00.0-05:00</published><updated>2004-12-08T11:29:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">re: The fall 2004 ISO C++ standards meeting</title><content type="html">I agree with DrPizza in a lot of ways, but I'm not quite the expert as other people.  I would really like a language that is just like C++ without the C gotchas, but not to the extent of Java or C#.  
&lt;br /&gt;
&lt;br /&gt;It would also enforce a lot of the items that Herb wrote about in the Coding Standards book.  Instead of having to remember to use the idioms, it would be built into the language.</content><author><name>Anonymous</name></author><thr:in-reply-to ref="2972"></thr:in-reply-to></entry><entry><id>3081</id><published>2004-10-29T20:42:00.0-05:00</published><updated>2004-10-29T20:42:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#post"></category><title type="text">Breaking changes?</title><content type="html">&lt;div&gt;In response to another blog entry, Ioannis Vranos wrote:&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div style="PADDING-LEFT: 50px"&gt;I am a big fan of C++/CLI,&lt;/div&gt;
&lt;div style="PADDING-LEFT: 50px"&gt; &lt;/div&gt;
&lt;div&gt;Thanks! The support is most appreciated.&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt;And so is the feedback. I'm going to push back a bit on some of these specific comments, but please don't mistake that for a lack of interest in knowing about things we may have got wrong or could do better -- I always want to know about those things.&lt;/div&gt;
&lt;div style="PADDING-LEFT: 50px"&gt; &lt;/div&gt;
&lt;div style="PADDING-LEFT: 50px"&gt;however I would like to make some complaints. &lt;/div&gt;
&lt;div style="PADDING-LEFT: 50px"&gt; &lt;/div&gt;
&lt;div style="PADDING-LEFT: 50px"&gt;Why are there many breaking changes with C++98? There are many parts that it looks like a different language. &lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt;Just a nit: We might not be using the same terminology here. To me a "breaking change" is a change that breaks, or changes the meaning of, existing valid code -- in this case, of an existing valid ISO C++ program. None of C++/CLI's these do that, and there are very few corner cases that actually are breaking changes. C++/CLI is pretty much a set of pure extensions that don't break or change the meaning of existing programs. That's very important, so I'm just taking a second to mention that so nobody gets an impression that it's otherwise.&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div style="PADDING-LEFT: 50px"&gt;For example, the default scope of managed types is local. What is the purpose of writing &lt;/div&gt;
&lt;div style="PADDING-LEFT: 50px"&gt;&lt;br /&gt;public ref class SomeClass &lt;br /&gt;{ &lt;br /&gt;  //... &lt;br /&gt;}; &lt;/div&gt;
&lt;div style="PADDING-LEFT: 50px"&gt; &lt;/div&gt;
&lt;div style="PADDING-LEFT: 50px"&gt;explicitly all the time? &lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt;I'm not sure I understand. First, this doesn't impact ISO C++ compatibility because ISO C++ doesn't currently have any standardized notion of libraries or assemblies, or of visibility of types/code outside an assembly. Second, the default visibility is private for &lt;em&gt;all&lt;/em&gt; kinds of classes, not just ref classes. This is consistent. (And the default visibility for an assembly's contents should be private, just as the default visibility for a class's members is and should be private. You don't want to expose internals by default, but only do so intentionally.)&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div style="PADDING-LEFT: 50px"&gt;Why the default inheritance for ref classes is public? It may be more "right", but it breaks consistency with ISO C++ needlessly (and I do not think the main criteria was being more right here, given the above). &lt;/div&gt;
&lt;div style="PADDING-LEFT: 50px"&gt; &lt;/div&gt;
&lt;div&gt;This is a valid concern, and if enough people complain then we probably ought to simply require the "public." But note that the reasoning here is reasonable: No matter what syntax we choose, it really is illegal for a ref class to be a nonpublic base class; it must be public. So the choices are: a) force programmers to always write an (&lt;em&gt;always&lt;/em&gt; redundant) "public" in front of every base class that's a CLI reference or interface type; or b) make writing the "public" optional. We chose b) for usability reasons. If there's enough feedback that people want to be forced to write the "public" we're willing to do that in the future (as the usual gradual multi-release migration via deprecation, not as a sudden breaking change from one release to another, of course).&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div style="PADDING-LEFT: 50px"&gt;Why should we define copy constructors and assignment operators for trivial swallow copies of data members explicitly? &lt;/div&gt;
&lt;div style="PADDING-LEFT: 50px"&gt; &lt;/div&gt;
&lt;div&gt;This also is a valid issue, but we're actually following normal C++ rules here. The issue Ioannis describes is that, unless you do something special or the compiler can't generate them, by default a native class has four compiler-generated functions: a default constructor, destructor, a copy constructor, and a copy assignment operator. The last two are what give a type "value semantics." In C++/CLI native types continue to have all four by default (in the cases where ISO C++ would generate them), and ref types have the first two by default but do not have the last two by default… because ISO C++ would not generate them.&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt;Consider this example in ISO C++:&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div style="PADDING-LEFT: 50px"&gt;class B {&lt;/div&gt;
&lt;div style="PADDING-LEFT: 50px"&gt;public:&lt;/div&gt;
&lt;div style="PADDING-LEFT: 50px"&gt;  B() { }&lt;/div&gt;
&lt;div style="PADDING-LEFT: 50px"&gt;private:&lt;/div&gt;
&lt;div style="PADDING-LEFT: 50px"&gt;  // the idiom for disabling copy semantics in ISO C++&lt;/div&gt;
&lt;div style="PADDING-LEFT: 50px"&gt;  B( const B&amp;amp;); // hide the copy constructor, and don't define it&lt;/div&gt;
&lt;div style="PADDING-LEFT: 50px"&gt;  B&amp;amp; operator=( const B&amp;amp; ); // hide the copy assignment operator, and don't define it&lt;/div&gt;
&lt;div style="PADDING-LEFT: 50px"&gt;};&lt;/div&gt;
&lt;div style="PADDING-LEFT: 50px"&gt; &lt;/div&gt;
&lt;div style="PADDING-LEFT: 50px"&gt;class D : public B { };&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt;Here class D has a compiler-generated default constructor and destructor, but it does &lt;em&gt;not&lt;/em&gt; have a compiler-generated copy constructor or copy assignment operator because the compiler-generated ones don't work -- D can't access the base operations because they're private, and so ISO C++ says that D won't get those functions because they can't be generated.&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt;And that is the same reason why ref classes, which implicitly inherit from System::Object, don't get them either -- because Object doesn't have them. So according to the ISO C++ rules the compiler won't generate them.&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt;Note: If you write these functions yourself, you can have a ref class with copy semantics, and that's cool. In that case, if you inherit from that ref class, you should &lt;em&gt;then&lt;/em&gt; get compiler-generated copy functions in the derived class, because they could be generated. We agree with that, but we decided that this case didn't make the bar for this release, but we do intend to support that after this release. We don't currently. It's a less frequent case than the general case you cite, but I did want to acknowledge your point and show that although the status quo follows ISO C++ rules in general your point is in some cases a valid criticism that we will address in the future.&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div style="PADDING-LEFT: 50px"&gt;Why the implicit type conversions via copy constructors become disabled? &lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt;They are still enabled, but only get invoked automatically when you're actually creating an object, not when you're just casting. That's how the CLI works, and we expose the CLI semantics here. For ref classes, the copy constructor is pretty much like having an &lt;strong&gt;explicit&lt;/strong&gt; copy constructor in ISO C++.&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt; &lt;/div&gt;</content><author><name>herb-sutter</name></author><thr:total>6</thr:total></entry><entry><id>3084</id><published>2004-10-29T17:03:00.0-05:00</published><updated>2004-10-29T17:03:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">re: Breaking changes?</title><content type="html">&lt;br /&gt;
&lt;br /&gt;* "Just a nit: We might not be using the same terminology here. To me a "breaking change" is a change that breaks, or changes the meaning of, existing valid 
&lt;br /&gt;
&lt;br /&gt;code -- in this case, of an existing valid ISO C++ program. None of C++/CLI's these do that, and there are very few corner cases that actually are breaking 
&lt;br /&gt;
&lt;br /&gt;changes. C++/CLI is pretty much a set of pure extensions that don't break or change the meaning of existing programs. That's very important, so I'm just 
&lt;br /&gt;
&lt;br /&gt;taking a second to mention that so nobody gets an impression that it's otherwise."
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;Yes my terminology was not probably accurate. I was talking about a different "feeling" (perhaps better described as semantics) of C++/CLI in those issues.
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;* "Second, the default visibility is private for all kinds of classes, not just ref classes."
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;OK.
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;*"This is a valid concern, and if enough people complain then we probably ought to simply require the "public." But note that the reasoning here is 
&lt;br /&gt;
&lt;br /&gt;reasonable: No matter what syntax we choose, it really is illegal for a ref class to be a nonpublic base class; it must be public."
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;OK, I was missing that. However what if this changes in the future? Maintaining the ISO C++ semantics would be more consistent.
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;* "And that is the same reason why ref classes, which implicitly inherit from System::Object, don't get them either -- because Object doesn't have them. So 
&lt;br /&gt;
&lt;br /&gt;according to the ISO C++ rules the compiler won't generate them."
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;So do you mean that System::Object is missing the default ones? OK, I see the reason. However in general, wouldn't it be better if System::Object didn't miss 
&lt;br /&gt;
&lt;br /&gt;them? :-)
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;* "Note: If you write these functions yourself, you can have a ref class with copy semantics, and that's cool. In that case, if you inherit from that ref 
&lt;br /&gt;
&lt;br /&gt;class, you should then get compiler-generated copy functions in the derived class, because they could be generated. We agree with that, but we decided that 
&lt;br /&gt;
&lt;br /&gt;this case didn't make the bar for this release, but we do intend to support that after this release."
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;That is good news, definitely we will need that. It will effectively save people from defining trivial shallow copy operations explicitly, all the time.
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;* They are still enabled, but only get invoked automatically when you're actually creating an object, not when you're just casting. That's how the CLI works, 
&lt;br /&gt;
&lt;br /&gt;and we expose the CLI semantics here. For ref classes, the copy constructor is pretty much like having an explicit copy constructor in ISO C++."
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;I do not know much about the implementation details, but wouldn't it be fairly easy to maintain the ISO C++ semantics here? If not, just to be more "legally" 
&lt;br /&gt;
&lt;br /&gt;accurate, shouldn't it be better the explicit keyword to be required for the copy constructors until things change? That would give more feeling to C++ 
&lt;br /&gt;
&lt;br /&gt;programmers on what to expect and maps pretty much to reality.
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;Thanks for providing answers!</content><author><name>Anonymous</name></author><thr:in-reply-to ref="3081"></thr:in-reply-to></entry><entry><id>3085</id><published>2004-10-29T18:22:00.0-05:00</published><updated>2004-10-29T18:22:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">re: Breaking changes?</title><content type="html">Some small correction:
&lt;br /&gt;
&lt;br /&gt;With 
&lt;br /&gt;
&lt;br /&gt;"Why the implicit type conversions via copy constructors become disabled?"
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;I really meant to say
&lt;br /&gt;
&lt;br /&gt;"Why the implicit type conversions via constructors become disabled?"
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;In any case, if there is a platform restriction and makes them explicit, then I think the explicit keyword should be requirement.
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;By sticking to syntax and behaviour of ISO C++ (the semantics), the standard remains open to future CLI expansion (private base classes, implicit type conversions via constructors, etc).
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;From an experience of newcomer point of view, when I first came across those two differences, I considered them confusing, and although there is a CLI reason for that (current CLI restrictions), the programmer expects what he types, so by typing keyword explicit for a copy constructor, he can understand that it is a platform restriction, otherwise it does not make sense.</content><author><name>Anonymous</name></author><thr:in-reply-to ref="3081"></thr:in-reply-to></entry><entry><id>3087</id><published>2004-10-29T21:20:00.0-05:00</published><updated>2004-10-29T21:20:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">re: Breaking changes?</title><content type="html">&amp;gt;&amp;gt;And that is the same reason why ref classes, which implicitly inherit from System::Object, don't get them either -- because Object doesn't have them. So according to the ISO C++ rules the compiler won't generate them.&amp;lt;&amp;lt;
&lt;br /&gt;This seems to be a dilemma in deciding which rules (ISO C++ vs. other CLI compliant languages in .NET) to bend. Languages like C# and VB.NET do not support the overloading of the assignment operator, and all provide the compiler-generated assignment operator for the derived class (as class D) even though it is implemented as shallow copying. 
&lt;br /&gt;</content><author><name>Anonymous</name></author><thr:in-reply-to ref="3081"></thr:in-reply-to></entry><entry><id>3108</id><published>2004-10-31T15:07:00.0-05:00</published><updated>2004-10-31T15:07:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">re: Breaking changes?</title><content type="html">Kevin wrote: &amp;gt;&amp;gt;Languages like C# and VB.NET do not support the overloading of the assignment operator, and all provide the compiler-generated assignment operator for the derived class (as class D) even though it is implemented as shallow copying.&amp;lt;&amp;lt;
&lt;br /&gt;
&lt;br /&gt;Actually, I don't think it's what you think. C# and VB don't distinguish between pointer and pointee, and the copying isn't "shallow" so much as it's copying the object references (handles in C++/CLI). It's clearer in C++ because the distinction between pointer and pointee is explicit in C++, so that you can tell the difference between:
&lt;br /&gt;
&lt;br /&gt;  ref class R { /*...*/ };
&lt;br /&gt;  R^ r1 = gcnew R;
&lt;br /&gt;  R^ r2 = gcnew R;
&lt;br /&gt;
&lt;br /&gt;  r1 = r2;   // 1: copy the handles
&lt;br /&gt;  *r1 = *r2; // 2: copy the values (objects)
&lt;br /&gt;
&lt;br /&gt;In C# this looks like:
&lt;br /&gt;
&lt;br /&gt;  class R { /*...*/ };
&lt;br /&gt;  R r1 = new R();
&lt;br /&gt;  R r2 = new R();
&lt;br /&gt;
&lt;br /&gt;  r1 = r2;   // 1: copy the handles
&lt;br /&gt;
&lt;br /&gt;The fundamental difference here is what Ioannis alludes to:
&lt;br /&gt;
&lt;br /&gt;&amp;gt;&amp;gt;However in general, wouldn't it be better if System::Object didn't miss them [copy construction and copy assignment]? :-)&amp;lt;&amp;lt;
&lt;br /&gt;
&lt;br /&gt;Maybe, but that was the Frameworks' decision. The CLI supports copy semantics (which we hook into) but doesn't require them. The CLI base class library reference types, and essentially all reference types authored in C# or VB, are polymorphic reference types (hence the name); those languages don't really support value-like ref class types. C++ is the only language that additionally allows you to write ref classes with value semantics; i.e., C++ ref classes are a superset of other languages', and C++ exposes the full range of possible functionality although the C++ compiler has to know to insert the calls to invoke the copying in the right places.
&lt;br /&gt;
&lt;br /&gt;</content><author><name>Anonymous</name></author><thr:in-reply-to ref="3081"></thr:in-reply-to></entry><entry><id>3219</id><published>2004-11-07T23:35:00.0-05:00</published><updated>2004-11-07T23:35:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">re: Breaking changes?</title><content type="html">&lt;br /&gt;"Maybe, but that was the Frameworks' decision. The CLI supports copy semantics (which we hook into) but doesn't require them. The CLI base class library reference types, and essentially all reference types authored in C# or VB, are polymorphic reference types (hence the name); those languages don't really support value-like ref class types. C++ is the only language that additionally allows you to write ref classes with value semantics; i.e., C++ ref classes are a superset of other languages', and C++ exposes the full range of possible functionality although the C++ compiler has to know to insert the calls to invoke the copying in the right places".
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;In which case, the keyword explicit should be mandatory.</content><author><name>Anonymous</name></author><thr:in-reply-to ref="3081"></thr:in-reply-to></entry><entry><id>3690</id><published>2004-11-27T14:49:00.0-05:00</published><updated>2004-11-27T14:49:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">re: Destructors vs. GC? Destructors   GC!</title><content type="html"></content><author><name>Anonymous</name></author><thr:in-reply-to ref="3081"></thr:in-reply-to></entry><entry><id>3185</id><published>2004-11-04T16:05:00.0-05:00</published><updated>2004-11-04T16:05:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#post"></category><title type="text">C++ Coding Standards Review</title><content type="html">&lt;div&gt;Chuck Allison wrote a nice summary and viewpoint of the book. It is almost embarrassingly positive, but I'll share it anyway. &amp;lt;cough&amp;gt;&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt;In part, Chuck writes:&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div style="PADDING-LEFT: 50px"&gt;You have never seen a book quite like this before. … This is the first “coding standards” book I’ve seen that works. The organization is clear and intuitive, the topics are pertinent, and the content is of the highest quality. All the standards contained herein have been rigorously scrutinized (I have hundreds of emails to prove it!) by a generous sampling of the leading contributors in the C++ world, as attested by the acknowledgements in the Preface.&lt;/div&gt;
&lt;div style="PADDING-LEFT: 50px"&gt; &lt;/div&gt;
&lt;div style="PADDING-LEFT: 50px"&gt;More than just style guidelines and “gotcha” warnings, C++ Coding Standards clarifies the idioms and practices that pertain specifically to successful C++ software. Even better, you can’t avoid deepening your mastery of the finer points of C++ as you read. This is the singularly authoritative Writ of Common Wisdom for the entire C++ development experience.&lt;/div&gt;
&lt;div style="PADDING-LEFT: 50px"&gt; &lt;/div&gt;
&lt;div style="PADDING-LEFT: 50px"&gt;Chuck Allison&lt;br /&gt;Editor, The C++ Source&lt;br /&gt;&lt;/div&gt;
&lt;div&gt;Thanks, Chuck! We'll be blushing for days. I'll put a copy on the &lt;a href="http://www.gotw.ca/publications/c++cs.htm"&gt;book's page&lt;/a&gt;.&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt; &lt;/div&gt;</content><author><name>herb-sutter</name></author><thr:total>2</thr:total></entry><entry><id>3187</id><published>2004-11-04T15:51:00.0-05:00</published><updated>2004-11-04T15:51:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">re: C++ Coding Standards Review</title><content type="html">Yes. I totally agree with him. After read one third of it, I would say I wanted this book years ago. Although I had your lucky book from VANCPP meeting, I ordered more for other guys. Thank you for your outstanding work!</content><author><name>Anonymous</name></author><thr:in-reply-to ref="3185"></thr:in-reply-to></entry><entry><id>3500</id><published>2004-11-14T19:20:00.0-05:00</published><updated>2004-11-14T19:20:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">re: C++ Coding Standards Review</title><content type="html">This book is nice.  All c++ programmers should probably give it a look through.  Most of the time it feels as if the gap between 99% of the c++ programmers out there and the remaining 1% who have actually mastered the language is too large to ever be breached (well...while there are still people actively programming c++) but books like this, and Scott Meyer's books, help a bit.
&lt;br /&gt;
&lt;br /&gt;I have a question unrelated to the book. I have been wondering if the Microsoft compiler (.NET 2003) locks on construction of local statics?  It seems to me that it does.  This is unlike the behavior of most compilers when dealing with threads + local static construction.</content><author><name>Anonymous</name></author><thr:in-reply-to ref="3185"></thr:in-reply-to></entry><entry><id>3605</id><published>2004-11-21T21:19:00.0-05:00</published><updated>2004-11-21T21:19:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#post"></category><title type="text">Two new articles</title><content type="html">&lt;div align="left"&gt;As I do most months, I've once again just written &lt;a href="http://www.gotw.ca/publications"&gt;two new articles&lt;/a&gt;, which will be available in print around the third week of December:&lt;/div&gt;
&lt;div align="left"&gt; &lt;/div&gt;
&lt;ul type="disc" style="MARGIN-TOP: 0px; MARGIN-BOTTOM: 0px"&gt;
&lt;li&gt;
&lt;div align="left"&gt;&lt;font size="2"&gt;&lt;strong&gt;Trip Report: October 2004&lt;/strong&gt;,&lt;br /&gt;&lt;font color="#000080"&gt;&lt;em&gt;C/C++ Users Journal&lt;/em&gt;, 23(1), January 2005.&lt;/font&gt;&lt;br /&gt;This month, an update on the most recent C++ standards meeting, and the progress on the C++0x standard language and library. [Actually, this wasn't quite as much of a "trip" as usual in that I arranged for Microsoft to host the meeting and so it was held in Redmond, but it's actually more work to be the host than it is to get on a plane. Still, it was nice to sleep at home for a change -- hotel rooms mostly all look the same after a while.]&lt;/font&gt;&lt;/div&gt;&lt;/li&gt;&lt;/ul&gt;
&lt;div align="left"&gt; &lt;/div&gt;
&lt;ul type="disc" style="MARGIN-TOP: 0px; MARGIN-BOTTOM: 0px"&gt;
&lt;li&gt;
&lt;div align="left"&gt;&lt;strong&gt;Tagged Unions&lt;/strong&gt;&lt;font size="2"&gt; (with Jim Hyslop),&lt;br /&gt;&lt;font color="#000080"&gt;&lt;em&gt;C/C++ Users Journal&lt;/em&gt;, 23(1), January 2005.&lt;/font&gt;&lt;br /&gt;Some of our C heritage is slim and fast—and fragile—in the name of performance. Unions are such a beast. Here's a technique you might already know about. Maybe someday C++ will do this for you automatically…&lt;/font&gt;&lt;/div&gt;&lt;/li&gt;&lt;/ul&gt;
&lt;div align="left"&gt; &lt;/div&gt;
&lt;div align="left"&gt;It's been fun to write two articles every month. Actually I really only have to write the equivalent of 1.5 articles a month, because I share one of the columns with valued coauthor Jim Hyslop. But the times, they are a-changin': Jim and I are planning to write another five Conversations columns and then retire that column, at least for now, after the June CUJ issue. At that point, with five years' worth of material in a round 60 Conversations columns, we plan to revise and pull together all the columns into book form. (But please don't send mail asking exactly when -- it won't be on shelves until early 2006. I just published two books in the last few months and I don't really want to look at another one till next fall… it's been a busy year. :-) )&lt;/div&gt;
&lt;div align="left"&gt; &lt;/div&gt;
&lt;div align="left"&gt;Enjoy!&lt;/div&gt;
&lt;div align="left"&gt; &lt;/div&gt;</content><author><name>herb-sutter</name></author></entry><entry><id>3666</id><published>2004-11-23T15:33:00.0-05:00</published><updated>2004-11-23T15:33:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#post"></category><title type="text">Destructors vs. GC? Destructors + GC!</title><content type="html">&lt;div&gt;On comp.lang.c++.moderated, Anand Hariharan recently asked:&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div align="left" style="PADDING-LEFT: 50px"&gt;&lt;em&gt;I recently attended a talk given by a .NET evangelist.  Surprisingly, the speaker was quite sincere and explained why Garbage collection is no panacea (citing examples such as database connections and file handles), taking his presentation through muddy waters of Dispose, Close, etc.&lt;/em&gt;&lt;/div&gt;
&lt;div align="left" style="PADDING-LEFT: 50px"&gt;&lt;em&gt;&lt;/em&gt; &lt;/div&gt;
&lt;div align="left" style="PADDING-LEFT: 50px"&gt;&lt;em&gt;At one point he showed how C# chose to overload the "using" keyword in a completely unrelated context viz., to specify that the variables within a block defined by "using" should be destroyed as soon as they leave the scope.&lt;br /&gt;&lt;br /&gt;At that point I asked why C# could not have simply incorporated those semantics as a part of the language rather than requiring the programmer explicitly request it at specific places.  His response: "Deterministic de-construction is generally expensive, especially if one has several small objects sporadically sprewn all over."&lt;br /&gt;&lt;/em&gt;&lt;/div&gt;
&lt;div align="left" style="PADDING-LEFT: 50px"&gt;&lt;em&gt;Is there a merit (statistical/empirical) to his assertion? &lt;/em&gt;&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div align="left"&gt;Short answer: No, but it's a common misconception even among experts. Having deterministic destruction can incur a minor performance penalty, and it is this he is thinking about. But deterministic destruction also gains a significant practical performance advantage, and is otherwise desirable. (See further below.)&lt;/div&gt;
&lt;div align="left"&gt; &lt;/div&gt;
&lt;div align="left"&gt;Anand continued:&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div align="left" style="PADDING-LEFT: 50px"&gt;&lt;em&gt;I thought C++ went great lengths for RAII to be possible, eschewing runtime guzzlers (such as mark-and-sweep) largely on performance grounds.&lt;br /&gt;&lt;/em&gt;&lt;em&gt;&lt;/em&gt;&lt;/div&gt;
&lt;div&gt;Actually, you want both; destructors are essential, and modern GCs are very sophisticated and high-performance and desirable for many reasons. It's a matter of using each where it's appropriate.&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt;Jared Finder responded, adding:&lt;br /&gt;&lt;/div&gt;
&lt;div style="PADDING-LEFT: 50px"&gt;&lt;em&gt;This just seems crazy.  I can't see how C#'s using, Java's try-finally, or C++'s automatic destruction would generate code that is different in any way.  &lt;/em&gt;&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt;Right, but it's useful to understand the actual issue. Here it is:&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt;Let's say you have a stack frame containing one or more conceptually local objects. If any such object should be cleaned up at the end of the function (or more local scope), either for performance reasons or for correctness reasons, you need to express that. Depending on the language you're using, you express that essentially identically as one of the following:&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;ul type="disc" style="MARGIN-TOP: 0px; MARGIN-BOTTOM: 0px"&gt;
&lt;li&gt;in C++, a stack-based object with a nontrivial destructor&lt;/li&gt;
&lt;li&gt;in C#, a using clause for a Disposable object&lt;/li&gt;
&lt;li&gt;in Java, the hand-coded Dispose pattern&lt;/li&gt;&lt;/ul&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt;In each case, you incur the overhead of an implicit or explicit "try/finally" for the first local object that will need the cleanup -- and it is that try/finally that the people who worry about performance are talking about.&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt;Note, however, that:&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;ol type="1" style="MARGIN-TOP: 0px; MARGIN-BOTTOM: 0px"&gt;
&lt;li&gt;The constructs for expressing this that are essentially the same in all languages; the only question is ease of use, and the winners there are C++, C#, and Java, in that order. (To be complete, I should acknowlege that there are other areas where C# and Java win on ease of use, but in this particular case it is C++ that is the simpler language.)&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;Generally it's wrong NOT to write the deterministic destruction when objects are conceptually local. If the object needs to be Dispose'd, you need to Dispose it. So it's usually a red herring to say this incurs some potential overhead, because to avoid the overhead would be to write an incorrect program (and/or a less well-performing one, see below).&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;There are offsetting performance advantages to early destruction. In particular, you incur a local try/finally for the first local variable in a given scope that requires the cleanup (additional ones are essentially free because you already have the try/finally in place), but you often get great performance benefits later by reducing finalizer pressure and GC work. (In one example I cite in talks, the microsoft.com website uses .NET widely but at one point found that they were spending 70% of total system time(!) in the GC. It wasn't .NET's fault or the GC's fault, but rather in the way that GC was being used. The CLR performance team analyzed the problem and told the app team to make one change: Before making a server-to-server call, clean up (Dispose) all the objects you don't need any more. With that one change, GC went down to 1%. I submit that the problem would never have occurred if the app had been written in C++, which uses deterministic destruction by default. C# and Java have it off by default, and if you forget to write "using" or the Dispose pattern then your code will still compile, but will have either a correctness bug or a latent performance problem.)&lt;/li&gt;&lt;/ol&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt;Otherwise, if none of the conceptually local object does not require cleanup, you express that essentially identically as one of the following:&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;ul type="disc" style="MARGIN-TOP: 0px; MARGIN-BOTTOM: 0px"&gt;
&lt;li&gt;in C++, a stack-based object with a trivial destructor (or, a heap-based object)&lt;/li&gt;
&lt;li&gt;in C#, no using clause&lt;/li&gt;
&lt;li&gt;in Java, no Dispose pattern&lt;/li&gt;&lt;/ul&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt;In each case, you avoid adding the exception handling to do the cleanup. Again, it's the same in all language. C++ happens to do turn cleanup on by default for stack-based objects and does this optimization to automatically avoid the overhead when the cleanup work is trivial.&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt;So the argument really doesn't boil down to what some people often say, namely whether deterministic destruction of conceptually local objects is a good thing or not -- clearly it is important, otherwise you wouldn't have C++ auto semantics, C# using statements, and Java Dispose patterns! The argument really boils down to this: When you do need deterministic destruction, you really do need it regardless of the language you're using, and to avoid the overhead would be to write an incorrect program (and often one with more overhead in other places).&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt;Jared continued:&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div style="PADDING-LEFT: 50px"&gt;&lt;em&gt;I can see there being problems with an old ABI that requires each function to register itself as having a cleanup step, but standards can't prevent all stupid implementations. In addition, using garbage collection will remove much of the work done in destructors since a most of the resources used in a program tends to be memory.&lt;/em&gt;&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt;The latter is true for trivial destructors. In short, finalizers (often but incorrectly called "destructors that run at GC time" &lt;u&gt;which they are not&lt;/u&gt;) are fundamentally flawed and extremely complex. (See for example &lt;a href="http://blogs.msdn.com/cbrumme/archive/2004/02/20/77460.aspx"&gt;Chris Brumme's blog article about finalizers&lt;/a&gt;.)&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt;I have personally come to the conclusion that destructors and GC are completely separate and must be kept completely separate. Trying to conflate the two ideas is the root of most of the problems with current GC systems in my opinion; in particular, this manifests most notably in the case of finalizers which exactly try to tie those two things together, and in the fact that all major current GC systems attempt to do GC instead of destructors, rather than in addition to destructors (with the notable exception of C++/CLI).&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt;Of course, C++/CLI exposes what the CLI does (including finalizers) and what C++ does (destructors) and by bringing them together shows how beneficial destructors are even for today's GC systems. I think that C++/CLI is the best it can be in this regard and is really compelling over the current alternatives. I also think this approach could be taken further and further improved upon; I have definite ideas, not ready for publication, on potential improvements in GC by removing finalizers outright (which could be viewed as somewhat radical and I agree that departing from longtime practice is something that should never be done lightly).&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div style="PADDING-LEFT: 50px"&gt;&lt;em&gt;I'd be interested in what Herb Sutter had to say about this, considering that one of the big advantages of C++/CLI over C# is the automatic calling of destructors.&lt;/em&gt;&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt;Yes. Of course, C# has other advantages; I drool over anonymous delegates (a restricted but very useful form of lambda functions / closures). It would be cool to have those in C++... but that's another release...&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt;Herb&lt;br /&gt;&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;</content><author><name>herb-sutter</name></author><thr:total>22</thr:total></entry><entry><id>3669</id><published>2004-11-23T15:15:00.0-05:00</published><updated>2004-11-23T15:15:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">re: Destructors vs. GC? Destructors + GC!</title><content type="html">If only you'd started working at Microsoft when .Net was first being designed...
&lt;br /&gt;
&lt;br /&gt;The 'using' keyword in C# is awkward (why does it open a completely new scope for each little local variable?!) and calling Dispose manually feels like a step backwards. Also, very few .Net programmers know how to implement Finalize correctly.
&lt;br /&gt;
&lt;br /&gt;C++/CLI fixes all that by bringing the straightforward and exception-safe C++ syntax to the .Net world, but I feel that in many ways it will forever be constrained by the design "mistakes" in the CLR and class library. That's a big shame for such an amazing feat of integration...
&lt;br /&gt;</content><author><name>Anonymous</name></author><thr:in-reply-to ref="3666"></thr:in-reply-to></entry><entry><id>3671</id><published>2004-11-24T00:26:00.0-05:00</published><updated>2004-11-24T00:26:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">re: Destructors vs. GC? Destructors + GC!</title><content type="html">Stephane, I agree with you. Except: there is no need for completely new scope for each little local variable. Here's why:
&lt;br /&gt;
&lt;br /&gt;using (X x = new X)
&lt;br /&gt;using (Y y = new Y)
&lt;br /&gt;{
&lt;br /&gt;}</content><author><name>Anonymous</name></author><thr:in-reply-to ref="3666"></thr:in-reply-to></entry><entry><id>3675</id><published>2004-11-24T17:24:00.0-05:00</published><updated>2004-11-24T17:24:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">Interesting Finds this week</title><content type="html">Interesting Finds this week</content><author><name>Anonymous</name></author><thr:in-reply-to ref="3666"></thr:in-reply-to></entry><entry><id>3681</id><published>2004-11-24T22:04:00.0-05:00</published><updated>2004-11-24T22:04:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">re: Destructors vs. GC? Destructors + GC!</title><content type="html">&lt;br /&gt;Not having to do with destructors in particular, however I want to state that C++/CLI must preserve the C++ semantics as much as possible. 
&lt;br /&gt;
&lt;br /&gt;In what I know so far in particular, the default inheritance should be made the same way as ISO C++ is.
&lt;br /&gt;
&lt;br /&gt;Consider for example if in the future, private inheritance becomes possible in .NET, the complexity that this will cause.
&lt;br /&gt;
&lt;br /&gt;Or a newcomer to C++ starting with C++/CLI to find out that in managed code the default inheritance for classes is public and in unmanaged code is private.
&lt;br /&gt;
&lt;br /&gt;I also think that despite the fact that Object class has no default copy constructor or assignment operator, convenience should prevail and default "shallow copy" ones should be provided.
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;The inheritance case does not sacrifice anything while increases C++ semantics compliance.
&lt;br /&gt;
&lt;br /&gt;The default copy construcor/assignment operator case increases convenience while does not sacrifice C++ semantics noticeably.
&lt;br /&gt;
&lt;br /&gt;(that is, in 99% of cases, we do not think of Object ^s and in a function accepting Object ^s, we would get compiler errors when trying to copy Object values).</content><author><name>Anonymous</name></author><thr:in-reply-to ref="3666"></thr:in-reply-to></entry><entry><id>3689</id><published>2004-11-27T11:48:00.0-05:00</published><updated>2004-11-27T11:48:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">re: Destructors vs. GC? Destructors + GC!</title><content type="html">Some of the answers to Ioannis' points are also addressed in &lt;a href="http://pluralsight.com/blogs/hsutter/archive/2004/10/29/3081.aspx" target="_new"&gt;http://pluralsight.com/blogs/hsutter/archive/2004/10/29/3081.aspx&lt;/a&gt; .</content><author><name>Anonymous</name></author><thr:in-reply-to ref="3666"></thr:in-reply-to></entry><entry><id>3748</id><published>2004-12-04T15:44:00.0-05:00</published><updated>2004-12-04T15:44:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">re: Destructors vs. GC? Destructors + GC!</title><content type="html">You are clouding the issue by your discussion of deterministic destruction of objects. In the .NET and Java GC worlds, the destruction of objects occurs whenever the GC gets around to it in its garbage collection idiom. In the C++ world it occurs either when an object goes out of scope for stacked based objects or when an object is deleted for objects in dynamic memory. In either case in the C++ world, the destruction occurs immediately when the events occur. This is the real value of C++ deterministic destruction and not the sophistry you present defending the inherently flawed system of GC in .NET and Java as being just a slightly worse case than C++.
&lt;br /&gt;
&lt;br /&gt;The way to fix this in .NET and Java, and any other GC type system, is to have the ability to mark objects as immediately destructible when they go out of scope ( value types ) or are "deleted" ( ref types ). In this sense GC systems need to support the tracking of such objects marked in this way, and operate accordingly. The question is how to mark such objects.
&lt;br /&gt;
&lt;br /&gt;I propose two general ways of marking such objects. 
&lt;br /&gt;
&lt;br /&gt;1)The first way would be to mark classes as being immediately destructible, so that when anm object of that class gets destroyed, the destructor is immediately called and the object is destroyed. This would serve the purpose of those who develop classes using RAII, ie. those whose classes release resources upon destruction.
&lt;br /&gt;
&lt;br /&gt;2) The second way would to allow the programmer to mark class objects themselves as immediately destructible. This would serve the purpose of allowing a user of classes to control immediate destruction, ie. for containers which hold RAII objects.
&lt;br /&gt;
&lt;br /&gt;How this marking is done is up to the individual languages.
&lt;br /&gt;
&lt;br /&gt;Without the ability to allow programmers to mark their classes and objects as immediately destructible in a GC system, the current GC system will remain flawed in this respect and no amount of sophistry will make it not so.</content><author><name>Anonymous</name></author><thr:in-reply-to ref="3666"></thr:in-reply-to></entry><entry><id>3749</id><published>2004-12-04T16:36:00.0-05:00</published><updated>2004-12-04T16:36:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">re: Destructors vs. GC? Destructors + GC!</title><content type="html">Well, I think you misunderstood what I was saying if you view it as "sophistry," especially considering that we seem to be in violent agreement.
&lt;br /&gt;
&lt;br /&gt;Nearly everything you said echoes what I said, both above and in my other blogging on this topic. For that matter, C++/CLI already does both of the two things you asked; for the first, you say a class's objects are destructible simply by writing the destructor (==Dispose), and for the second, you can put the objects on the stack or explicitly delete them (even on the GC heap) both of which call the destructor. I happen to believe that we can do even better than that, and have qualitatively better GC, by having GC fundamentally be aware of destructors. Today's GCs aren't.
&lt;br /&gt;
&lt;br /&gt;I agree that C++'s approach, including in .NET, is significantly superior to the other languages'. As I wrote about the microsoft.com problem: "I submit that the problem would never have occurred if the app had been written in C++, which uses deterministic destruction by default." Other languages and systems (notably, as I mentioned, Java and C#) needed to retrofit support for destruction but did so via brittle and tedious coding patterns (Java's Dispose pattern, or C#'s "using" construct which semiautomates the Dispose pattern). Those are inferior to destructors primarily because they are off by default, and therefore fragile and error-prone. I've said that often and loudly.
&lt;br /&gt;
&lt;br /&gt;I was (and am) critiquing a specific fundamental weakness in current GC systems. In particular, they do not have a strong notion of object lifetime.
&lt;br /&gt;
&lt;br /&gt;You could make (y)our case even more strongly than you did: Specifically, modern GC systems that don't directly include support for destructors can be argued to be not completely type-safe after all. The reason is that today's GC systems do indeed prevent two type-safety issues: 1. They do prevent using a pointer to one type to access an object of another type. 2. They do prevent using a pointer to access an object after the object has been collected.
&lt;br /&gt;
&lt;br /&gt;But: 3. They do NOT prevent using a pointer to access an object after the object has been torn down (destroyed/Disposed or finalized). The GC itself has no notion of object lifetime, no "constructed" bit or other flag. Allowing use of an object after it has been torn down can rightly be viewed as a type safety issue, IMO. The fundamental point here, which is what I emphasized in the article above, is that today's GC systems conflate object teardown (which means the end of the object's lifetime) with memory reclamation.
&lt;br /&gt;
&lt;br /&gt;So that is the problem: The lifetime of an object and the lifetime of the memory it occupies are not the same thing, and must be treated distinctly. But today's GC systems do treat them as the same thing. That's the flaw I was pointing out, and that you seem to be in strong agreement with.
&lt;br /&gt;
&lt;br /&gt;Does that help?
&lt;br /&gt;
&lt;br /&gt;</content><author><name>Anonymous</name></author><thr:in-reply-to ref="3666"></thr:in-reply-to></entry><entry><id>3750</id><published>2004-12-05T13:56:00.0-05:00</published><updated>2004-12-05T13:56:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">re: Destructors vs. GC? Destructors + GC!</title><content type="html">You write "I happen to believe that we can do even better than that, and have qualitatively better GC, by having GC fundamentally be aware of destructors. Today's GCs aren't."
&lt;br /&gt;
&lt;br /&gt;If this means that destructors are immediately called for all value objects which go out of scope or all reference objects which are specifically deleted and have a reference count of 0, then we are in agreement. The weakness in GC systems is the inability to be able tell the system to call the destructor of an object immediately rather than lazily when there are no further references to that object. There are a class of objects which need this ability, most typically your RAII objects. If this were fixed then the biggest flaw in GC systems would be fixed. Without such a fix, RAII in GC systems is a failure. The "using" and "dispose" hacks of .NET and Java are not the correct solution.
&lt;br /&gt;
&lt;br /&gt;My object to your presentation on this subject is that you bent over backward, IMO, to present the weakness of GC systems in this regard vis-a-vis C++, as being as negligible as possible. It is a design flaw of GC systems, .NET as well as Java as well as Python etc., and instead of trying to minimize its inherent weakness as a programming solution, you should have been emphasizing what a serious flaw this is in order to promote others, most notably Microsoft in this particular case to solve it.
&lt;br /&gt;
&lt;br /&gt;However one is able to mark objects as immediately destructible rather than lazily destructible in a GC system, it needs to be done in order to solve the problem. The current workarounds are just poor patches to the problem and not a complete solution.</content><author><name>Anonymous</name></author><thr:in-reply-to ref="3666"></thr:in-reply-to></entry><entry><id>3760</id><published>2004-12-06T17:05:00.0-05:00</published><updated>2004-12-06T17:05:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">re: Destructors vs. GC? Destructors + GC!</title><content type="html">I want to add one more comment of the failure to do deterministic destruction in .NET, even as regards C++. Much has been made of the ability to call delete on a managed reference in the new C++/CLI release to invoke the managed destructor. This is still flawed when the managed reference is being used in more than one place. Calling delete, if I understand it, will call the managed destructor but this is the wrong result if there remain more than one reference to the object. Instead calling delete should not call the managed destructor unless this is the last reference to the object, ala boost::shared_ptr&amp;lt;T&amp;gt;. So even in this much trumpeted addition to C++ .NET, the result is just a flawed approximation of the basic problem which C++ has already solved. The basic problem still remains to be solved. I sincerely hope, without putting an onus on your shoulder, that you can influence Microsoft to solve the basic problem and will take my suggestions about one way to solve it to heart.</content><author><name>Anonymous</name></author><thr:in-reply-to ref="3666"></thr:in-reply-to></entry><entry><id>3817</id><published>2004-12-10T00:59:00.0-05:00</published><updated>2004-12-10T00:59:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">re: Destructors vs. GC? Destructors + GC!</title><content type="html">C# does not have stack based objects, nor it has a delete operator. In order to support C++/CLI like destructor, it is necessary to re-introduce those two concepts into C#, which apparently is what C# tries to avoid in the first place. 
&lt;br /&gt;
&lt;br /&gt;The deterministic destruction is certainly a compelling feature of C++/CLI. But like people said, it is not panacea. Lifecycle management is not as simple as acquire and release. It does solve some trivial problems. But in a complex system, it may introduce additional unnecessary complexity into the system. An analogy will be smart pointers in COM world. People love it, and people hate it. 
&lt;br /&gt;
&lt;br /&gt;Your accessment on CLR's GC is not fair. CLR always claims GC manages and only managed managed heap. It is up to the developers to manage the lifecycle of other resources, be it SQL connection, file handle, unmanaged memory, whatever. This is, CLR's GC already made a clean separation of the managed memory, and object lifecycle. Your article is really about how a programming language should help developers manage object lifecycle, which, as discussed my first paragraph, will be prioritized by lanaguage designers against other design priorities. 
&lt;br /&gt;
&lt;br /&gt;By declaring that GC should be extended to handle deterministic object destruction, you blur the line between memory management and object lifecycle management, violating your own claim. 
&lt;br /&gt;
&lt;br /&gt;While I believe deterministic destruction is a very important (and distinct) feature of C++/CLI, it is not to say that it will give a huge advantage over C# (and Java). I would say seemless interop with unmanaged code is where C++/CLI shines. </content><author><name>Anonymous</name></author><thr:in-reply-to ref="3666"></thr:in-reply-to></entry><entry><id>3818</id><published>2004-12-10T04:03:00.0-05:00</published><updated>2004-12-10T04:03:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">Herb Sutter discusses C  /CLI's deterministic destruction</title><content type="html"></content><author><name>Anonymous</name></author><thr:in-reply-to ref="3666"></thr:in-reply-to></entry><entry><id>3824</id><published>2004-12-10T07:47:00.0-05:00</published><updated>2004-12-10T07:47:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">re: Destructors vs. GC? Destructors + GC!</title><content type="html">(I think it's interesting that two responders disliked my blog for opposite reasons, one complaining that I was being too nice to GC, the other that I was being too hard on GC.)
&lt;br /&gt;
&lt;br /&gt;Thanks, Junfeng. I mostly already agree with what you write, and you do distinguish correctly between the runtime and the programmer model (the latter being what the programmer deals with at the source level).
&lt;br /&gt;
&lt;br /&gt;But I would disagree with a couple of small points:
&lt;br /&gt;
&lt;br /&gt;&amp;gt;&amp;gt;C# does not have stack based objects&amp;lt;&amp;lt;
&lt;br /&gt;
&lt;br /&gt;Sure it does; that's what "using" is. (You spell it differently than in C++, and it's not documented using the words "auto" or "stack", but functionally it's the same construct.) For that matter, even VB and Java programs typically de facto use stack-based objects even though those languages don't support that explicitly in the language; in VB and Java the programmer has to hand-code it himself.
&lt;br /&gt;
&lt;br /&gt;&amp;gt;&amp;gt;By declaring that GC should be extended to handle deterministic object destruction, you blur the line between memory management and object lifecycle management, violating your own claim.&amp;lt;&amp;lt;
&lt;br /&gt;
&lt;br /&gt;Yes, let me try to be clearer by distinguishing GC from the runtime using GC.
&lt;br /&gt;
&lt;br /&gt;My goal was to point out that GC for memory (reclaiming memory) and deterministic destruction are separate and complementary things, but today most GC-supporting runtimes do GC instead of destructors rather than in addition to them.
&lt;br /&gt;
&lt;br /&gt;I do, however, believe that such runtime systems would be stronger if they explicitly and directly supported the concept of "object lifetime" as distinct from "memory lifetime" -- which is clearly an important distinction inasmuch as the latter is a subset of the former.
&lt;br /&gt;
&lt;br /&gt;The fact is that programmers do need to consider object lifetime distinctly anyway even if the runtime system doesn't. That's why Java quickly had to adopt the Dispose pattern.
&lt;br /&gt;
&lt;br /&gt;This distinction between object and memory lifetime surfaces in other places, too, for example in that there is an important distinction between type safety and memory safety. Both are important, and many current GC-based systems focus only or mainly on memory lifetime. It is important to be able to reason about the subset of that time in which the bundle-o-bits is actually typed (satisfies the invariants for an object of that type).
&lt;br /&gt;
&lt;br /&gt;</content><author><name>Anonymous</name></author><thr:in-reply-to ref="3666"></thr:in-reply-to></entry><entry><id>3839</id><published>2004-12-11T05:27:00.0-05:00</published><updated>2004-12-11T05:27:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">re: Destructors vs. GC? Destructors + GC!</title><content type="html">Regarding Mr. Zhang's comments, it is not necessary to add stack-based objects or a delete operator to C#, or any other .NET language, in order to implement deterministic destruction of objects. C++ has already shown with its smart pointers and containers, and GC systems have already shown with their garbage collection, that having to do a manual delete of allocated objects, in the face of complicated programming logic and exceptions, is difficult and error prone.
&lt;br /&gt;
&lt;br /&gt;What is necessary for the .NET framework, or any other GC-based system, is to create a means by which the programmer can mark classes and/or objects as immediately destructible, when there are no more references to that object, rather than lazily destructible, and to support a class's member function which is always automatically called when the object is destroyed, ie. like the destructor in C++. I realize that while this idea is simple, the implementation of it in a GC system may not be, but that is no reason not to pursue the goal and make it happen. Clearly by making it happen, a GC system will provide the best of both worlds when it comes to the destruction of objects.
&lt;br /&gt;
&lt;br /&gt;My prediction is once the first major GC system solves this problem with the sort of solution as stated above, all other will follow suit in fairly rapid succession. But until it happens, each one is satisfied in the mediocrity of their own flawed solutions while pretending this flaw either does not exist or is too minor to worry about. In the meantime programmers suffer and complain because they have to cobble together solutions which are only a patchwork at best.</content><author><name>Anonymous</name></author><thr:in-reply-to ref="3666"></thr:in-reply-to></entry><entry><id>3902</id><published>2004-12-12T18:43:00.0-05:00</published><updated>2004-12-12T18:43:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">re: Destructors vs. GC? Destructors + GC!</title><content type="html">Regarding Mr. Diener's comment,
&lt;br /&gt;
&lt;br /&gt;There are two discussions here going on simultaneously. And that confuses people. 
&lt;br /&gt;
&lt;br /&gt;1. Introduce deterministic destruction for a language based on today's GC system. 
&lt;br /&gt;
&lt;br /&gt;2. Extend GC to be aware of object lifetime. 
&lt;br /&gt;
&lt;br /&gt;C++/CLI implements deterministic destruction using stack objects and delete operator. Maybe it is just me. But I don't see how C# can implement deterministic destruction without using stack objects or delete operator, based on today's GC system.
&lt;br /&gt;
&lt;br /&gt;And for your suggestion of extending GC to allow programmer to make classes as immediately destructible, it already exists, it is called Dispose(). Instead of marking the object as immediately destructible, you simply call Dispose() (explicitly, or implicitly with the language help). Remember, GC does not have a concept of scope. It only knows if an object is alive or not when it does a collection. Your suggestion at best will save the object from being promoted to Gen1, which is simply an implementation artifact of CLR's GC. I don't think this is what your suggestion intends to solve. </content><author><name>Anonymous</name></author><thr:in-reply-to ref="3666"></thr:in-reply-to></entry><entry><id>3904</id><published>2004-12-12T19:35:00.0-05:00</published><updated>2004-12-12T19:35:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">re: Destructors vs. GC? Destructors + GC!</title><content type="html">C# implements a primitive deterministic destruction by using some "using" directive.
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;You can see it in these presentations of C++/CLI:
&lt;br /&gt; &lt;a href="http://microsoft.sitestream.com/TechEd/DEV/DEV333_files/Botto_files/DEV333_Sutte.ppt" target="_new"&gt;http://microsoft.sitestream.com/TechEd/DEV/DEV333_files/Botto_files/DEV333_Sutte.ppt&lt;/a&gt; 
&lt;br /&gt;                   &lt;a href="http://www.accu.org/conference/presentations/Sutter_-_Is_C++_Relevant_on_Modern_Environments_%28keynote%29.pdf" target="_new"&gt;http://www.accu.org/conference/presentations/Sutter_-_Is_C++_Relevant_on_Modern_Environments_%28keynote%29.pdf&lt;/a&gt; 
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;in C++/CLI Dispose() is produced automatically from the compiler including chaining calls to Dispose(). Again check the presentations above to see the benefits of C++/CLI on this matter.
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;As far as I have understood calling delete on a managed object in C++/CLI, is the same thing as calling Dispose() (meaning you can do both).
&lt;br /&gt;
&lt;br /&gt;A stack semantics managed object reaching the end of its scope, or a call to Dispose()/delete calls the destructor (which is different from the finaliser which is executed at the time of GC *if* the destructor has not been called previously) which releases the important resources we have defined.
&lt;br /&gt;
&lt;br /&gt;The object however is garbage collected (=the memory is freed) only when the CLR decides.
&lt;br /&gt;
&lt;br /&gt;Memory and resources obtain an independent meaning in this way (if we want to).</content><author><name>Anonymous</name></author><thr:in-reply-to ref="3666"></thr:in-reply-to></entry><entry><id>3918</id><published>2004-12-13T11:25:00.0-05:00</published><updated>2004-12-13T11:25:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">re: Destructors vs. GC? Destructors + GC!</title><content type="html">Brian Harry's discussion on this issue. It is years old, but it is still accurate today. 
&lt;br /&gt;
&lt;br /&gt;&lt;a href="http://discuss.develop.com/archives/wa.exe?A2=ind0010A&amp;amp;L=DOTNET&amp;amp;P=R28572" target="_new"&gt;http://discuss.develop.com/archives/wa.exe?A2=ind0010A&amp;amp;L=DOTNET&amp;amp;P=R28572&lt;/a&gt;
&lt;br /&gt;
&lt;br /&gt;It is very long, but it is very worthwhile. </content><author><name>Anonymous</name></author><thr:in-reply-to ref="3666"></thr:in-reply-to></entry><entry><id>3958</id><published>2004-12-17T15:41:00.0-05:00</published><updated>2004-12-17T15:41:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">re: Destructors vs. GC? Destructors + GC!</title><content type="html">Junfeng Zhang commented:
&lt;br /&gt;
&lt;br /&gt;"C++/CLI implements deterministic destruction using stack objects and delete operator."
&lt;br /&gt;
&lt;br /&gt;The delete operator in C++/CLI is flawed since it will always delete the object, even when there are still other references to it. I pointed out this flaw already in one of the blogs in this long discussion.
&lt;br /&gt;
&lt;br /&gt;"And for your suggestion of extending GC to allow programmer to make classes as immediately destructible, it already exists, it is called Dispose(). Instead of marking the object as immediately destructible, you simply call Dispose() (explicitly, or implicitly with the language help). "
&lt;br /&gt;
&lt;br /&gt;Your comment contradicts itself. Dispose() does not make an object immediately destructible as I am sure you know. Furthermore my entire point is that the programmer having to call anything to destroy a GC ref object is error-prone and poor. A smart pointer, aka Boost's shared_ptr&amp;lt;&amp;gt;, destroys the object pointed to internally immediately when the shared_ptr&amp;lt;&amp;gt; goes out of scope and there are no more references to the object. This is the way a GC system with the ability to mark classes and objects as immediately destructible should work. Without it, forcing programmers to call Dispose() in the face of exceptions and multiple references to an object is an absurd system which is only tolerated because GC implementors are too mediocre to come up with a better solution such as I have described.
&lt;br /&gt;</content><author><name>Anonymous</name></author><thr:in-reply-to ref="3666"></thr:in-reply-to></entry><entry><id>3960</id><published>2004-12-17T18:00:00.0-05:00</published><updated>2004-12-17T18:00:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">re: Destructors vs. GC? Destructors + GC!</title><content type="html">C++/CLI implements deterministic destruction by using objects with stack semantics, a call to delete operator or a call to Dispose() (which is generated automatically by the compiler from the destructors).
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;In none of these cases the memory is immediately freed, but only when the CLR decides to do so.
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;Deterministic destruction is not deterministic finalisation.
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;About smart pointers, I see no reason why they should not be used in .NET in addition to these, and no reason why they can not (with C++).
&lt;br /&gt;</content><author><name>Anonymous</name></author><thr:in-reply-to ref="3666"></thr:in-reply-to></entry><entry><id>4822</id><published>2005-01-07T10:21:00.0-05:00</published><updated>2005-01-07T10:21:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">re: Destructors vs. GC? Destructors + GC!</title><content type="html">This is has little to do with destructor-like language features, but if you want to speed up the rate at the GC notices that things can reclaimed, you could use aggressive tail-recursion-elimination in your compiler -- the idea being that every open call on the stack is going to keep references to objects alive, even if those objects are not needed by pending computations or the caller. I don't know if the CLR supports such kinds of optimization, though. But it's certainly been a topic among Lisp and Scheme hackers for a long time.</content><author><name>Anonymous</name></author><thr:in-reply-to ref="3666"></thr:in-reply-to></entry><entry><id>5034</id><published>2005-01-16T13:42:00.0-05:00</published><updated>2005-01-16T13:42:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">re: Destructors vs. GC? Destructors + GC!</title><content type="html">&lt;br /&gt;Let's say you're done with an object. It gets reclaimed eventually (both its memory, and its 'destructor'). This happens in all languages and runtimes discussed here. No contention.
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;Now when does the 'destructor' run? It is either immediately (when the app requests it) or later (when the system/library detects it).
&lt;br /&gt;
&lt;br /&gt;C++ does the first via "end-of-scope" or explicit "delete". C# does it via "using" or explicit "Dispose", in both cases it's pretty  explicit. C# decided to avoid users having to know the difference between stack vs heap as much as C++ requires you to. This does make it easier to use.
&lt;br /&gt;
&lt;br /&gt;'smart pointer' libraries do the second (implicit reclamation) when some ref count is satisfied. C# does it at GC time, which does not use reference counting but a reachability test.  In both cases it is not explicitly determined by the application programmer that removes the last reference, but by some intermediary code which determines when to run the "destructor".
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;So take your pick: explicit or implicit. Both offer it.  You could implement 'smart Dispose' that does ref-counting or pooling if you really want to, as well. 
&lt;br /&gt;
&lt;br /&gt;The one thing that C# doesn't offer you is implicit end-of-scope disposal. The argument can be about that, but it's just not very interesting. C++ is not an easy-to-use language. C# is. They have different tradeoffs. News at 11.
&lt;br /&gt;</content><author><name>Anonymous</name></author><thr:in-reply-to ref="3666"></thr:in-reply-to></entry><entry><id>5076</id><published>2005-01-17T18:31:00.0-05:00</published><updated>2005-01-17T18:31:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">C   DF Discussion on hold</title><content type="html"></content><author><name>Anonymous</name></author><thr:in-reply-to ref="3666"></thr:in-reply-to></entry><entry><id>5121</id><published>2005-01-18T16:02:00.0-05:00</published><updated>2005-01-18T16:02:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">Herb Sutter e GC vs destructors</title><content type="html"></content><author><name>Anonymous</name></author><thr:in-reply-to ref="3666"></thr:in-reply-to></entry><entry><id>3688</id><published>2004-11-26T16:29:00.0-05:00</published><updated>2004-11-26T16:29:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#post"></category><title type="text">New book printings, and errata now online</title><content type="html">&lt;div&gt;Addison-Wesley will be doing new printings of &lt;em&gt;&lt;a href="http://www.gotw.ca/publications/c++cs.htm"&gt;C++ Coding Standards&lt;/a&gt;&lt;/em&gt; and &lt;a href="http://www.gotw.ca/publications/xc++s.htm"&gt;&lt;em&gt;Exceptional C++ Style&lt;/em&gt;&lt;/a&gt; next week, and I've taken the opportunity to bring the errata lists up to date for those books. You can find the current errata lists at each of the books' pages.&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt;Note: I've also been receiving and saving occasional errata reports for my first two books, &lt;em&gt;&lt;a href="http://www.gotw.ca/publications/xc++.htm"&gt;Exceptional C++&lt;/a&gt;&lt;/em&gt; and &lt;a href="http://www.gotw.ca/publications/mxc++.htm"&gt;&lt;em&gt;More Exceptional C++&lt;/em&gt;&lt;/a&gt;. I haven't yet got around to applying them for new printings, but I hope to get to that in the next month or two. If you've sent me errata, I haven't replied (yet) but I have been saving your emails and you will get a reply, if a belated one in some cases.&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt; &lt;/div&gt;</content><author><name>herb-sutter</name></author></entry><entry><id>3767</id><published>2004-12-07T21:04:00.0-05:00</published><updated>2004-12-07T21:04:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#post"></category><title type="text">General-audience blurb about genericity</title><content type="html">&lt;div&gt;A writer for a magazine I'd never heard of before emailed me some questions today that were pretty unique. It's not the questions that were unique (the questions are rather common), but what was unique was the request that I answer them for a more general audience.&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt;So I dashed off a quick answer with the usual fruit metaphor, and since I was writing it anyway I thought I'd inflict it on you, too. Besides, the majority of you who are already familiar with these answers may find it interesting to see the kinds of questions that nontechnical people ask about the stuff we do.&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;&lt;font size="2"&gt;
&lt;/font&gt;&lt;div style="PADDING-LEFT: 50px"&gt;1. Is genericity a concept that is currently applied by programmers, or  is it something of the past or future?&lt;/div&gt;
&lt;div&gt;&lt;font size="2"&gt;
&lt;/font&gt;&lt;div&gt; &lt;/div&gt;
&lt;div&gt;It's very current. Of course, it's also "past" in that it's not new -- C++ has had type genericity for over a decade. It's also very much "future" in that languages that don't have type genericity are scrambling to add the feature.&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;&lt;/div&gt;
&lt;div style="PADDING-LEFT: 50px"&gt;2. In short, simple terms, can you explain the benefit(s) of genericity for programmers? and for consumers?&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt;For programmers, genericity reduces code duplication and type-casting (type coercion), and so software is easier to write and more reliable. Consumers benefit from the latter in turn.&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div style="PADDING-LEFT: 50px"&gt;3. If you had to say anything else about this concept that might help the average person understand, what might that be? (a comparison or analogy, perhaps)&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div align="left"&gt;If you have a bag of fruit, but you don't know what kind of fruits are in the bag, then every time the program takes a fruit out of the bag it has to ask "is this a watermelon? is it a lime? is it a mango?" and so forth. (Computers, after all, can be pretty dim.) It's tedious for programmers to have to tell the computer "for the millionth time, I said it's a watermelon!" It's also dangerous in several ways.&lt;/div&gt;
&lt;div align="left"&gt; &lt;/div&gt;
&lt;div align="left"&gt;One way it's dangerous is that you could get the type wrong. For example, you might pull out a fruit, decide without really looking at it that it must be a lemon (even though it's actually a watermelon), and try to force the watermelon it into a small lemon juicer. One possible outcome -- actually, a likely one -- is a broken juicer, and after a while it gets expensive to keep buying new juicers. Even if it doesn't break the juicer, trying to stuff a watermelon inside is liable to make quite a mess and the result will be, um, terribly unsatisfactory.&lt;/div&gt;
&lt;div align="left"&gt; &lt;/div&gt;
&lt;div align="left"&gt;Another way it's dangerous is that you could forget a type (e.g., "oops, I never thought anyone would put a persimmon in there, now what?").&lt;/div&gt;
&lt;div align="left"&gt; &lt;/div&gt;
&lt;div align="left"&gt;Worst of all, most of the time you only put one kind of fruit in a bag, or different fruits that are a restricted subset of all possible fruits (e.g., just lemons and limes). The programming language should prevent you from putting in inappropriate fruits that don't belong. Without type genericity, that's harder to do.&lt;/div&gt;
&lt;div align="left"&gt; &lt;/div&gt;
&lt;div align="left"&gt; &lt;/div&gt;</content><author><name>herb-sutter</name></author><thr:total>3</thr:total></entry><entry><id>3903</id><published>2004-12-12T19:25:00.0-05:00</published><updated>2004-12-12T19:25:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">re: General-audience blurb about genericity</title><content type="html">Isn't the fruit example more applicable to OO rather than genericity? If subtypes of fruit conform to the LSP then there should be no problem storing various fruits in the bag.  And most fruits can be juiced.  If, however, we wanted a bag that could also hold things such as marbles, candy, or cash then we'd want our bags for all these things to be structurally equivalent and not have to rebuild the bag for these unrelated objects.  So one aspect of genericity (the main aspect? the original intent?) is that it enables structural reuse independent of type, thereby reducing code duplication or type-casting as you said.  Or maybe I'm just not looking at your analogy in the right way :-)</content><author><name>Anonymous</name></author><thr:in-reply-to ref="3767"></thr:in-reply-to></entry><entry><id>3949</id><published>2004-12-16T07:08:00.0-05:00</published><updated>2004-12-16T07:08:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">re: General-audience blurb about genericity</title><content type="html">Hmmmm, I'm guessing you just did someone's homework for them :)</content><author><name>Anonymous</name></author><thr:in-reply-to ref="3767"></thr:in-reply-to></entry><entry><id>5877</id><published>2005-02-14T15:26:00.0-05:00</published><updated>2005-02-14T15:26:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">re: General-audience blurb about genericity</title><content type="html">Is this the commonly accepted definition of the term "genericity"?  I understand that "Generics" is commonly used to refer to to parametric polymorphism, but I thought "genericity" would apply to even the old "object" containers.
&lt;br /&gt;
&lt;br /&gt;Maybe the e-mail you got had some other information that implied Generics/Templates, but could the sender have been asking about genericity in the make-your-code-adaptable sense?</content><author><name>Anonymous</name></author><thr:in-reply-to ref="3767"></thr:in-reply-to></entry><entry><id>3957</id><published>2004-12-17T21:27:00.0-05:00</published><updated>2004-12-17T21:27:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#post"></category><title type="text">Three new articles, two on the Concurrency Revolution</title><content type="html">&lt;div align="left"&gt;Last month, I noted two new upcoming articles and said that I would be throttling back a bit. Well, I still plan to throttle back, but this month I ended up writing &lt;a href="http://www.gotw.ca/publications"&gt;three new articles&lt;/a&gt;, including a 5,500-word feature for the March issue of Dr. Dobb's Journal. The two that are in the February issue of CUJ should be available in print around the third week of January, and the March issue of DDJ should be available at the beginning of February.&lt;/div&gt;
&lt;div align="left"&gt; &lt;/div&gt;
&lt;ul type="disc" style="MARGIN-TOP: 0px; MARGIN-BOTTOM: 0px"&gt;
&lt;li style="MARGIN-BOTTOM: 4px"&gt;
&lt;div align="left"&gt;&lt;font size="2"&gt;&lt;strong&gt;&lt;font size="2"&gt;&lt;strong&gt;The Concurrency Revolution&lt;/strong&gt;&lt;/font&gt;&lt;/strong&gt;,&lt;br /&gt;&lt;font color="#000080"&gt;&lt;em&gt;C/C++ Users Journal&lt;/em&gt;, 23(2), February 2005.&lt;/font&gt;&lt;/font&gt;&lt;/div&gt;&lt;/li&gt;&lt;/ul&gt;
&lt;div align="left" style="PADDING-LEFT: 50px; MARGIN-BOTTOM: 4px"&gt;&lt;font size="2"&gt;The biggest sea change in software development since the OO revolution is knocking at the door, and its name is Concurrency. This is a big deal, and when I started writing about it for this column I quickly found myself writing a feature article that was getting far too big for a column. So I finished writing the feature (see next paragraph), then went back and distilled the material down to a nice summary of the essentials, and that's this article.&lt;/font&gt;&lt;/div&gt;
&lt;div align="left"&gt; &lt;/div&gt;
&lt;ul type="disc" style="MARGIN-TOP: 0px; MARGIN-BOTTOM: 0px"&gt;
&lt;li style="MARGIN-BOTTOM: 4px"&gt;
&lt;div align="left"&gt;&lt;font size="2"&gt;&lt;strong&gt;&lt;font size="2"&gt;&lt;strong&gt;T&lt;font size="2"&gt;&lt;strong&gt;he Free Lunch Is Over: A Fundamental Turn Toward Concurrency in Software&lt;/strong&gt;&lt;/font&gt;&lt;/strong&gt;&lt;/font&gt;&lt;/strong&gt;,&lt;br /&gt;&lt;font color="#000080"&gt;&lt;em&gt;Dr. Dobb's Journal&lt;/em&gt;, 30(3), March 2005.&lt;/font&gt;&lt;/font&gt;&lt;/div&gt;&lt;/li&gt;&lt;/ul&gt;
&lt;div align="left" style="PADDING-LEFT: 50px; MARGIN-BOTTOM: 4px"&gt;&lt;font size="2"&gt;We stand at a fundamental turning point in software development. The major processor architectures, from Intel and AMD to Sparc and PowerPC, have run out of room with most of their traditional approaches to boosting CPU performance. Instead of driving clock speeds and straight-line instruction throughput ever higher, they are turning &lt;em&gt;en masse&lt;/em&gt; to hyperthreading and multicore architectures. That marks a fundamental change for us software writers, because for years we’ve enjoyed a free lunch as faster computers directly made our applications faster too, and that will largely not be true any more.&lt;/font&gt;&lt;/div&gt;
&lt;div align="left" style="PADDING-LEFT: 50px; MARGIN-BOTTOM: 4px"&gt;&lt;font size="2"&gt;Most of the coming gains won’t be picked up directly by the majority of today’s applications. This has four major interrelated consequences :&lt;/font&gt;&lt;/div&gt;
&lt;ul type="disc" style="MARGIN-TOP: 0px; MARGIN-BOTTOM: 0px"&gt;
&lt;/ul&gt;&lt;ul type="disc" style="MARGIN-TOP: 0px; MARGIN-BOTTOM: 0px"&gt;
&lt;li style="MARGIN-BOTTOM: 4px"&gt;
&lt;div align="left"&gt;Applications will increasingly need to be concurrent (e.g., multithreaded) if they want to fully exploit future CPU throughput gains. Single-threaded applications will run new CPUs at a fraction of the chip's potential performance (e.g., Intel is talking about eventually producing up to 100-core chips; a single-threaded app can exploit at most 1/100 of such a CPU's throughput).&lt;/div&gt;&lt;/li&gt;
&lt;li style="MARGIN-BOTTOM: 4px"&gt;
&lt;div align="left"&gt;Applications are likely to become increasingly CPU-bound. We seem to have reached the end of the “applications are increasingly I/O-bound or network-bound or database-bound” trend, because performance in those areas is still improving rapidly (gigabit WiFi, anyone?), while traditional CPU performance-enhancing techniques have maxed out.&lt;/div&gt;&lt;/li&gt;
&lt;li style="MARGIN-BOTTOM: 4px"&gt;
&lt;div align="left"&gt;Efficiency and performance optimization will get more, not less, important. Those languages that already lend themselves to heavy optimization will find new life. Those that don’t will need to find ways to compete and become more efficient and optimizable. Expect long-term increased demand for performance-oriented languages and systems.&lt;/div&gt;&lt;/li&gt;
&lt;li style="MARGIN-BOTTOM: 4px"&gt;
&lt;div align="left"&gt;Programming languages and systems will increasingly be forced to deal well with concurrency. Java has included support for concurrency since its beginning, although mistakes were made that later had to be corrected over several releases in order to do concurrent programming more correctly and efficiently. C++ has long been used to write heavy-duty multithreaded systems well, but it has no standardized support for concurrency at all. That really will have to change.&lt;/div&gt;&lt;/li&gt;&lt;/ul&gt;
&lt;div align="left" style="PADDING-LEFT: 50px; MARGIN-BOTTOM: 4px"&gt;If you haven’t done so already, now is the time to take a hard look at the design of your application, determine what operations are CPU-sensitive now or are likely to become so soon, and identify how those places could benefit from concurrency. Now is also the time for you and your team to grok concurrent programming’s requirements, pitfalls, styles, and idioms. Only by doing this will your software be able to fully exploit the continuing exponential gains in processor throughput.&lt;/div&gt;
&lt;div align="left"&gt; &lt;/div&gt;
&lt;ul type="disc" style="MARGIN-TOP: 0px; MARGIN-BOTTOM: 0px"&gt;
&lt;li style="MARGIN-BOTTOM: 4px"&gt;
&lt;div align="left"&gt;&lt;strong&gt;Order, Order &lt;/strong&gt;&lt;font size="2"&gt;(with Jim Hyslop),&lt;br /&gt;&lt;font color="#000080"&gt;&lt;em&gt;C/C++ Users Journal&lt;/em&gt;, 23(2), February 2005.&lt;/font&gt;&lt;/font&gt;&lt;/div&gt;&lt;/li&gt;&lt;/ul&gt;
&lt;div align="left" style="PADDING-LEFT: 50px; MARGIN-BOTTOM: 4px"&gt;&lt;font size="2"&gt;Getting the order right for a standard associative container can take a bit of thought. In this case, we consider how to order for multi-field objects stored in sorted containers.&lt;/font&gt;&lt;/div&gt;
&lt;div align="left"&gt; &lt;/div&gt;
&lt;div align="left"&gt; &lt;/div&gt;
&lt;div align="left"&gt;Enjoy!&lt;/div&gt;
&lt;div align="left"&gt; &lt;/div&gt;
&lt;div align="left"&gt; &lt;/div&gt;</content><author><name>herb-sutter</name></author><thr:total>19</thr:total></entry><entry><id>4044</id><published>2004-12-20T23:55:00.0-05:00</published><updated>2004-12-20T23:55:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">re: Three new articles, two on the Concurrency Revolution</title><content type="html">good job, thx~</content><author><name>Anonymous</name></author><thr:in-reply-to ref="3957"></thr:in-reply-to></entry><entry><id>4116</id><published>2004-12-29T00:18:00.0-05:00</published><updated>2004-12-29T00:18:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">Concurrency Revolution</title><content type="html">Very nice article on concurrency; I couldn't agree more about the issues involved and the fact that we need to get better about exploiting parallelism.</content><author><name>Anonymous</name></author><thr:in-reply-to ref="3957"></thr:in-reply-to></entry><entry><id>4506</id><published>2004-12-29T22:58:00.0-05:00</published><updated>2004-12-29T22:58:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">re: Three new articles, two on the Concurrency Revolution</title><content type="html">&amp;gt; On-die cache sizes have soared, and today most major chip vendors will sell you CPUs that have 2MB and more of on-board L2 cache
&lt;br /&gt;
&lt;br /&gt;Herb, this isn't even remotely correct.. at least not TODAY. I encourage you, or anyone else, to browse the CPU category at &lt;a href="http://www.newegg.com" target="_new"&gt;http://www.newegg.com&lt;/a&gt; and see which chips have 2mb L2. Only P4EE (Extremely Expensive), and some of the mobile Pentium-M chips have that much L2. Everything else is either 1mb or 512kb.
&lt;br /&gt;
&lt;br /&gt;Great article though.</content><author><name>Anonymous</name></author><thr:in-reply-to ref="3957"></thr:in-reply-to></entry><entry><id>4508</id><published>2004-12-29T23:43:00.0-05:00</published><updated>2004-12-29T23:43:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">re: Three new articles, two on the Concurrency Revolution</title><content type="html">Thanks, Jeff. I think you just misunderstood what I wrote. You commented:
&lt;br /&gt;
&lt;br /&gt;&amp;gt; Herb, this isn't even remotely correct.. at least not TODAY. I encourage you, or anyone else, to browse the CPU category at &lt;a href="http://www.newegg.com" target="_new"&gt;http://www.newegg.com&lt;/a&gt; and see which chips have 2mb L2. Only P4EE (Extremely Expensive), and some of the mobile Pentium-M chips have that much L2. Everything else is either 1mb or 512kb. 
&lt;br /&gt;
&lt;br /&gt;Right, and that supports what I wrote:
&lt;br /&gt;
&lt;br /&gt;&amp;gt;&amp;gt; On-die cache sizes have soared, and today most major chip vendors will sell you CPUs that have 2MB and more of on-board L2 cache
&lt;br /&gt;
&lt;br /&gt;I think maybe you misunderstood the "will sell you" part. It simply means that you can buy such chips from most major vendors (it does not imply that every chip comes with that much L2, which obviously isn't true). It is also true that all the major vendors will sell you CPUs with less than 2MB of L2, and that several of them will sell you CPUs with more. The point is just that chips with that much on-die cache are not a novelty, but are routinely commercially available today.
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;</content><author><name>Anonymous</name></author><thr:in-reply-to ref="3957"></thr:in-reply-to></entry><entry><id>4645</id><published>2004-12-30T15:12:00.0-05:00</published><updated>2004-12-30T15:12:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">Threading, uses and problems</title><content type="html">What can we all do to improve responsiveness of our applications? Use threads, of course. However, threading is hard - is there a way to have our cake and eat it too?</content><author><name>Anonymous</name></author><thr:in-reply-to ref="3957"></thr:in-reply-to></entry><entry><id>4709</id><published>2005-01-02T08:52:00.0-05:00</published><updated>2005-01-02T08:52:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">re: Three new articles, two on the Concurrency Revolution</title><content type="html">Great article! I recently upgraded my home system from a 950M AMD Athlon CPU to a 3500 AMD Athlon64 and it really doesn’t feel much faster :). 
&lt;br /&gt;On a seriously note I deal with these performance issues all the time. I work on the performance and scalability team for a company that builds software solutions for the banking industry. It’s a hybrid of both java and C++ applications hosted on either AIX/PowerPC or Windows/Intel. In all our customers engagements we deploy on multi-processor/machine configurations. We stress test our applications with load test scripts simulating hundreds on virtual users to verify scalability, locate bottlenecks and optimize as needed. 
&lt;br /&gt;I love the remark about stress testing that Herb refers too and I’ve see it many times myself.
&lt;br /&gt;
&lt;br /&gt;“This is the next jolt for people who thought that surely now they know how to write concurrent code: I’ve come across many teams whose application worked fine even under heavy and extended stress testing, and ran perfectly at many customer sites, until the day that a customer actually had a real multiprocessor machine and then deeply mysterious races and corruptions started to manifest intermittently.”
&lt;br /&gt;
&lt;br /&gt;The fact is many developers build and test on single process boxes and don’t see these subtle concurrency issues themselves. Unfortunately these bugs will pass on undetected and are integrated into a much larger code base, which makes it only more difficult/expensive to catch later in the process. I’ve been in software development for almost 15 years now and many of the engineers I’ve worked with lacked an understanding of concurrent programming. Even a recent graduate of the Georgia Tech (hired as an intern) was concurrency-challenged.
&lt;br /&gt;
&lt;br /&gt;I agree the concurrent programming may be the best way to improve application performance. It requires a different mindset and needs to be carefully designed in to the application.
&lt;br /&gt;
&lt;br /&gt;michael.stittleburg@fnf.com
&lt;br /&gt;</content><author><name>Anonymous</name></author><thr:in-reply-to ref="3957"></thr:in-reply-to></entry><entry><id>4819</id><published>2005-01-07T09:31:00.0-05:00</published><updated>2005-01-07T09:31:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">Right On!</title><content type="html">I came to the same, almost word-by-word,
&lt;br /&gt;conclusion in the summer of 2003. 
&lt;br /&gt;
&lt;br /&gt;So far I see very little appreciation of
&lt;br /&gt;this in the software development community.
&lt;br /&gt;I just hope your collection of articles
&lt;br /&gt;on the subject will help.
&lt;br /&gt;
&lt;br /&gt;Oleg.
&lt;br /&gt;</content><author><name>Anonymous</name></author><thr:in-reply-to ref="3957"></thr:in-reply-to></entry><entry><id>4838</id><published>2005-01-08T16:51:00.0-05:00</published><updated>2005-01-08T16:51:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">re: Three new articles, two on the Concurrency Revolution</title><content type="html">I put my comments here, they are a tad longwinded and dark :)
&lt;br /&gt;
&lt;br /&gt;&lt;a href="http://mcfunley.com/blog/archive/2005/01/08/189.aspx" target="_new"&gt;http://mcfunley.com/blog/archive/2005/01/08/189.aspx&lt;/a&gt;</content><author><name>Anonymous</name></author><thr:in-reply-to ref="3957"></thr:in-reply-to></entry><entry><id>4839</id><published>2005-01-08T23:12:00.0-05:00</published><updated>2005-01-08T23:12:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">re: Ghosts of Concurrency Past</title><content type="html">Mr. Herb Sutter,
&lt;br /&gt;
&lt;br /&gt;How can you write 5500 words without even a mere mention of Me and My Law?  Surely you are familiar with the Word of Amdahl and the implications it has for your new idolatry?
&lt;br /&gt;
&lt;br /&gt;Yours Serially,
&lt;br /&gt;
&lt;br /&gt;Gene Amdahl, late</content><author><name>Anonymous</name></author><thr:in-reply-to ref="3957"></thr:in-reply-to></entry><entry><id>4898</id><published>2005-01-11T13:06:00.0-05:00</published><updated>2005-01-11T13:06:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">re: Three new articles, two on the Concurrency Revolution</title><content type="html">Nice job !</content><author><name>Anonymous</name></author><thr:in-reply-to ref="3957"></thr:in-reply-to></entry><entry><id>4917</id><published>2005-01-12T05:05:00.0-05:00</published><updated>2005-01-12T05:05:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">re: Three new articles, two on the Concurrency Revolution</title><content type="html">If we are going to have to make a paradigm shift in terms of how we code, would it not be best to use programming languages that are designed with concurrency as a fundamental feature? C++ and its derivates, as far as I am aware, were not designed with concurrency in mind. For example Parlog -I don't know if it still exists-, a concurrent version of Prolog, had this built in to the language. It meant that every line of code you wrote, you had to think of whether it could be concurrent with the other statements, and if not what it depended on. There was no need to explicitly create threads or locks; the compiler took care of that for you.</content><author><name>Anonymous</name></author><thr:in-reply-to ref="3957"></thr:in-reply-to></entry><entry><id>5164</id><published>2005-01-19T08:02:00.0-05:00</published><updated>2005-01-19T08:02:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">re: Three new articles, two on the Concurrency Revolution</title><content type="html">Great article!!
&lt;br /&gt;
&lt;br /&gt;You are probably correct when you mention the "motivations" for multithreaded applications (you mention two classes of apps, right?) However, my intuition would be that one of the strongest drivers for multithreaded support (from an OS perspective) came not from the examples you mention above, but was mainly driven by the needs of GUIs (spawn a database job, update the status bar, change the mouse pointer, etc.) Though of course, the UI problems are generalized as "separate control flows".
&lt;br /&gt;In general I agree with you, but I think that parallelizing applications will continue to be a very difficult task (unlike what I consider a more "natural" phenomenon with object oriented philosophy). I hope that new languages and paradigms will appear to help us be better concurrent programmers.
&lt;br /&gt;</content><author><name>Anonymous</name></author><thr:in-reply-to ref="3957"></thr:in-reply-to></entry><entry><id>5173</id><published>2005-01-19T14:21:00.0-05:00</published><updated>2005-01-19T14:21:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">Reflecting on &amp;amp;quot;Space is speed&amp;amp;quot;</title><content type="html">Thanks for the interesting article.  Your aside about "Space is speed" made me think...
&lt;br /&gt;
&lt;br /&gt;An excerpt from "The Free Lunch Is Over: A Fundamental Turn Toward Concurrency in Software":
&lt;br /&gt;
&lt;br /&gt;"As it happens, our compiler uses pointers much more heavily in its internal data structures than most other kinds of applications ever would. Because pointers were now 8 bytes instead of 4 bytes, a pure data size increase, we saw a significant increase in the 64-bit compiler’s working set. That bigger working set caused a performance penalty that almost exactly offset the code execution performance increase we’d gained from going to the faster processor with more registers. As of this writing, the 64-bit compiler runs at the same speed as the 32-bit compiler, even though the source base is the same for both and the 64-bit processor offers better raw processing throughput."
&lt;br /&gt;
&lt;br /&gt;Could you have your cake and eat it too, if you introduced the idea of "short pointers"?  Like short and long integers, one could imagine having a short (32-bit) pointer.  I posit that there are apps which do not need to take advantage of a full-sized 64 bit pointer.  They could choose to use only short (32-bit) pointers in order to save space.  Thus, in your example,  there would be no degradation caused by the significant increase in the working set, but, the benefit from the use of the 64-bit CPU remains.  IANACW*, so this may not be possible without introducing other problems (i.e. how to map 32-bit pointers into a 64-bit memory model), but I thought is was worth asking.
&lt;br /&gt;
&lt;br /&gt;[IANACW: I am not a compiler writer ;-)]</content><author><name>Anonymous</name></author><thr:in-reply-to ref="3957"></thr:in-reply-to></entry><entry><id>5223</id><published>2005-01-20T10:18:00.0-05:00</published><updated>2005-01-20T10:18:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">What are your thoughts on Erlang or other models of declarative concurrency</title><content type="html">Herb,
&lt;br /&gt;
&lt;br /&gt;I was wondering if you are familiar with Erlang (http://www.erlang.org) or other models of declarlarative concurrency.  For example, in Erlang, it is possible to have run thousands upon thousands of threads, but you don't need traditional locking, because Erlang is a functional programming language and the only way to communicate amongst threads is to send messages to them, i.e., there is no shared state among the threads that needs to be synchronized with locks.
&lt;br /&gt;
&lt;br /&gt;Another excellent explanation of declarative concurrency is in the book "Concepts, Techniques, and Models of Computer Programming", MIT Press, 2004, by Peter van Roy and Seif Haridi (http://www.info.ucl.ac.be/~pvr/).  As part of the book, they motivate declarative concurrency and shared state concurrency and analyze the differences between them.  (An excellent book, it also covers functional programming, object-oriented programming, logic programming, and constraint-based programming, from a practical and a semantic basis).</content><author><name>Anonymous</name></author><thr:in-reply-to ref="3957"></thr:in-reply-to></entry><entry><id>5737</id><published>2005-02-10T07:55:00.0-05:00</published><updated>2005-02-10T07:55:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">re: Three new articles, two on the Concurrency Revolution</title><content type="html">Please recall that concurrency was available in Concurrent C/C++ by Gehani (time to look at it again!), Compositional C++ and ADA today still. Erlang's concurrency prefers many processes potentially across many distributed processors rather than threads (at least in UNIX/Linux). In the high performance computing world of clusters/etc. for finance, we've been cursing this lack of concurrency in the C/C++ language from the beginning.</content><author><name>Anonymous</name></author><thr:in-reply-to ref="3957"></thr:in-reply-to></entry><entry><id>6141</id><published>2005-02-23T12:51:00.0-05:00</published><updated>2005-02-23T12:51:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">re: Three new articles, two on the Concurrency Revolution</title><content type="html">Welcome to 1983, as viewed in 'supercomputer' land.  Similar predictions of a concurrency revolution were made.  But with the extra bonus claim that concurrency could sometimes make programs easier to understand rather than harder, as in threads are easier to program than event loops.
&lt;br /&gt;
&lt;br /&gt;An amazing number of concurrency models were developed and tried.  Most fell by the wayside for one reason or another.  In the end, threads and their various synchronization models won out.  Not because they were easy, but because concurrency was hard.  (I know, I've been developing distributed systems since the late 70s.)
&lt;br /&gt;
&lt;br /&gt;There's not going to be a concurrency revolution, because concurrency is hard.  How many people understand concurrency?  I think Leslie Lamport does.  So let's say 1.</content><author><name>Anonymous</name></author><thr:in-reply-to ref="3957"></thr:in-reply-to></entry><entry><id>6626</id><published>2005-03-09T20:49:00.0-05:00</published><updated>2005-03-09T20:49:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">re: Three new articles, two on the Concurrency Revolution</title><content type="html">In my humble opinion, this will eventually lead us to a processing architecture completely removed from Von Neuman. I see a grid of 1-4 bit processors, each executing a piece of a program, and handing data off to neighboring pieces of the program. All of the processor will get utilized for the task at hand, assuming the programmer is sufficiently skilled.
&lt;br /&gt;
&lt;br /&gt;The simplest architecture that seems to work is a cell with a single input and output from its 4 neighboring cells. The programming consists of 4 lookup tables of 16 entries each. (A total of 64 bits/cell)  All that's done is to select the appropropriate output bits from the lookup based on the inputs.
&lt;br /&gt;
&lt;br /&gt;Since there is no instruction pointer, debugging takes on an entirely new dimension. It'll be interesting, to say the least. I look forward to it.
&lt;br /&gt;
&lt;br /&gt;  --Mike--</content><author><name>Anonymous</name></author><thr:in-reply-to ref="3957"></thr:in-reply-to></entry><entry><id>6908</id><published>2005-03-28T22:49:00.0-05:00</published><updated>2005-03-28T22:49:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">Implementing the Async Pattern and the my threading bug...</title><content type="html"></content><author><name>Anonymous</name></author><thr:in-reply-to ref="3957"></thr:in-reply-to></entry><entry><id>7145</id><published>2005-03-31T11:35:00.0-05:00</published><updated>2005-03-31T11:35:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">Implementing the Async Pattern and the my threading bug...</title><content type="html"></content><author><name>Anonymous</name></author><thr:in-reply-to ref="3957"></thr:in-reply-to></entry><entry><id>5032</id><published>2005-01-16T18:25:00.0-05:00</published><updated>2005-01-16T18:25:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#post"></category><title type="text">Brief thoughts on garbage, locks, and lambdas</title><content type="html">&lt;div&gt;On &lt;a href="http://news:comp.lang.c++.moderated"&gt;comp.lang.c++.moderated&lt;/a&gt;, Michael Pryhodko wrote an interesting article that James Kanze responded to, and then so did I. Here's most of it.&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt;&lt;strong&gt;Garbage Collection&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt;Michael wrote about features that he felt shouldn't be in Standard C++. One of them was:&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div style="PADDING-LEFT: 50px"&gt;&lt;em&gt;garbage collection -- ultimate testament of average developer's inability(disability :) ); pushing it into standard is just a sign that people gave up idea to teach 'average developer' to develop. It could be fine addition to standard library, but changing language... I am really against it. What is really annoying me that GC does not solve ANYTHING -- memory is just only one of the resources used by application.&lt;br /&gt;&lt;/em&gt;&lt;/div&gt;
&lt;div&gt;James replied:&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div style="PADDING-LEFT: 50px"&gt;&lt;em&gt;That's sort of true.  In the same way that using a high-level language instead of assembler is a testament of the average programmers inability.&lt;/em&gt;&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt;It's sort of true in that memory is just one resource, but it is a very special resource. Specifically, GC is essential (or nearly so) for:&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;ul type="disc" style="MARGIN-TOP: 0px; MARGIN-BOTTOM: 0px"&gt;
&lt;li&gt;guaranteeing type safety and memory safety (because you have to guarantee that the memory that held an object stays around for as long as there are any pointers to it, even if the object has already been destroyed); and&lt;/li&gt;&lt;/ul&gt;
&lt;div&gt; &lt;/div&gt;
&lt;ul type="disc" style="MARGIN-TOP: 0px; MARGIN-BOTTOM: 0px"&gt;
&lt;li&gt;lock-free programming (see Andrei Alexandrescu's recent articles and talks; you can do it yourself without GC but it's like working with knives that are sharp on both edges and don't have handles).&lt;/li&gt;&lt;/ul&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt;It's true that many programmers misuse GC as a crutch. It's also true that GC is technically compelling (or essential) as a fundamental building block for a still-growing list of reasons.&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt;&lt;strong&gt;Threads&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt;Michael then turned to another topic:&lt;/div&gt;
&lt;div style="PADDING-LEFT: 50px"&gt;&lt;br /&gt;&lt;em&gt;threads -- only as library extension. C++ was designed from the ground ignoring this issue. And since there is no common model for multithreading -- it is very dangerous to enforce any to underlying platform.&lt;/em&gt;&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt;James wrote back:&lt;/div&gt;
&lt;div style="PADDING-LEFT: 50px"&gt;&lt;br /&gt;&lt;em&gt;Threading is simply impossible at the library level.  The major issues aren't library issues, but questions concerning memory visibility and sequencing.&lt;/em&gt;&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt;James' first part is exactly right; threading can't be done purely as a library, period. (That includes pthreads.)&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt;When it comes to language guarantees you need to have, the usual suspects include guarantees about the memory model, (re)ordering of operations (by the compiler's optimizer, the system cache manager, the processor core itself, or any other level), atomicity, and semantics for shared objects. I'd be inclined to also throw in a couple of guarantees about the scheduler (e.g., FIFO unblocking, fairness) just to avoid some pathological starvation cases and confusing execution orderings.&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt;But in fact there's more: Not only does threading require basic language support to be possible to do correctly at all, but we need also need still-to-be-designed higher-level language abstractions for concurrency that we don't yet have in any language on any platform. Lock-based programming is our status quo and it ain't enough; as semaphores are to assembler, locks are to C (they're just as low-level and probably more dangerous), and we need an "OO" level of abstraction for concurrency. There's work like &lt;a href="http://www.ada95.com"&gt;Ada95&lt;/a&gt; and &lt;a href="http://research.microsoft.com/Comega/"&gt;Cw&lt;/a&gt; (&lt;a href="http://research.microsoft.com/Comega/"&gt;Comega&lt;/a&gt;) that begin raising the abstraction level, but we need more.&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt;I was already writing further about this problem (but not any solution) this weekend as one part of my March &lt;a href="http://www.cuj.com"&gt;CUJ&lt;/a&gt; column. Deadlines, love 'em and hate 'em...&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt;&lt;strong&gt;Lambdas and Closures&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt;Michael's third not-in-my-language feature was:&lt;/div&gt;
&lt;div style="PADDING-LEFT: 50px"&gt;&lt;br /&gt;&lt;em&gt;lambda -- quite interesting idea, but not without flaws.&lt;br /&gt;&lt;/em&gt;&lt;/div&gt;
&lt;div&gt;James succinctly riposted:&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div style="PADDING-LEFT: 50px"&gt;&lt;em&gt;Nothings without flaws.&lt;/em&gt;&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt;Something that has surprised me is that the more completely separate language design problems I work on, the more lambdas/closures turn out to be a key language abstraction that adds substantial elegance and power. &lt;a href="http://www.boost.org/doc/html/lambda.html"&gt;Boost Lambda&lt;/a&gt; is a great approximation, but even if it were perfect (and unfortunately it's not although it's very impressive) you really need this to be in the language, not just to get reasonable diagnostics and debugger/tool support, but because some features and semantics that turn out to be desirable are impossible to achieve exactly the way you want them to be if lambdas are a library-only solution. I'll have more to say about this over the coming year or two; it's an interesting area.&lt;br /&gt;&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;</content><author><name>herb-sutter</name></author><thr:total>7</thr:total></entry><entry><id>5062</id><published>2005-01-17T05:20:00.0-05:00</published><updated>2005-01-17T05:20:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">re: Brief thoughts on garbage, locks, and lambdas</title><content type="html">"lock-free programming (see Andrei Alexandrescu's recent articles and talks; you can do it yourself without GC but it's like working with knives that are sharp on both edges and don't have handles)."
&lt;br /&gt;I'd suggest that the flipside of this is that in the places where lock-free and wait-free programming is at its most important GC is inappropriate anyway.  My big I/O-bound pagable user-mode program with copious amounts of memory space can probably afford GC; my small non-pagable kernel with only limited amounts of memory probably can't.  Unfortunately, the former program can also probably afford to block and the OS scheduler can probably fix priority inversions--and user-mode spinlocks can probably provide better performance than lock-free.  My kernel (because for example portions of it can't be pre-empted) in certain areas simply can't afford to block.  Lock-free can still make deadlock avoidance easier, but static source analysis can AFAICT do a reasonable job of that anyway.
&lt;br /&gt;
&lt;br /&gt;In any case, you just don't need the GC.  CASn (arbitrarily large compare-and-swap) can be fabricated from regular pointer-wide CAS using reference-counting, and CASn is a sufficiently powerful primitive to allow construction of any lock-free structure that you want.
&lt;br /&gt;
&lt;br /&gt;Lambdas should obviously go in (along with all the bits and pieces they need to go with them).  Threading requires so many constraints to be useful that it's not clear to me that it can be usefully standardized; either it'll be too constraining (making implementation on some platforms difficult or impossible or otherwise suboptimal) or too flexible (making writing reliable multithreaded programs impossible).
&lt;br /&gt;</content><author><name>Anonymous</name></author><thr:in-reply-to ref="5032"></thr:in-reply-to></entry><entry><id>5110</id><published>2005-01-18T08:33:00.0-05:00</published><updated>2005-01-18T08:33:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">re: Brief thoughts on garbage, locks, and lambdas</title><content type="html">Hi Herb,
&lt;br /&gt;
&lt;br /&gt;I barely know what lock-free programming is (I did some reading yesterday after you posted your article).  I don't see the connection with GC.  Can you suggest a reference?
&lt;br /&gt;
&lt;br /&gt;With regard to threading:  I think the status quo is that everybody who uses threads in C++ (and there are a lot of us) all roll their own OO lock classes (or whatever), and #ifdef the implementation if they need to be able to compile for multiple platforms.  I agree that a higher-level abstraction would be great, but how far down the road are we talking until such a thing becomes a reality?  Isn't there value in standardizing the status quo, so that we can at least write portable threaded code today?</content><author><name>Anonymous</name></author><thr:in-reply-to ref="5032"></thr:in-reply-to></entry><entry><id>5116</id><published>2005-01-18T10:56:00.0-05:00</published><updated>2005-01-18T10:56:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">re: Brief thoughts on garbage, locks, and lambdas</title><content type="html">&amp;gt;&amp;gt;I barely know what lock-free programming is (I did some reading yesterday after you posted your article). I don't see the connection with GC. Can you suggest a reference? &amp;lt;&amp;lt;
&lt;br /&gt;
&lt;br /&gt;Check out these references, particularly hazard pointers which show how extremely subtle and brittle it is to do lock-free with manual memory management. At his talk last week, Andrei called this the most compelling reason he has ever seen to want GC (I partly agree, but I think type safety is just as fundamentally compelling).
&lt;br /&gt;
&lt;br /&gt;A. Alexandrescu. “Lock-Free Data Structures” (C/C++ Users Journal, 22(10), October 2004).
&lt;br /&gt;
&lt;br /&gt;A. Alexandrescu and M. Michael. “Lock-Free Data Structures with Hazard Pointers” (C/C++ Users Journal, 22(12), December 2004). 
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;&amp;gt;&amp;gt;With regard to threading: I think the status quo is that everybody who uses threads in C++ (and there are a lot of us) all roll their own OO lock classes (or whatever)&amp;lt;&amp;lt;
&lt;br /&gt;
&lt;br /&gt;Right, and that's a problem. I've devoted my March 2005 CUJ column to showing (some of) the problems with lock-based programming.
&lt;br /&gt;
&lt;br /&gt;</content><author><name>Anonymous</name></author><thr:in-reply-to ref="5032"></thr:in-reply-to></entry><entry><id>5181</id><published>2005-01-19T19:30:00.0-05:00</published><updated>2005-01-19T19:30:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">re: Brief thoughts on garbage, locks, and lambdas</title><content type="html">Garbage collection makes lock-free code simpler because certain problems (most notably the ABA problem) "magically" disappears if you can assume garbage collection. HOWEVER, any old garbage collection algorithm will not do if it is to be useful in this context.
&lt;br /&gt;
&lt;br /&gt;The garbage collection algorithm must be able to deal correctly with concurrently updated data structures without introducing the same kinds of synchronization we seek to avoid by writing lock-free code in the first place. AFAIK that's not the case for GC generally used today because it's fairly complex and incurs significant overhead compared to typical GC.</content><author><name>Anonymous</name></author><thr:in-reply-to ref="5032"></thr:in-reply-to></entry><entry><id>5575</id><published>2005-02-03T13:56:00.0-05:00</published><updated>2005-02-03T13:56:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">re: Brief thoughts on garbage, locks, and lambdas</title><content type="html">&lt;br /&gt;Any thoughts on the token passing/IPI model used by DragonflyBSD?  As well as msg passing?
&lt;br /&gt;
&lt;br /&gt;I thought this was an interesting solution to the deadlock/interface pollution problems introduced by mutexes.  I haven't played with this yet in user mode to know if it's applicable at an application level or not however.
&lt;br /&gt;</content><author><name>Anonymous</name></author><thr:in-reply-to ref="5032"></thr:in-reply-to></entry><entry><id>8375</id><published>2005-05-13T10:49:00.0-05:00</published><updated>2005-05-13T10:49:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">re: Brief thoughts on garbage, locks, and lambdas</title><content type="html">&amp;gt;&amp;gt; Check out these references, particularly hazard pointers which show how extremely subtle and brittle it is to do lock-free with manual memory management. &amp;lt;&amp;lt;
&lt;br /&gt;
&lt;br /&gt;I would not call algorithms that try to avoid SMR “brittle”. Algorithms have been using the IBM FreeList for lock-free memory managements for decades. Microsoft even has some patents on similar algorithms. BTW, there are very good reasons one would want to avoid SMR:
&lt;br /&gt;
&lt;br /&gt;1. Memory Barriers
&lt;br /&gt;
&lt;br /&gt;You need an extremely expensive #StoreLoad barrier after you set a hazard pointer and before you do the reload and compare. You also need release semantics when you store a pointer into a null hazard pointer and when you set the hazard pointer back to null at the end of the protected region. Oh yeah, I almost forgot, you will need classic acquire semantics after the reload and compare to prevent ABA. This is “very” expensive stuff, even on x86; you have to use the LOCK prefix or an MFENCE instruction to prevent an x86 from reordering a “load-after-store”! I have created a tweaked implementation of SMR in my AppCore library but the performance degradation from the memory barriers slows it down http://appcore.home.comcast.net/. 
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;2. Compiler Reordering
&lt;br /&gt;
&lt;br /&gt;If the compiler reorders one little thing while you are setting a hazard pointer, you can and will crash from some obscure race-condition. You need to use assembly language.
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;3. Infrastructure and Scalability
&lt;br /&gt;
&lt;br /&gt;SMR needs a moderate amount of support to keep track off all the applications threads. Also, there is a static amount of hazard pointers per-thread. This can be cumbersome to work with in some situations.
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;&amp;gt;&amp;gt; At his talk last week, Andrei called this the most compelling reason he has ever seen to want GC (I partly agree, but I think type safety is just as fundamentally compelling).  &amp;lt;&amp;lt;
&lt;br /&gt;
&lt;br /&gt;IMHO, hazard pointers can be too expensive for use as a generic garbage collector for lock-free algorithms. Sure you can avoid ABA, but at the cost of not being able to reuse anything until it has gone through a SMR polling cycle. There are alternatives for SMR. I have developed a new, unpublished, user-space algorithm that can provide a marked performance increase over SMR by getting rid of the nasty memory barriers. It requires an application to follow a simple and straightforward set of rules that implement a scaleable proxy collection algorithm, kind of like the infamous Read-Copy-Update. I am thinking about publishing it fairly soon.
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;BTW, I hang out on comp.programming.threads.
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;</content><author><name>Anonymous</name></author><thr:in-reply-to ref="5032"></thr:in-reply-to></entry><entry><id>9984</id><published>2005-06-05T14:31:00.0-05:00</published><updated>2005-06-05T14:31:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">Really COOL!</title><content type="html">Wow,  superb!
&lt;br /&gt;Thanks.</content><author><name>Anonymous</name></author><thr:in-reply-to ref="5032"></thr:in-reply-to></entry><entry><id>5132</id><published>2005-01-18T22:57:00.0-05:00</published><updated>2005-01-18T22:57:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#post"></category><title type="text">Two new articles for March mags</title><content type="html">&lt;div align="left"&gt;As I do most months, I've once again just written &lt;a href="http://www.gotw.ca/publications"&gt;two new articles&lt;/a&gt;, which will be available in print around the third week of February:&lt;/div&gt;
&lt;div align="left"&gt; &lt;/div&gt;
&lt;ul type="disc" style="MARGIN-TOP: 0px; MARGIN-BOTTOM: 0px"&gt;
&lt;li&gt;
&lt;div align="left"&gt;&lt;font size="2"&gt;&lt;strong&gt;The Trouble With Locks&lt;/strong&gt;,&lt;br /&gt;&lt;font color="#000080"&gt;&lt;em&gt;C/C++ Users Journal&lt;/em&gt;, 23(3), March 2005.&lt;/font&gt;&lt;br /&gt;Many people believe they understand how to write correct concurrent programs, but may not yet fully comprehend just how subtle it really is. This article focuses on the mainstream status quo approach to concurrency, lock-based programming. We will see why lock-based programming is difficult even for experts to use correctly, and why it’s fundamentally flawed for building large programs.&lt;/font&gt;&lt;/div&gt;&lt;/li&gt;&lt;/ul&gt;
&lt;div align="left"&gt; &lt;/div&gt;
&lt;ul type="disc" style="MARGIN-TOP: 0px; MARGIN-BOTTOM: 0px"&gt;
&lt;li&gt;
&lt;div align="left"&gt;&lt;strong&gt;Implicit Virtual&lt;/strong&gt;&lt;font size="2"&gt; (with Jim Hyslop),&lt;br /&gt;&lt;font color="#000080"&gt;&lt;font color="#000080"&gt;&lt;em&gt;C/C++ Users Journal&lt;/em&gt;, 23(3), March 2005.&lt;/font&gt;&lt;br /&gt;&lt;/font&gt;One person’s “bug” is another person’s “feature.” This month, we consider the implicit nature of virtual and how it can produce cool or unsettling results in your code, depending on your point of view.&lt;/font&gt;&lt;/div&gt;&lt;/li&gt;&lt;/ul&gt;
&lt;div align="left"&gt; &lt;/div&gt;
&lt;div align="left"&gt;Enjoy!&lt;/div&gt;
&lt;div align="left"&gt; &lt;/div&gt;
&lt;div align="left"&gt; &lt;/div&gt;</content><author><name>herb-sutter</name></author><thr:total>5</thr:total></entry><entry><id>5176</id><published>2005-01-19T16:35:00.0-05:00</published><updated>2005-01-19T16:35:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">re: Two new articles for March mags</title><content type="html">Where to read the whole article???</content><author><name>Anonymous</name></author><thr:in-reply-to ref="5132"></thr:in-reply-to></entry><entry><id>5182</id><published>2005-01-19T19:53:00.0-05:00</published><updated>2005-01-19T19:53:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">re: Two new articles for March mags</title><content type="html">How can I get access to C/C++ Users Journal to read the articles?</content><author><name>Anonymous</name></author><thr:in-reply-to ref="5132"></thr:in-reply-to></entry><entry><id>5209</id><published>2005-01-20T05:07:00.0-05:00</published><updated>2005-01-20T05:07:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">re: Two new articles for March mags</title><content type="html">Is the soft copy available of general reading. Thanks,</content><author><name>Anonymous</name></author><thr:in-reply-to ref="5132"></thr:in-reply-to></entry><entry><id>5210</id><published>2005-01-20T05:35:00.0-05:00</published><updated>2005-01-20T05:35:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">re: Two new articles for March mags</title><content type="html">See www.cuj.com -- they'll have subscription information. CUJ is also carried by many U.S. bookstores' magazine sections.
&lt;br /&gt;
&lt;br /&gt;I'll put electronic versions on my website, www.gotw.ca, sometime after they're published. You can find several hundred of my past articles there already. I've always put everything I write online, except only for the final contents of the books. I've usually put them up within a few months after publication, but I'm rather behind on that right now.
&lt;br /&gt;
&lt;br /&gt;</content><author><name>Anonymous</name></author><thr:in-reply-to ref="5132"></thr:in-reply-to></entry><entry><id>6681</id><published>2005-03-12T16:53:00.0-05:00</published><updated>2005-03-12T16:53:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">re: Two new articles for March mags</title><content type="html">Hi, Herb.
&lt;br /&gt;I am responding to your March 2005 column in CUJ.  You could call me a fan - I find that your columns always offer insight.  I really liked the column.  Yes, getting multi-threading right is enormously difficult.  As well, the bugs that arise can be heinously difficult to find.  The power outage that affected 50 million people in North America in 2004 was made worse by a race condition in the alarm handling software, which caused it to shut down.  Subsequent analysis revealed that a million hours of operation had not previously exposed the bug (I’d provide a reference, but I’m too lazy.  Take Google as my reference).
&lt;br /&gt;
&lt;br /&gt;I must take you to task, though.  It is great to have a small fragment of code which shows all sorts of problems.  But it is the wrong fragment of code.  My response to your column is – “Don’t do it like that, then”.  Maybe you’re way ahead of me and I will read a better way in future columns.  I hope so.  Just in case, this email is about why I think that you are asking the wrong question, and what question you should be asking.  (BTW sorry for a long email.  I may be already telling you lots of stuff you already know.  But in my experience very few people know this stuff.  And in my industry, it is stuff that people should know).
&lt;br /&gt;
&lt;br /&gt;About me ?  I design embedded communications systems.  I’ve been doing so for twenty years.  Real time scheduling is the hardest thing about what we do, and it has taken me the past twenty years to reach the understanding that I do.  Sadly, I see young engineers making the same mistakes over and over.  So I applaud you for taking up multi-threading.  I hope that in future, engineers and programmers do not take twenty years to get this stuff right.  We can’t afford it.
&lt;br /&gt;
&lt;br /&gt;Our goals are a little different.  You see multi-threading as a means to get more speed out of applications (is it still called multi-threading when several CPUs are involved ?).  I see multi-threading as only one tool in the design of real time systems.  And it is a tool of last resort, since it is so hard to do correctly.  If you haven’t already, I recommend that you study the nature of real time systems.  There are strong solutions to the problem of real time design, and they come down to understanding the nature of asynchronous execution – which may or may not include multi-threading.
&lt;br /&gt;
&lt;br /&gt;Bear with me for a few more paragraphs – I’ll get to specifics shortly.
&lt;br /&gt;
&lt;br /&gt;I think your comparison with structured and object oriented programming is a great one – understanding that relationship is at the heart of solving the problem.  When people told me that Java was a superior language because it has built in support for multi-threading, I took a look.  I was depressed.  The Java model of multi-threading doesn’t help you design and implement correct real-time designs.  Far from it. There seem to be many gotchas with the Java monitor approach.  I see polls from time to time as to what programming languages embedded systems designers are using.  Around half are still using C.  One can come up with many reasons for that – we’re a conservative lot.  The central design problem in real time systems is ensuring that all operations complete when they need to.  No languages solve that problem better than C (which is to say not at all).  Why then, would we use anything more complicated ?  (We overwhelmingly use C in my company).  But this is not a language debate.  I look forward to the day when compilers and CPUs offer native support for the kind of programming idioms I discuss here.
&lt;br /&gt;
&lt;br /&gt;Continuing with your comparison between structured programming and object oriented for a little longer:  The object revolution was big, because of the leverage of encapsulation.  It allowed programmers to start making strong assumptions about data states, and it provided for emergent behaviour of objects based on those states.  Note that objects encapsulate data in space, but not in time.  A thread is a set of un-completed functions.  Those functions contain objects that are in transient states of execution.  Another way of looking at a thread is “That set of objects which are in transient (undefined) states with respect to other threads”.  The problem of making a multi-threaded system execute correctly, is the problem of managing every possible interaction (in time and space) between those collections of objects.
&lt;br /&gt;
&lt;br /&gt;The problem is the function (method) call itself.  Threads are inherently asynchronous.  The function call is synchronous.  Viewed from a time perspective invoking a method does not respect object boundaries.  Calling methods on objects which may not be in well defined states is a violation of encapsulation.  Just don’t do it.  Don’t share data between threads.  Just don’t
&lt;br /&gt;
&lt;br /&gt;Easy to say:  People didn’t like giving up GOTO, either.
&lt;br /&gt;
&lt;br /&gt;What’s the alternative ?  Asynchronous message exchange.  Object C wants to know the sum of value A plus value B, both of which may lie in different contexts.  Solution:
&lt;br /&gt;1) Object A (the owner of value A) sends Object C a message containing the value of A when it changes.  Use a publish / subscribe pattern if your aesthetics demand it.  The message is queued at C until C next executes.
&lt;br /&gt;2) Object B (the owner of value B) sends Object C a message containing the value of B when it changes.  The message is queued at C until C next executes.
&lt;br /&gt;3) When Object C gets an update in value A or value B, it re-computes the sum.
&lt;br /&gt;4) Clients of Object C send messages to C requesting the sum.  C responds with the sum when it receives those requests.
&lt;br /&gt;
&lt;br /&gt;All of the message exchanges are asynchronous.  That means that the message is queued at the receiver, until the receiver is executing.
&lt;br /&gt;
&lt;br /&gt;There are no race conditions.  The respective events have become serialised in the queue of the receiver object.
&lt;br /&gt;
&lt;br /&gt;There is no shared data.  The requisite values are copied across synchronisation boundaries.
&lt;br /&gt;
&lt;br /&gt;There are no locks that cause a thread to block.  Deadlock is far less likely.  There are still synchronisation issues.  But they have been pushed to the front of the design problem, rather than lurking in the background.  The design problem becomes that of designing protocols between stateful entities.
&lt;br /&gt;
&lt;br /&gt;I call objects A, B, C concurrent objects.  Concurrent objects communicate asynchronously (message send, queued at receiver) with other concurrent objects.  They are encapsulated in time and space.  They are super-objects.
&lt;br /&gt;
&lt;br /&gt;The UML has a very similar idea to my concurrent objects.  The UML definition for an Active Object is “The root of a thread”  My own definition is less restrictive and more restrictive:  
&lt;br /&gt;1) A concurrent object may or may not have its own thread.  More on this below.
&lt;br /&gt;2) Concurrent objects only communicate via asynchronous message exchange.  They do not share each others’ data.
&lt;br /&gt;
&lt;br /&gt;The industry focuses too strongly on multi-threading.  Multi-threading is an implementation technique that reduces latency.  Concurrent design is the process of understanding the interactions of the objects in the system.  In concurrent design, states and protocols are the things to model.  Only once the interactions are understood, should objects be allocated to threads or CPUs.  Concurrent objects live in the design space.  Threads live in the implementation space.  
&lt;br /&gt;In practical terms, a thread is a collection of concurrent objects.  They are collected by their properties in time (execution characteristics) rather than their properties in space (object relationships).  I have sometimes implemented systems with three threads:
&lt;br /&gt;1) Processing the actual communications data – response time:  Under 10 ms.
&lt;br /&gt;2) Processing the control events in the system – response time:  10 .. 100 ms.
&lt;br /&gt;3) Processing the user interactions – response time 100 ms .. ?? s
&lt;br /&gt;Threads create partitions of time, rather than partitions of space (functionality / data).  Concurrent objects are partitions of both time and space.
&lt;br /&gt;If the system deadlines are not severe, an important special case is to have all of the concurrent objects in one thread.  I do that if I can.  Why bother with the overhead of concurrent objects in a single threaded system ?  Because concurrent objects solve the problem of schedulability.  A single threaded concurrent object scheduler simply picks the highest priority object which has messages waiting, and executes it.
&lt;br /&gt;Systems with multiple CPUs will presumably try to balance the execution load across all CPUs.
&lt;br /&gt;
&lt;br /&gt;Concurrent objects are best not to be too fine grained, because they have significant communication overhead.  They can contain many ordinary objects.
&lt;br /&gt;
&lt;br /&gt;The concurrent object idiom is the only viable programming model for computation in a network.
&lt;br /&gt;
&lt;br /&gt;Other authors have written about concurrent objects:
&lt;br /&gt;Steve Mellor is particularly strong on the relationships between analysis, design, modelling, and implementation.  I don’t agree with his ideas that the code should be automatically generated from an object model.  Having said that, I think that Steve is the only “methodologist” to have nailed the design of concurrent systems.
&lt;br /&gt;Miro Samek shows how easy it is to implement a concurrent object framework (After reading Miro’s book, I wrote my own in a few weeks).  A good antidote to some of Steve’s ideas.  Miro assumes that concurrent objects will always have their own threads, so he refers to them as active objects.
&lt;br /&gt;The University of Illinois has been researching Actors for many years.  I find their papers a bit too technical.
&lt;br /&gt;
&lt;br /&gt;You talked about an upcoming programming revolution.  I think this is it.
&lt;br /&gt;</content><author><name>Anonymous</name></author><thr:in-reply-to ref="5132"></thr:in-reply-to></entry><entry><id>5443</id><published>2005-01-25T17:27:00.0-05:00</published><updated>2005-01-25T17:27:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#post"></category><title type="text">C++ Coding Standards a Jolt finalist</title><content type="html">&lt;div&gt;The book &lt;em&gt;&lt;a href="http://www.gotw.ca/publications/c++cs.htm"&gt;C++ Coding Standards&lt;/a&gt;&lt;/em&gt; (by &lt;a href="http://www.gotw.ca"&gt;me&lt;/a&gt; and &lt;a href="http://www.moderncppdesign.com/"&gt;Andrei Alexandrescu&lt;/a&gt;) has been named a &lt;a href="http://www.awprofessional.com/promotion/2009"&gt;2005 Jolt award finalist&lt;/a&gt;. Thanks to our nominators! I guess this means C++ is still cool enough for books about "just C++" to compete equally with books about "just Java" and "just Perl."&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt; &lt;/div&gt;</content><author><name>herb-sutter</name></author><thr:total>7</thr:total></entry><entry><id>5447</id><published>2005-01-25T15:04:00.0-05:00</published><updated>2005-01-25T15:04:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">re: C++ Coding Standards a Jolt finalist</title><content type="html">Congrats.  It's an excellent book.
&lt;br /&gt;</content><author><name>Anonymous</name></author><thr:in-reply-to ref="5443"></thr:in-reply-to></entry><entry><id>5453</id><published>2005-01-26T01:56:00.0-05:00</published><updated>2005-01-26T01:56:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">re: C++ Coding Standards a Jolt finalist</title><content type="html">Well done - a useful collection of advice that will help anyone interested in writing more robust code.
&lt;br /&gt;Most of the entries in the book emphasise using standard C++ library features to solve problems rather than rolling your own code to gain the benefits of reuse. This is fine in environments where you have a standard library, but not much help in more limited environments where a standard library, exceptions etc. are not an option.
&lt;br /&gt;While the C standard includes the notion of a freestanding implemtation, there is no equivalent in C++, despite the fact that it would be useful.
&lt;br /&gt;How about another CUJ article with some advice for use of C++ in restricted implementations ?
&lt;br /&gt;
&lt;br /&gt;</content><author><name>Anonymous</name></author><thr:in-reply-to ref="5443"></thr:in-reply-to></entry><entry><id>5564</id><published>2005-02-03T02:16:00.0-05:00</published><updated>2005-02-03T02:16:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">re: C++ Coding Standards a Jolt finalist</title><content type="html">Congratulations! Waiting for more :)</content><author><name>Anonymous</name></author><thr:in-reply-to ref="5443"></thr:in-reply-to></entry><entry><id>5878</id><published>2005-02-14T16:02:00.0-05:00</published><updated>2005-02-14T16:02:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">re: C++ Coding Standards a Jolt finalist</title><content type="html">Another excellent job which has covers all facets of c++ coding standards. Great job and expect more and more highest quality C++ books of yours to be in the market.
&lt;br /&gt;
&lt;br /&gt;- H
&lt;br /&gt;</content><author><name>Anonymous</name></author><thr:in-reply-to ref="5443"></thr:in-reply-to></entry><entry><id>6315</id><published>2005-03-02T13:26:00.0-05:00</published><updated>2005-03-02T13:26:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">re: C++ Coding Standards a Jolt finalist</title><content type="html">Let me know</content><author><name>Anonymous</name></author><thr:in-reply-to ref="5443"></thr:in-reply-to></entry><entry><id>6694</id><published>2005-03-14T05:12:00.0-05:00</published><updated>2005-03-14T05:12:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">re: C++ Coding Standards a Jolt finalist</title><content type="html">salam</content><author><name>Anonymous</name></author><thr:in-reply-to ref="5443"></thr:in-reply-to></entry><entry><id>6715</id><published>2005-03-14T16:58:00.0-05:00</published><updated>2005-03-14T16:58:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">C   Connections announcement</title><content type="html"></content><author><name>Anonymous</name></author><thr:in-reply-to ref="5443"></thr:in-reply-to></entry><entry><id>5569</id><published>2005-02-03T14:42:00.0-05:00</published><updated>2005-02-03T14:42:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#post"></category><title type="text">Video interview on Channel 9, part 1</title><content type="html">&lt;div&gt;&lt;a href="http://channel9.msdn.com/ShowPost.aspx?PostID=39280"&gt;Channel 9 interviewed me&lt;/a&gt; recently and just posted the first part. This section is about how C++ fits with other languages and thrives in the .NET world, why you should care about concrete languages, and thoughts about computer science in education. Enjoy!&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt; &lt;/div&gt;</content><author><name>herb-sutter</name></author><thr:total>3</thr:total></entry><entry><id>5584</id><published>2005-02-04T01:36:00.0-05:00</published><updated>2005-02-04T01:36:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">re: Video interview on Channel 9, part 1</title><content type="html">The interview is interesting, but for Pete's sake why do they waste bandwidth on video for this ? The images contian zero content - this is a best an audio feed.
&lt;br /&gt;Even better, a transcript would only take 5 minutes to read...</content><author><name>Anonymous</name></author><thr:in-reply-to ref="5569"></thr:in-reply-to></entry><entry><id>5594</id><published>2005-02-05T13:19:00.0-05:00</published><updated>2005-02-05T13:19:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">re: Video interview on Channel 9, part 1</title><content type="html">Hey, I paid for unlimited bandwidth.  I want to use it!
&lt;br /&gt;</content><author><name>Anonymous</name></author><thr:in-reply-to ref="5569"></thr:in-reply-to></entry><entry><id>6126</id><published>2005-02-22T20:19:00.0-05:00</published><updated>2005-02-22T20:19:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">re: Video interview on Channel 9, part 1</title><content type="html">Videos are great. Do you think we ever would get fast broadband everywhere if there was no use for it? Only minor nag point about the videos are that they are not HD quality. In movie industry it's different. The content is already high quality, so the infrastructure to get it to homes is catching up. Same should be for Internet content. If everyone provided content that would not be usable without atleast 8 Mbit ADSL, the broadband providers would have more incentive and demand from customers to provide full rate services quickly. Where I live they upgraded speeds to 512 kbit when they put their own crappy video clip service up. MS should show the way here by providing HD content over net long before anyone else (not counting the pirates which do this already).</content><author><name>Anonymous</name></author><thr:in-reply-to ref="5569"></thr:in-reply-to></entry><entry><id>5576</id><published>2005-02-03T19:56:00.0-05:00</published><updated>2005-02-03T19:56:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#post"></category><title type="text">Interview part 2, with some folks on the VC++ team</title><content type="html">&lt;div&gt;Channel 9 have now &lt;a href="http://channel9.msdn.com/ShowPost.aspx?PostID=39463"&gt;posted the second part&lt;/a&gt; of the interview. I only say a few more things, and then it's off to meet three of the folks who work near me on the VC++ floor -- Brandon Bray and Jonathan Caves from the VC++ front-end compiler team, and Chuck Mitchell who's an architect on the next-generation &lt;a href="http://www.research.microsoft.com/phoenix/"&gt;Phoenix&lt;/a&gt; compiler project.&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt;Chuck graciously allowed us to ambush him completely without warning as he just happened to be walking innocently down our hallway, minding his own business and carrying his laptop and his lunch, unaware that our camera was running until it &lt;em&gt;leaped&lt;/em&gt; into his face out of the bushes… Thanks, Chuck!&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt; &lt;/div&gt;</content><author><name>herb-sutter</name></author><thr:total>3</thr:total></entry><entry><id>5595</id><published>2005-02-05T14:52:00.0-05:00</published><updated>2005-02-05T14:52:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">re: Interview part 2, with some folks on the VC++ team</title><content type="html">This is the first time having discovered the Channel 9 site from the blog. I like the way the show just seems to be on the spot rather than scripted like with some of the other msdn programs, you get a far more casual and on the spot conversations. Half the people being shot in your little episode seem to have to get over the shock of having a camera shoved in their faces :) 
&lt;br /&gt;
&lt;br /&gt;</content><author><name>Anonymous</name></author><thr:in-reply-to ref="5576"></thr:in-reply-to></entry><entry><id>6447</id><published>2005-03-07T04:47:00.0-05:00</published><updated>2005-03-07T04:47:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">re: Interview part 2, with some folks on the VC++ team</title><content type="html">oh</content><author><name>Anonymous</name></author><thr:in-reply-to ref="5576"></thr:in-reply-to></entry><entry><id>8388</id><published>2005-05-14T13:44:00.0-05:00</published><updated>2005-05-14T13:44:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">re: Interview part 2, with some folks on the VC++ team</title><content type="html">Is phoenix going to be able to handle exported templates?</content><author><name>Anonymous</name></author><thr:in-reply-to ref="5576"></thr:in-reply-to></entry><entry><id>5698</id><published>2005-02-09T17:15:00.0-05:00</published><updated>2005-02-09T17:15:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#post"></category><title type="text">Why C++ on .NET is good for security</title><content type="html">&lt;div&gt;Recently, various media (&lt;a href="http://www.zdnet.com.au/news/security/0,2000061744,39179932,00.htm"&gt;ZDNet&lt;/a&gt;, &lt;a href="http://it.slashdot.org/article.pl?sid=05/02/04/2139259&amp;amp;tid=172"&gt;Slashdot&lt;/a&gt;) reported concerns that supporting C++ on .NET was a Bad Thing for .NET and security.&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt;Clearly highlighting that security is a genuine concern is a good thing . But the articles (including several published responses) seem to labor under a fundamental misunderstanding about how C++ is actually supported on .NET. If the situation were what the reports appear to indicate, I'd be concerned too.&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt;Fortunately, it's not. Maybe I can provide some more context about my design to make it clearer why this is a choice that makes the world more, not less, secure.&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt;&lt;strong&gt;You can and should write perfectly verifiable code in C++&lt;/strong&gt; targeting .NET, perfectly safe code where you're not allowed to use those dangerous casts, etc. It's called &lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div style="PADDING-LEFT: 50px"&gt;/clr:safe &lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt;and it's encouraged. And writing &lt;strong&gt;verifiable C++&lt;/strong&gt; code means a lot more than just writing C# code in C++ syntax (though you can do just that if you like) -- you also get to use templates and automatic destructors and other major C++ power features safely and verifiably.&lt;br /&gt;&lt;/div&gt;
&lt;div&gt;For example, consider one of those other C++ power features: STL. Of course, the plain native STL isn't bounds-checked or verifiable. But we also provide a complete STL/CLR library (previously also called STL.NET) which is fully verifiable. STL/CLR is a library that brings all of C++'s familiar containers, iterators, and algorithms straight to the managed world with full interoperability with the managed container interfaces. This is what you can do (only) in a language that supports both templates and generics: Have a template, like msclr::vector, that implements a generic interface, like IList. You can use it as a vector (it is one); code that uses a std::vector today can work seamlessly with a msclr::vector. You can use it as an IList (it is that, too); C# and VB (and C++) code can happily foreach on it.&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt;And did I mention this is all completely safe and verifiable? Oh yes, I did.&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt;STL/CLR is an example of how C++ on .NET really brings together the best of both worlds, with no compromises: C++ code gets its usual full STL style of programming and full template specialization and everything else that makes the Standard C++ language and library so powerful. And you can still take one of those container objects and pass it directly to a C# or VB app that can use it naturally. It's safe.&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt;Sure, you can also explicitly disable safe mode and write/call unsafe code too if you want -- in &lt;em&gt;any&lt;/em&gt; language. That's not specific to C++; you can do that with C# unsafe and Java JNI. If it's immoral to call into unsafe code when you need to, why does C# have unsafe, and why does Java have JNI?&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt;One thing this discussion does underscore, though, is the design choice difference between the JVM's "one language" and the CLR's "many languages." There's a lot of C++ code out there. Which is better for security -- to ignore that code and tell people to throw it all away because tossing it is good for them (and pretend that they will, and that the insecure code will just disappear)? Or to give C++ developers an easier migration to take their existing valuable code and make it also be safe and verifiable?&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt;For those interested in some more details, check this blog's archives for a number of articles I've written about some of these issues already.&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt;Cheers,&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt;Herb&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt; &lt;/div&gt;</content><author><name>herb-sutter</name></author><thr:total>6</thr:total></entry><entry><id>5708</id><published>2005-02-09T13:03:00.0-05:00</published><updated>2005-02-09T13:03:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">re: Why C++ on .NET is good for security</title><content type="html">Albeit that /clr:safe is not yet usable for production code...</content><author><name>Anonymous</name></author><thr:in-reply-to ref="5698"></thr:in-reply-to></entry><entry><id>5725</id><published>2005-02-10T04:18:00.0-05:00</published><updated>2005-02-10T04:18:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">re: Why C++ on .NET is good for security</title><content type="html">Those people criticizing your C++/CLI efforts haven't probably even bothered to read and understand a single article about the implementation from either one of you guys. Otherwise they couldn't be talking such nonsense.
&lt;br /&gt;
&lt;br /&gt;I personally very much welcome the new implementation because it's exactly what I've been wishing for for a long time - to have the full power of C++ in the managed world plus have the ability do step into the unmanaged world if the situation requires it (which is quite common). The current MC++ implementation is really far from ideal. Although C# is great to quickly develop a managed app or lib, it only allows you so much. Some things are just so much nicer (and even safer) when written in C++ (eg. RAII) that it really can't be beaten by other languages.
&lt;br /&gt;
&lt;br /&gt;Keep up the good work ... and release it soon :)
&lt;br /&gt;
&lt;br /&gt;Cheers, Ales (CZ).</content><author><name>Anonymous</name></author><thr:in-reply-to ref="5698"></thr:in-reply-to></entry><entry><id>5733</id><published>2005-02-10T06:55:00.0-05:00</published><updated>2005-02-10T06:55:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">re: Why C++ on .NET is good for security</title><content type="html">Actually, reading Gosling he comes across as embittered, and he uses the language of someone who is in a bunkered mentality. Look at how many times he uses the word "scary".</content><author><name>Anonymous</name></author><thr:in-reply-to ref="5698"></thr:in-reply-to></entry><entry><id>5796</id><published>2005-02-11T15:16:00.0-05:00</published><updated>2005-02-11T15:16:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">Get Your Verifiable C   Here</title><content type="html"></content><author><name>Anonymous</name></author><thr:in-reply-to ref="5698"></thr:in-reply-to></entry><entry><id>6897</id><published>2005-03-27T14:23:00.0-05:00</published><updated>2005-03-27T14:23:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">re: Why C++ on .NET is good for security</title><content type="html">&amp;gt; It's called /clr:safe and it's encouraged.
&lt;br /&gt;
&lt;br /&gt;Would it be possible to make it the default option? If you want unverifiable code you should have to explicitly say /clr:unsafe.</content><author><name>Anonymous</name></author><thr:in-reply-to ref="5698"></thr:in-reply-to></entry><entry><id>42416</id><published>2006-11-23T21:04:00.0-05:00</published><updated>2006-11-23T21:04:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">来，领取你的可验证的C  吧</title><content type="html">????Herb Sutter????,?????Whidbey?????/clr:safe????,????????(????)STL???</content><author><name>Anonymous</name></author><thr:in-reply-to ref="5698"></thr:in-reply-to></entry><entry><id>6714</id><published>2005-03-14T19:56:00.0-05:00</published><updated>2005-03-14T19:56:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#post"></category><title type="text">C++ Connections announcement</title><content type="html">&lt;div&gt;I'm very pleased to announce that a new C++-specific conference is going be held later this year:&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div style="PADDING-LEFT: 50px"&gt;&lt;strong&gt;&lt;a href="http://www.cpp-connections.com"&gt;&lt;font size="3"&gt;C++ Connections&lt;/font&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/div&gt;
&lt;div style="PADDING-LEFT: 50px"&gt;&lt;strong&gt;November 7-11, 2005&lt;/strong&gt;&lt;/div&gt;
&lt;div style="PADDING-LEFT: 50px"&gt;&lt;strong&gt;Mandalay Bay resort, Las Vegas, NV, USA&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt;My summary: The biggest C++-fest since C++ World went away. Five intense days of practical and modern C++. All the major speakers and experts, speaking entirely on the most pragmatic and useful topics -- stuff you can apply directly in your current project, not obscure stuff you'll never use. Celebratory of the 20th anniversary of C++, but fully grounded in today's C++ and forward-looking to C++0x. Tools, techniques, applications.&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt;Perhaps the best thing I can say is this: When I go to conferences, I usually just fly in and out just in time for my own talks, and I usually don't attend other conference sessions -- although I'd often like to, I can almost never justify staying given all the other things I'm under the gun to deliver. This conference is compelling enough that, for the first time since the 1990s, I'm clearing my week so that I can actually attend the conference myself, and not just speak (though I'll do that too).&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt;This is going to be a major C++ party. I hope you'll be there.&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt;I see encouraging trends in C++:&lt;/div&gt;
&lt;ul type="disc" style="MARGIN-TOP: 0px; MARGIN-BOTTOM: 0px"&gt;
&lt;li&gt;Universities are switching back to C++ from Java as their primary undergraduate language.&lt;/li&gt;
&lt;li&gt;C++ book sales are up in a difficult market, and a &lt;a href="http://www.gotw.ca/publications/c++cs.htm"&gt;C++-specific book&lt;/a&gt; I coauthored last fall is a &lt;a href="http://pluralsight.com/blogs/hsutter/archive/2005/01/25/5443.aspx"&gt;finalist for this week's Jolt awards&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;By most measures, C++ use in industry never declined and even though it's long been the dominant language it is &lt;em&gt;still&lt;/em&gt; slowly growing (Java has peaked and seems to have started slowly declining by many measures).&lt;/li&gt;
&lt;li&gt;And C++-specific conferences are returning -- after a hiatus with no C++-only events, in 2001 and 2002 we held three successful &lt;a href="http://www.thecppseminar.com"&gt;The C++ Seminar&lt;/a&gt; (TCS) events, in 2004 the &lt;a href="http://www.gotw.ca/sands.htm"&gt;Stroustrup &amp;amp; Sutter on C++&lt;/a&gt; (S&amp;amp;S) fest sold out at double the size of the TCSes, and C++ Connections looks like it will dwarf S&amp;amp;S.&lt;/li&gt;&lt;/ul&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt;Don was almost right: C++ is love. Come to this year's Novemberfest. Learn. Enjoy. Apply. Benefit. (Oh, and did I mention that we're going to roast Bjarne one evening? True. Bring your camera.)&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt;Below I've included the call for submissions. Enjoy,&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt;Herb&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt;&lt;br /&gt;&lt;strong&gt;Conference Announcement and Call For Submissions&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt;Submissions due 15 April 2005&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt;&lt;br /&gt;&lt;strong&gt;"C++ Connections: 20 Years of C++"&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt;Location: Mandalay Bay resort, Las Vegas, NV, USA&lt;br /&gt;Dates: November 7-11, 2005&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt;C++ Connections is a five-day conference event focused on practical C++ practice and experience, and that also celebrates the 20th anniversary of C++'s commercial debut in 1985. The program emphasizes modern real-world techniques and applications along with current topics related to C++’s near-term future, including C++0x, the next revision of the C++ standard now in development. The program is organized as a three-day conference with two days of pre- and post-conference tutorials.&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt;The topics of interest include, but are not limited to:&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt;  Programming and design techniques&lt;br /&gt;    (talks should focus on concrete and proven techniques,&lt;br /&gt;    not on enumerating "pitfalls" or "spot-the-bug" topics)&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt;  Library building and techniques&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt;  Using C++ successfully in real-world applications and interesting problem domains&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt;  Performance studies, metrics, and testing&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt;  Tools supporting C++ design, implementation, and maintenance&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt;  Application-, library-, and compiler-level optimization techniques&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt;&lt;br /&gt;&lt;strong&gt;Conference Program Committee&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt;  Bjarne Stroustrup, Professor, Texas A&amp;amp;M University&lt;br /&gt;  Herb Sutter, Architect, Microsoft Corporation&lt;br /&gt;  Scott Meyers, Independent Consultant&lt;br /&gt;  Douglas Schmidt, Professor, Vanderbilt University&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt;&lt;br /&gt;&lt;strong&gt;Submission Guidelines&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt;We are accepting proposal submissions for 60-minute and 75-minute talks and 3-hour (half-day) tutorial sessions.&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt;To submit a session proposal for consideration, please send an email to &lt;a href="mailto:connections-submissions@gotw.ca"&gt;connections-submissions@gotw.ca&lt;/a&gt; with Subject:”Session proposal: &amp;lt;session title&amp;gt;” and containing all of the following:&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt;  - about you:&lt;br /&gt;      - name and title&lt;br /&gt;      - biographical summary (approx 50 words)&lt;br /&gt;      - picture (suitable for inclusion in the conference program, JPEG preferred)&lt;br /&gt;  - about your proposed session:&lt;br /&gt;      - title and preferred length (60 min, 75 min, or 3 hours)&lt;br /&gt;      - short abstract (approx. 100 words, suitable for inclusion in the conference program)&lt;br /&gt;      - extended abstract (2 to 4 pages incl. content and approach of the session)&lt;br /&gt;  - any additional information you wish to include about your session proposal&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt;&lt;br /&gt;&lt;strong&gt;Important Dates&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt;  Submissions due for review: 15 April 2005&lt;br /&gt;  Initial decision sent: 1 May 2005&lt;br /&gt;  Final version submitted: 1 July 2005&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt; &lt;/div&gt;</content><author><name>herb-sutter</name></author><thr:total>15</thr:total></entry><entry><id>6731</id><published>2005-03-15T05:50:00.0-05:00</published><updated>2005-03-15T05:50:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">re: C++ Connections announcement</title><content type="html">Is there going to be a web site where we can look up room rates and the cost to attend the conference. I'll need that type of info in order to get my company to pay for me to attend.</content><author><name>Anonymous</name></author><thr:in-reply-to ref="6714"></thr:in-reply-to></entry><entry><id>6734</id><published>2005-03-15T09:52:00.0-05:00</published><updated>2005-03-15T09:52:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">re: C++ Connections announcement</title><content type="html">I'm there! (btw, your advice in _C++ Coding Standards_ re: exception-handling and catch(...) in item #62 was very disappointing..)</content><author><name>Anonymous</name></author><thr:in-reply-to ref="6714"></thr:in-reply-to></entry><entry><id>6784</id><published>2005-03-17T12:40:00.0-05:00</published><updated>2005-03-17T12:40:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">re: C++ Connections announcement</title><content type="html">We shouldn't forget the ACCU conferences (see www.accu.org). They are great! But they are also in Oxford, England, so for some they are a bit hard to get to. The next ACCU conference is next month.
&lt;br /&gt;
&lt;br /&gt;  - Bjarne</content><author><name>Anonymous</name></author><thr:in-reply-to ref="6714"></thr:in-reply-to></entry><entry><id>6799</id><published>2005-03-18T14:26:00.0-05:00</published><updated>2005-03-18T14:26:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">re: C++ Connections announcement</title><content type="html">The website just went up -- www.cpp-connections.com . Enjoy,
&lt;br /&gt;
&lt;br /&gt;Herb
&lt;br /&gt;
&lt;br /&gt;</content><author><name>Anonymous</name></author><thr:in-reply-to ref="6714"></thr:in-reply-to></entry><entry><id>6802</id><published>2005-03-19T07:50:00.0-05:00</published><updated>2005-03-19T07:50:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">Interesting finds this week</title><content type="html">Interesting finds this week</content><author><name>Anonymous</name></author><thr:in-reply-to ref="6714"></thr:in-reply-to></entry><entry><id>6827</id><published>2005-03-21T01:46:00.0-05:00</published><updated>2005-03-21T01:46:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">re: C++ Connections announcement</title><content type="html">Responding to Bjarne, the &amp;lt;a href="http://www.accu.org/conference/"&amp;gt;ACCU conference&amp;lt;/a&amp;gt; is something we're very proud of. And we do hope that Herb will be turning up, since he is on the programme.
&lt;br /&gt;
&lt;br /&gt;Having said that, it's not a C++-only conference, though the organisation is very strongly based on C and C++.
&lt;br /&gt;
&lt;br /&gt;Alan Bellingham, declaring an interest as secretary of ACCU.</content><author><name>Anonymous</name></author><thr:in-reply-to ref="6714"></thr:in-reply-to></entry><entry><id>6831</id><published>2005-03-21T06:47:00.0-05:00</published><updated>2005-03-21T06:47:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">re: C++ Connections announcement</title><content type="html">Yup, ACCU and SD are the two big conferences that still have strong C++ content, even though they're not exclusively about C++. ACCU in particular is always a blast because the audience is always highly interactive and supercharged. I'm looking forward to coming again next month.
&lt;br /&gt;
&lt;br /&gt;</content><author><name>Anonymous</name></author><thr:in-reply-to ref="6714"></thr:in-reply-to></entry><entry><id>6844</id><published>2005-03-22T00:45:00.0-05:00</published><updated>2005-03-22T00:45:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">re: C++ Connections announcement</title><content type="html">Yes, on first glance I thought "Yikes!" competition to ACCU!  For your one-conference a month jet-setting C++ programmer this might be so but when you think about it they are on 4000 miles and six months apart.
&lt;br /&gt;
&lt;br /&gt;I'm also guessing from Herb's tone that C++ Connections (and the title) that this is much more closely focused on C++.  ACCU is actually quite broad these days taking in a lot of Agile, Patterns, C, Java, C# plus a Python conference and general security track.
&lt;br /&gt;
&lt;br /&gt;Umm, does that sound too much like an advert?     (Just because I'm on the conference committee you shouldn't assume I'm biased...)</content><author><name>Anonymous</name></author><thr:in-reply-to ref="6714"></thr:in-reply-to></entry><entry><id>6845</id><published>2005-03-22T00:55:00.0-05:00</published><updated>2005-03-22T00:55:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">re: C++ Connections announcement</title><content type="html">Hi! Where can i find additional info about this conference (price, guest placing, e.t.c). How can i register myself? I'm from Russia... it's far away from Las Vegas... :) But i'm realy want to visit this meeting.</content><author><name>Anonymous</name></author><thr:in-reply-to ref="6714"></thr:in-reply-to></entry><entry><id>6846</id><published>2005-03-22T02:26:00.0-05:00</published><updated>2005-03-22T02:26:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">re: C++ Connections announcement</title><content type="html">&lt;br /&gt;I see that Alan and Allan have beaten me to it, but thanks Herb &amp;amp; Bjarne for the kind words - everyone is very much looking forward to seeing you both next month.
&lt;br /&gt;
&lt;br /&gt;Wishing you all the best for your event, sounds very exciting. Makes we wonder if I can persuade my company about a November week in Vegas...
&lt;br /&gt;
&lt;br /&gt;Ewan (ACCU Chair)</content><author><name>Anonymous</name></author><thr:in-reply-to ref="6714"></thr:in-reply-to></entry><entry><id>6848</id><published>2005-03-22T10:00:00.0-05:00</published><updated>2005-03-22T10:00:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">re: C++ Connections announcement</title><content type="html">Cyberz asked:
&lt;br /&gt;
&lt;br /&gt;&amp;gt;Hi! Where can i find additional info about
&lt;br /&gt;&amp;gt;this conference (price, guest placing,
&lt;br /&gt;&amp;gt;e.t.c). How can i register myself?
&lt;br /&gt;
&lt;br /&gt;Sure -- just check out www.cpp-connections.com.
&lt;br /&gt;
&lt;br /&gt;I guess I should update the main blog entry to reflect the URL (which wasn't available when I first blogged it). Going there now...
&lt;br /&gt;
&lt;br /&gt;Herb
&lt;br /&gt;</content><author><name>Anonymous</name></author><thr:in-reply-to ref="6714"></thr:in-reply-to></entry><entry><id>7222</id><published>2005-04-05T23:01:00.0-05:00</published><updated>2005-04-05T23:01:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">re: C++ Connections announcement</title><content type="html">I wonder why you often mention Java as a kind of a competitor to C++? It's not Java that's going to be 'C++ killer'. It's .Net. And I suspect you at Microsoft perfectly know that. Well, of course C++ will be a viable option for some years to come but we must realize that'll be ONLY because of a huge C++ code base out there. Do you ever look through papers with job offers? I doubt it. But if you did, you would be sure to discover that when it comes to .Net development it's ALWAYS C#(sometimes VB) but NEVER C++. Do you think these are 'encouraging trends in C++'?     </content><author><name>Anonymous</name></author><thr:in-reply-to ref="6714"></thr:in-reply-to></entry><entry><id>7223</id><published>2005-04-05T23:30:00.0-05:00</published><updated>2005-04-05T23:30:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">re: C++ Connections announcement</title><content type="html">Paul wrote: &amp;gt;&amp;gt; Do you ever look through papers with job offers? I doubt it. But if you did, you would be sure to discover that when it comes to .Net development it's ALWAYS C#(sometimes VB) but NEVER C++. Do you think these are 'encouraging trends in C++'? &amp;lt;&amp;lt;
&lt;br /&gt;
&lt;br /&gt;I do monitor trends, including not just job offers but developer surveys, book sales, conferences, and other indicators. You're completely correct that there's virtually no C++ on .NET on the shipping product today, and that's because C++ had poor support for the managed world in Visual Studio .NET and 2003. Check out C++/CLI, which we're shipping this year in VS 2005, and once it's been out there for a year or two let's look at the indicators again and see where we are in 2006-7.
&lt;br /&gt;
&lt;br /&gt;As for whether C++ is important in a managed world, my OOPSLA keynote last fall on this topic will be on the website soon and I'll post a link here when it's available. I hope that, if it doesn't convince you, it might at least give food for thought and some perspective on why both C++ and managed environments are going to exist and remain important for the foreseeable future.
&lt;br /&gt;
&lt;br /&gt;</content><author><name>Anonymous</name></author><thr:in-reply-to ref="6714"></thr:in-reply-to></entry><entry><id>8564</id><published>2005-05-25T06:05:00.0-05:00</published><updated>2005-05-25T06:05:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">Is C   back?</title><content type="html"></content><author><name>Anonymous</name></author><thr:in-reply-to ref="6714"></thr:in-reply-to></entry><entry><id>8565</id><published>2005-05-25T06:11:00.0-05:00</published><updated>2005-05-25T06:11:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">Is C   in fashion again?</title><content type="html"></content><author><name>Anonymous</name></author><thr:in-reply-to ref="6714"></thr:in-reply-to></entry><entry><id>6804</id><published>2005-03-19T20:43:00.0-05:00</published><updated>2005-03-19T20:43:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#post"></category><title type="text">Concurrency and (not) state</title><content type="html">&lt;div&gt;&lt;font size="2"&gt;
&lt;/font&gt;&lt;div&gt;Iain McInnes wrote in a comment that he sees the solution to concurrency as:&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;&lt;/div&gt;&lt;font size="2"&gt;
&lt;/font&gt;&lt;div style="PADDING-LEFT: 50px"&gt;Don't share data between threads. Just don't&lt;/div&gt;
&lt;div style="PADDING-LEFT: 50px"&gt;Easy to say: People didn't like giving up GOTO, either.&lt;/div&gt;
&lt;div style="PADDING-LEFT: 50px"&gt;What's the alternative ? Asynchronous message exchange.&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt;Bingo. That's the core lesson, and it's the cornerstone of a design I've been working on since late last year: Shared state is evil (for concurrency, but also for so many other reasons including plain old single-threaded coupling). Async messages are the way to communicate.&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt;But recognizing that is really just the fundamental and easy first step. The next few steps after it are also fairly obvious (e.g., you need to add support for futures). But there's still a fair amount of design work needed for a language to be built on top of that to make it usable: How do you expose concurrency in the programming language, especially if you're extending an imperative language, not a functional one where concurrency is already pretty easy? How do you deal with both coarse-grained (e.g., task-level) and fine-grained (e.g., loop-level) concurrency, preferably using the same language construct that can scale up and down that far to cover the whole range? How do you deal with the fact that sometimes two threads do have to rendezvous and collaborate for a while, exchanging data according to some protocol?&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt;Point solutions already exist for all of these things, but they now need to be brought into mainstream programming languages in a usable and accessible way. And that's what I call the "OO of concurrency" -- those extensions will be as much of an extension as classes and virtual functions.&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div align="left"&gt;Ada95 and Java do some of it (but not nearly enough), ditto for research languages like µC++, and ditto for OpenMP (which I view as industrial-strength duct tape, strong but an ugly band-aid) -- all of those are more similar than they are different, and incremental steps that basically stick with the current status quo (in particular, supporting shared state and locking), which is fundamentally not good enough. Some research languages like Polyphonic C# (Comega) go further -- Comega's chords are fun, and their main problem is that they're not the solution for mainstream programmers because using them requires thinking in a much more Lisp- or Prolog-esque way, and there's little evidence that mainstream programmers can or will bend their minds in that way). Functional languages have long been well-suited to concurrency, but likewise I doubt that mainstream programmers will make a functional language the dominant commercial programming language anytime soon; it's too different from the imperative model.&lt;/div&gt;
&lt;div align="left"&gt; &lt;/div&gt;
&lt;div align="left"&gt;So there's a lot of interesting research and directions, exploring useful avenues, but we need something a lot smoother, cleaner, and applicable to current &lt;u&gt;imperative&lt;/u&gt; programming languages. I and other people are actively working on that.&lt;/div&gt;
&lt;div align="left"&gt; &lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt; &lt;/div&gt;</content><author><name>herb-sutter</name></author><thr:total>10</thr:total></entry><entry><id>6806</id><published>2005-03-19T19:48:00.0-05:00</published><updated>2005-03-19T19:48:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">Object, know thyself</title><content type="html">Herb Sutter shows up at the message-passing party That's the core lesson, and it's the cornerstone of a design I've been working on since late last year: Shared state is evil (for concurrency, but also for so many other reasons including plain old single-threaded coupling). Async messages are the way to communicate. He goes on to say: Point solutions already exist for all of these things, but they now need to be brought into mainstream programming languages in a usable and accessible way. And that's what I call the "OO of concurrency" -- those extensions will be as much of an extension as classes and virtual functions. Ada95 and Java do some of it (but not nearly enough), ditto for research languages like µC++, and ditto for OpenMP (which I view as industrial-strength duct tape, strong but an ugly band-aid) -- all of those are more similar than they are different, and incremental steps that basically stick with the current status quo (in particular, supporting shared state and locking), which is fundamentally not good enough. [...]. Functional languages have long been well-suited to concurrency, but likewise I doubt that mainstream programmers will make a functional language the dominant commercial programming language anytime soon; it's too different from the imperative model. So there's a lot of interesting research and directions, exploring useful avenues, but we need something a lot smoother, cleaner, and applicable to current imperative programming languages. I and other people are actively working on that. You'd be forgiven for thinking that if message passing and state isolation is that important at the programming level (as opposed to the XML-contracty stuff we see in REST/WS/SOA) by the time you're done patching C++ VTables, or waiting for Java to have Isolates, or waiting for Windows to have Indigo, you might as well have shipped it with E, Erlang [1] or Smalltalk. And as far as I can tell, a pure message passing language is going to make for a much bigger leap for the worker bees than the object/functional chasm would require. [1] Real world, can do....</content><author><name>Anonymous</name></author><thr:in-reply-to ref="6804"></thr:in-reply-to></entry><entry><id>6828</id><published>2005-03-21T02:37:00.0-05:00</published><updated>2005-03-21T02:37:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">re: Concurrency and (not) state</title><content type="html">I don't think functional / declarative programming languages are too hard for the average programmer to pick up; it's just that you have to travel too far to find a declarative language.
&lt;br /&gt;
&lt;br /&gt;If there were more mainstream languages out there with simple, easy to use declarative constructs I think we'd be well on our way to giving compilers more informormation - the kind of information they need for efficient use of the multi-CPU-core architectures we'll see in the future.</content><author><name>Anonymous</name></author><thr:in-reply-to ref="6804"></thr:in-reply-to></entry><entry><id>6839</id><published>2005-03-21T17:03:00.0-05:00</published><updated>2005-03-21T17:03:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">re: Concurrency and (not) state</title><content type="html">The fundamental and most important aspect of asynchronous message passing designs is figuring out the invariants of which messages can be delivered when and to which actors in the concurrent system. An example of an invariant would be:
&lt;br /&gt;    If a IOStart message is delivered, an IOEnd message will be delivered no matter what.
&lt;br /&gt;
&lt;br /&gt;(This allows one to reliably clean up a resource allocated in the IOStart. Furthermore it establishes a design pattern to use with the component that is sending the messages.)
&lt;br /&gt;
&lt;br /&gt;Beyond this, it must be documented what calls are allowed in the handler for a message itself. (And how message delivery is affected, if at all. E.g. if I cancel the operation in the IOStart handler, do I still get an IOEnd message? I've dealt with more than one system that gives an unexpected result in that case.)
&lt;br /&gt;
&lt;br /&gt;Anything that can be added to the compilation system to do compile time detection of violations of these invariants would be a huge win.
&lt;br /&gt;
&lt;br /&gt;I make this point having a lot of experience with badly implemented concurrent message passing systems, including plain old Win32 events. One ends up chasing down a lot of bugs where the order of message delivery is critical and there are no guarantees documented by the message sender (Win32) in many cases.
&lt;br /&gt;
&lt;br /&gt;Given the choice between commonly found "anarchy oriented message passing" and a pthreads-like system, I'll take pthreads in a New York minute. I might implement my own "sane" message passing using pthreads, but at least I'm not fighting a lot of non-deterministic behavior in the components I'm building on top of to get the job done.
&lt;br /&gt;
&lt;br /&gt;(I suppose another way to phrase this is that in thread based designs, one typically does not see component interfaces expose any access to the thread level primitives. E.g. one does not usually design classes with an exposed condition variable. In message passign designs, often low level details, such as message ordering,  are exposed, often unintentionally.)
&lt;br /&gt;</content><author><name>Anonymous</name></author><thr:in-reply-to ref="6804"></thr:in-reply-to></entry><entry><id>6842</id><published>2005-03-21T23:20:00.0-05:00</published><updated>2005-03-21T23:20:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">re: Concurrency and (not) state</title><content type="html">Zalman Stern wrote:
&lt;br /&gt;
&lt;br /&gt;Given the choice between commonly found "anarchy oriented message passing" and a pthreads-like system, I'll take pthreads in a New York minute.
&lt;br /&gt;
&lt;br /&gt;When you express it like that, I agree.  But message passing doesn’t have to involve anarchy.  The focus of the design simply needs to change.  The design problem becomes that of designing protocols between stateful entities (objects).  Often we try to lash up a set of conditionals which determine the response of the object under different conditions.  But we keep finding exceptions which aren’t handled properly – so we one or more flag variables: thus creating more state, and more unexpected conditions.  Hence sequencing issues and unexpected behaviour.  Yes, interaction amongst stateful objects is hard.
&lt;br /&gt;
&lt;br /&gt;But there are strong design techniques which address those issues.  The only sensible way to implement a moderately complex concurrent (message passing) object is via a state machine.  A properly designed state machine will have a well defined (correct) behaviour for every event (message) received in every state.  The design of the application *becomes* the design of the interactions and the states.
&lt;br /&gt;
&lt;br /&gt;A state machine is a rare beast in the software world:  The specification and the implementation are very close.  Sufficiently close that you will find design tools where, once you have specified and modelled the design (i.e. the objects, states and interactions) the tool will generate the code automatically.  I personally don’t think we have to go that far – I’d far prefer to read well crafted code, than rely on some design tool.  But the process of writing software becomes that of analysis, specification and design.  The coding is simply the implementation of the design.  I’m all for that.
&lt;br /&gt;</content><author><name>Anonymous</name></author><thr:in-reply-to ref="6804"></thr:in-reply-to></entry><entry><id>6850</id><published>2005-03-22T12:46:00.0-05:00</published><updated>2005-03-22T12:46:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">re: Concurrency and (not) state</title><content type="html">Yes, my own message passing designs almost always use a state machine. I often have a class with an enum listing the states and a comment giving the transitions and various invariants about the states, etc. It also lends it self to decomposition when there are too many states as one can tear out a portion and make it into a new state machine.
&lt;br /&gt;
&lt;br /&gt;I am more concerned with the external interface presented by reuseable components in a concurrent world. For message passing, this could involve using state machines as a design technique but more importantly, documenting the state machine and the intended protocols for clients.
&lt;br /&gt;
&lt;br /&gt;I've really run into a lot of problems with badly designed and badly documented event driven and message passing APIs in my career. Thus my emphasis on making sure we are paying attention to the important parts of the problem when proposing this as an improvement over other concurrency mechanisms.
&lt;br /&gt;</content><author><name>Anonymous</name></author><thr:in-reply-to ref="6804"></thr:in-reply-to></entry><entry><id>6883</id><published>2005-03-25T09:28:00.0-05:00</published><updated>2005-03-25T09:28:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">re: Concurrency and (not) state</title><content type="html">Has anyone ever looked into CASS threading for Asynchronous messages? It seems like they might go well together if the values being checked by the threads were the messages in the queue. I don't know if it would ensure that one thread would always progress but it seems like it could be worked that way. That way you wouldn't have to share data yet all threads could operate on the same data for I/O type of things. I know Andre's examples were with modified list but I don't see why a message queue couldn't work just as well. Just a thought anyway.</content><author><name>Anonymous</name></author><thr:in-reply-to ref="6804"></thr:in-reply-to></entry><entry><id>6899</id><published>2005-03-28T03:33:00.0-05:00</published><updated>2005-03-28T03:33:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">re: Concurrency and (not) state</title><content type="html">One possible answer to a question "why concurrency problem appears in the first place?" is that there is a limited resources that have to be shared.
&lt;br /&gt;
&lt;br /&gt;Thus, one should queue access (in some way) to these resources.
&lt;br /&gt;
&lt;br /&gt;Because of this arguing, I think, it's hard enough to disengage from the concurrency problem in a general way.</content><author><name>Anonymous</name></author><thr:in-reply-to ref="6804"></thr:in-reply-to></entry><entry><id>7238</id><published>2005-04-06T19:32:00.0-05:00</published><updated>2005-04-06T19:32:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">re: Concurrency and (not) state</title><content type="html">A state machine with enums listing the state seems to be common. A language construct that can capture this state-machine-with-enum would be nice as it can increase productivity and reduce bugs.</content><author><name>Anonymous</name></author><thr:in-reply-to ref="6804"></thr:in-reply-to></entry><entry><id>7930</id><published>2005-05-01T13:27:00.0-05:00</published><updated>2005-05-01T13:27:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">re: Concurrency and (not) state</title><content type="html">The new pipes in linux are very asynchronous.  One could easily build an async messaging system based on that, by having say a central thread that you send data to and manages communication between the other async channels.  </content><author><name>Anonymous</name></author><thr:in-reply-to ref="6804"></thr:in-reply-to></entry><entry><id>32787</id><published>2006-08-03T02:00:00.0-05:00</published><updated>2006-08-03T02:00:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">并发冲突控制与数据共享</title><content type="html">HSutter???????????????????????,????????????????????,????C  ????????????????????????????</content><author><name>Anonymous</name></author><thr:in-reply-to ref="6804"></thr:in-reply-to></entry><entry><id>7199</id><published>2005-04-05T10:26:00.0-05:00</published><updated>2005-04-05T10:26:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#post"></category><title type="text">Two new articles</title><content type="html">&lt;div align="left"&gt;Jim and I have now written &lt;a href="http://www.gotw.ca/publications"&gt;two new articles&lt;/a&gt;:&lt;/div&gt;
&lt;div align="left"&gt; &lt;/div&gt;
&lt;ul type="disc" style="MARGIN-TOP: 0px; MARGIN-BOTTOM: 0px"&gt;
&lt;li&gt;
&lt;div align="left"&gt;&lt;font size="2"&gt;&lt;strong&gt;Polymorphic Exceptions&lt;/strong&gt;&lt;font size="2"&gt; (with Jim Hyslop)&lt;/font&gt;,&lt;br /&gt;&lt;font color="#000080"&gt;&lt;em&gt;C/C++ Users Journal&lt;/em&gt;, 23(4), April 2005.&lt;/font&gt;&lt;br /&gt;What do you do when you want to throw an exception, the exception object is a derived class, but all you have is a reference to the base class?&lt;/font&gt;&lt;/div&gt;&lt;/li&gt;&lt;/ul&gt;
&lt;div align="left"&gt; &lt;/div&gt;
&lt;ul type="disc" style="MARGIN-TOP: 0px; MARGIN-BOTTOM: 0px"&gt;
&lt;li&gt;
&lt;div align="left"&gt;&lt;strong&gt;Logically Shallow Views&lt;/strong&gt;&lt;font size="2"&gt; (with Jim Hyslop),&lt;br /&gt;&lt;font color="#000080"&gt;&lt;font color="#000080"&gt;&lt;em&gt;C/C++ Users Journal&lt;/em&gt;, 23(5), May 2005.&lt;/font&gt;&lt;br /&gt;&lt;/font&gt;&lt;strong&gt;const&lt;/strong&gt; is logical, not physical; shallow, not deep; and a promise on the view, not necessarily a promise on the object.&lt;/font&gt;&lt;/div&gt;&lt;/li&gt;&lt;/ul&gt;
&lt;div align="left"&gt; &lt;/div&gt;
&lt;div align="left"&gt;These are the 58th and 59th installments of our &lt;em&gt;&lt;a href="http://www.gotw.ca/conv"&gt;Conversations&lt;/a&gt;&lt;/em&gt; column. The 60th, and final, installment will appear in the June issue of CUJ as we wrap up this column five years after it began. It's hard to believe we've already done that many since we began the column back in April 2000 in the &lt;em&gt;C++ Report&lt;/em&gt;, but in the past five years there have been only two months where we skipped a month. After taking some time off to recuperate :-), we intend to rework all the columns to add some details and improvements and to organize them topically, and publish the results as a book. It could be available as soon as a year from now…&lt;/div&gt;
&lt;div align="left"&gt; &lt;/div&gt;
&lt;div align="left"&gt;Enjoy!&lt;/div&gt;
&lt;div align="left"&gt; &lt;/div&gt;
&lt;div align="left"&gt; &lt;/div&gt;</content><author><name>herb-sutter</name></author><thr:total>4</thr:total></entry><entry><id>7202</id><published>2005-04-05T06:35:00.0-05:00</published><updated>2005-04-05T06:35:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">re: Two new articles</title><content type="html">What happened to Jeannine &amp;amp; the original characters of the story?</content><author><name>Anonymous</name></author><thr:in-reply-to ref="7199"></thr:in-reply-to></entry><entry><id>7254</id><published>2005-04-07T15:12:00.0-05:00</published><updated>2005-04-07T15:12:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">re: Two new articles</title><content type="html">&amp;gt;  What happened to Jeannine &amp;amp; the 
&lt;br /&gt;&amp;gt; original characters of the story?
&lt;br /&gt;
&lt;br /&gt;Outsourced.
&lt;br /&gt;
&lt;br /&gt;
&lt;br /&gt;</content><author><name>Anonymous</name></author><thr:in-reply-to ref="7199"></thr:in-reply-to></entry><entry><id>7645</id><published>2005-04-20T12:53:00.0-05:00</published><updated>2005-04-20T12:53:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">sad to see it go</title><content type="html">It will be sad to see that column go! It's a very nice format to present these topics. It was the thing I liked most :-(</content><author><name>Anonymous</name></author><thr:in-reply-to ref="7199"></thr:in-reply-to></entry><entry><id>8460</id><published>2005-05-18T21:04:00.0-05:00</published><updated>2005-05-18T21:04:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">re: Two new articles</title><content type="html">Hmm - just got the June 2005 issue of CUJ today, and was sad to not see a "Conversations" column.  It will be missed.  Looking forward to the book!
&lt;br /&gt;
&lt;br /&gt;May the Guru slam a tome behind you another day!</content><author><name>Anonymous</name></author><thr:in-reply-to ref="7199"></thr:in-reply-to></entry><entry><id>7224</id><published>2005-04-06T05:32:00.0-05:00</published><updated>2005-04-06T05:32:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#post"></category><title type="text">OOPSLA keynote now online for viewing</title><content type="html">&lt;div&gt;The talk I gave at OOPSLA about "&lt;a href="http://msdn.microsoft.com/visualc/using/multimedia/oopsla/default.aspx"&gt;Concrete Languages on Virtual Platforms&lt;/a&gt;" is now online. The abstract is:&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;blockquote style="MARGIN-TOP: 0px; MARGIN-BOTTOM: 0px"&gt;From the JVM to .NET, virtual machine runtime environments with garbage collection are now the mainstream of computing rather than the exception, and they are here to stay. Microsoft has bet its medium-term future on it: The successor to Win32 as the API for Windows Longhorn is WinFX, which is based on today's .NET Frameworks and puts the garbage-collected VM squarely at the heart of a major operating system. In this talk, the lead architect of C++/CLI talks about the importance and viability of environments based on virtual machines and garbage collection, even for performance-driven applications, and demonstrates the challenges and rewards of evolving existing performance- and hardware-oriented languages to operate seamlessly and with first-class status in modern virtual environments.&lt;/blockquote&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt; &lt;/div&gt;</content><author><name>herb-sutter</name></author><thr:total>7</thr:total></entry><entry><id>7225</id><published>2005-04-06T05:12:00.0-05:00</published><updated>2005-04-06T05:12:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">OOPSLA keynote now online for viewing</title><content type="html">By one of my most respected person in the industry, Herb Sutter gave a talk @ the OOPSLA on "Concrete...</content><author><name>Anonymous</name></author><thr:in-reply-to ref="7224"></thr:in-reply-to></entry><entry><id>7471</id><published>2005-04-17T23:10:00.0-05:00</published><updated>2005-04-17T23:10:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">re: OOPSLA keynote now online for viewing</title><content type="html">Nice talk; learned some interesting things. Thanks.</content><author><name>Anonymous</name></author><thr:in-reply-to ref="7224"></thr:in-reply-to></entry><entry><id>7651</id><published>2005-04-21T00:51:00.0-05:00</published><updated>2005-04-21T00:51:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">re: OOPSLA keynote now online for viewing</title><content type="html">Herb talk to the folks at Microsoft hosting this talk... They do browser detection and block Firefox saying it doesn't support "plugins"! By faking it out as *an old Netscape browser* I was able to watch your video on Firefox. This kind of silliness just makes Microsoft look bad.</content><author><name>Anonymous</name></author><thr:in-reply-to ref="7224"></thr:in-reply-to></entry><entry><id>7653</id><published>2005-04-21T01:42:00.0-05:00</published><updated>2005-04-21T01:42:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">re: OOPSLA keynote now online for viewing</title><content type="html">Small bug in presentation. Your ReadFirstLineFromFile Java example is a little unfairly complex. A much simpler solution (with the same effect) would look like this:
&lt;br /&gt;
&lt;br /&gt;String ReadFirstLineFromFile(String path) {
&lt;br /&gt;	StringReader r = new StreamReader(path);
&lt;br /&gt;	try {
&lt;br /&gt;		return r.ReadLine();
&lt;br /&gt;	} finally {
&lt;br /&gt;		r.Dispose();
&lt;br /&gt;	}
&lt;br /&gt;}</content><author><name>Anonymous</name></author><thr:in-reply-to ref="7224"></thr:in-reply-to></entry><entry><id>8567</id><published>2005-05-25T04:46:00.0-05:00</published><updated>2005-05-25T04:46:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">re: OOPSLA keynote now online for viewing</title><content type="html">hey herb... i know this is a little off topic but will the new C++ Express client support old style MFC apps aswell as the new manged windows forms?</content><author><name>Anonymous</name></author><thr:in-reply-to ref="7224"></thr:in-reply-to></entry><entry><id>9663</id><published>2005-05-31T13:29:00.0-05:00</published><updated>2005-05-31T13:29:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">re: OOPSLA keynote now online for viewing</title><content type="html">Hi,
&lt;br /&gt;
&lt;br /&gt;This is a little bit off topic. I heard that STL.NET (or STL/CLR) will not be available as a full release when VS2005 ships. Is that true? Why Microsoft is treating C++/CLI as a second class citizen in .NET languages?
&lt;br /&gt;
&lt;br /&gt;Thanks,
&lt;br /&gt;John.</content><author><name>Anonymous</name></author><thr:in-reply-to ref="7224"></thr:in-reply-to></entry><entry><id>9665</id><published>2005-05-31T15:19:00.0-05:00</published><updated>2005-05-31T15:19:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">re: OOPSLA keynote now online for viewing</title><content type="html">John Thomas asked:
&lt;br /&gt;&amp;gt;&amp;gt;I heard that STL.NET (or STL/CLR) will not be available as a full release when VS2005 ships. Is that true? Why Microsoft is treating C++/CLI as a second class citizen in .NET languages?&amp;lt;&amp;lt;
&lt;br /&gt;
&lt;br /&gt;Yes, it's true, and it's not a second-class issue (our team, VC++, is delivering both), it's just a timing issue.
&lt;br /&gt;
&lt;br /&gt;Implementing the C++/CLI language extensions took a large amount of work in the compiler, and naturally those had to be done before STL/CLR could be built on top of them and tested extensively. The language implementation took longer than expected (in part because we were also devoting resources to participating in an open standard for these extensions, which took away some developer time to participate in general and to implement changes to the design made by the committee), and that meant we got a correspondingly later start with STL/CLR. When we saw we couldn't get STL/CLR to the level of quality and performance we wanted it to be to ship it without delaying the whole VC++ 2005 product, we decided to ship it out of band this time instead of delaying the product. The intent is definitely to have STL/CLR in the box going forward, it just didn't quite make the box this time and we didn't want to ship something that was 3/4 baked when giving it just a few more months would make it a lot better and production-quality.
&lt;br /&gt;
&lt;br /&gt;Herb
&lt;br /&gt;</content><author><name>Anonymous</name></author><thr:in-reply-to ref="7224"></thr:in-reply-to></entry><entry><id>9707</id><published>2005-06-02T16:01:00.0-05:00</published><updated>2005-06-02T16:01:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#post"></category><title type="text">Two new articles for July mags</title><content type="html">&lt;div align="left"&gt;Once again, there are &lt;a href="http://www.gotw.ca/publications"&gt;two new articles&lt;/a&gt; for the July issue of CUJ. After this, I'll continue writing for CUJ and other magazines, but I intend to throttle back a bit so I won't have an article in every issue of CUJ.&lt;/div&gt;
&lt;div align="left"&gt; &lt;/div&gt;
&lt;ul type="disc" style="MARGIN-TOP: 0px; MARGIN-BOTTOM: 0px"&gt;
&lt;li&gt;
&lt;div align="left"&gt;&lt;font size="2"&gt;&lt;strong&gt;Graceful Exits &lt;/strong&gt;&lt;font size="2"&gt;(with Jim Hyslop)&lt;/font&gt;,&lt;br /&gt;&lt;font color="#000080"&gt;&lt;em&gt;C/C++ Users Journal&lt;/em&gt;, 23(7), July 2005.&lt;/font&gt;&lt;br /&gt;When you detect an error or invalid state in a function, what’s the best way to handle it: return an error code, throw an exception, or call assert()? Well, as is frequently the case, the answer is "that depends…"&lt;/font&gt;&lt;/div&gt;&lt;/li&gt;&lt;/ul&gt;
&lt;div align="left"&gt; &lt;/div&gt;
&lt;ul type="disc" style="MARGIN-TOP: 0px; MARGIN-BOTTOM: 0px"&gt;
&lt;li&gt;
&lt;div align="left"&gt;&lt;strong&gt;Trip Report: April 2005&lt;/strong&gt;&lt;font size="2"&gt; (with Jim Hyslop),&lt;br /&gt;&lt;font color="#000080"&gt;&lt;font color="#000080"&gt;&lt;em&gt;C/C++ Users Journal&lt;/em&gt;, 23(7), July 2005.&lt;/font&gt;&lt;br /&gt;&lt;/font&gt;News and views from the spring 2005 C and C++ standards meetings in Lillehammer, Norway. The big news: The C++ evolution working group has set this fall is the deadline for new proposals, after which we'll be heads-down trying to finish most of the technical work next ISO C++ standard by 2007 so that the new standard can be published in 2009. (It would be nice if the "x" in "C++0x" didn't need to be a hexadecimal digit…) This column also summarizes the main changes you can expect to C++ and why they matter to you.&lt;/font&gt;&lt;/div&gt;&lt;/li&gt;&lt;/ul&gt;
&lt;div align="left"&gt; &lt;/div&gt;
&lt;div align="left"&gt;"Graceful Exits" is the 60th and final installment of the &lt;a href="http://www.gotw.ca/conv"&gt;Conversations&lt;/a&gt; column. Thanks again to my coauthor Jim and to the many readers who have emailed us with kudos and questions about the column over the past five years.&lt;/div&gt;
&lt;div align="left"&gt; &lt;/div&gt;
&lt;div align="left"&gt;Enjoy!&lt;/div&gt;
&lt;div align="left"&gt; &lt;/div&gt;
&lt;div align="left"&gt; &lt;/div&gt;</content><author><name>herb-sutter</name></author><thr:total>3</thr:total></entry><entry><id>9708</id><published>2005-06-02T11:08:00.0-05:00</published><updated>2005-06-02T11:08:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">re: Two new articles for July mags</title><content type="html">Will Conversations #35 and later be available online? Or should we wait for the book?</content><author><name>Anonymous</name></author><thr:in-reply-to ref="9707"></thr:in-reply-to></entry><entry><id>9709</id><published>2005-06-02T11:54:00.0-05:00</published><updated>2005-06-02T11:54:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">re: Two new articles for July mags</title><content type="html">Yuri asked:
&lt;br /&gt;&amp;gt;&amp;gt;Will Conversations #35 and later be available online? Or should we wait for the book?&amp;lt;&amp;lt;
&lt;br /&gt;
&lt;br /&gt;I used to put all my articles online a few months after their print dates, and I've fallen far behind. I do keep meaning catch up with that, but I'm constantly swamped. My best answer right now is that I still have the best intentions and I might get around to putting the original versions up on the website someday, but I've been saying that for 2-3 years now.
&lt;br /&gt;
&lt;br /&gt;Herb
&lt;br /&gt;
&lt;br /&gt;</content><author><name>Anonymous</name></author><thr:in-reply-to ref="9707"></thr:in-reply-to></entry><entry><id>9721</id><published>2005-06-02T19:41:00.0-05:00</published><updated>2005-06-02T19:41:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">re: Two new articles for July mags</title><content type="html">How can I read the whole articles?
&lt;br /&gt;thx</content><author><name>Anonymous</name></author><thr:in-reply-to ref="9707"></thr:in-reply-to></entry><entry><id>9729</id><published>2005-06-03T10:50:00.0-05:00</published><updated>2005-06-03T10:50:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#post"></category><title type="text">C++/CLI Update</title><content type="html">&lt;div&gt;The C++/CLI standards work is nearing completion. Here's some quick news and where to find the latest public drafts.&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt;&lt;strong&gt;Timing update:&lt;/strong&gt; We decided to take a six-month slip (the smallest slip possible in Ecma, which votes on standards twice a year) and now expect the Ecma C++/CLI standard to be technically complete by September 2005 for an Ecma vote in December 2005.&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt;&lt;strong&gt;Where to find drafts:&lt;/strong&gt; The most recent public draft is 1.12. &lt;a href="http://www.plumhall.com/ecma/"&gt;Plum Hall's repository&lt;/a&gt; of public drafts has links to this and several older versions so that people who are interested can use PDF's "diff" to see changes over time. You can also use these linked searches via &lt;a href="http://search.msn.com/results.aspx?srch=105&amp;amp;FORM=AS5&amp;amp;q=%22c%2b%2b%2fcli%22+%22working+draft%22"&gt;MSN Search&lt;/a&gt; or &lt;a href="http://www.google.com/search?hl=en&amp;amp;lr=&amp;amp;q=%22c%2B%2B%2Fcli%22+%22working+draft%22"&gt;Google&lt;/a&gt; for an up-to-date list of locations that carry the public drafts, as well as of other sites and papers that reference the drafts.&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt; &lt;/div&gt;</content><author><name>herb-sutter</name></author><thr:total>2</thr:total></entry><entry><id>9748</id><published>2005-06-04T16:43:00.0-05:00</published><updated>2005-06-04T16:43:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">re: C++/CLI Update</title><content type="html">Objects are garbate. Lists hold the truth.</content><author><name>Anonymous</name></author><thr:in-reply-to ref="9729"></thr:in-reply-to></entry><entry><id>14853</id><published>2005-09-16T01:58:00.0-05:00</published><updated>2005-09-16T01:58:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">PDC05 Day Three!</title><content type="html">Before I get started I want to point out a couple of items for tomorrow:
&lt;br /&gt;1) Herb Sutter's 10:30a.m....</content><author><name>Anonymous</name></author><thr:in-reply-to ref="9729"></thr:in-reply-to></entry><entry><id>13496</id><published>2005-07-25T22:02:00.0-05:00</published><updated>2005-07-25T22:02:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#post"></category><title type="text">New article on the software impact of concurrency (ACM Queue)</title><content type="html">&lt;div&gt;A few months ago, &lt;a href="http://www.acmqueue.org/"&gt;ACM Queue&lt;/a&gt; asked if I'd write an article for them about the software impact of concurrency. I agreed, and colleague &lt;a href="http://research.microsoft.com/~larus/"&gt;Jim Larus&lt;/a&gt; graciously agreed to coauthor it with me. The results will be in the September 2005 issue of ACM Queue. Here is a title and abstract.&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div style="PADDING-LEFT: 50px"&gt;&lt;strong&gt;Software and the Concurrency Revolution&lt;/strong&gt;&lt;/div&gt;
&lt;div style="PADDING-LEFT: 50px"&gt; &lt;/div&gt;
&lt;div style="PADDING-LEFT: 50px"&gt;The concurrency revolution is primarily a software revolution. Soon all new machines will be multicore, and the difficult problem is programming these machines in a way in which mainstream applications benefit from the continued exponential growth in CPU performance.&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt;I plan to put the full text of this article &lt;a href="http://www.gotw.ca/publications"&gt;on my website&lt;/a&gt; about a month after the magazine goes out. (I usually put up everything I write, but I've been distracted lately and I'm a little behind in putting stuff on the site.)&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;</content><author><name>herb-sutter</name></author><thr:total>1</thr:total></entry><entry><id>13562</id><published>2005-07-28T18:50:00.0-05:00</published><updated>2005-07-28T18:50:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">Interesting Finds</title><content type="html"></content><author><name>Anonymous</name></author><thr:in-reply-to ref="13496"></thr:in-reply-to></entry><entry><id>13797</id><published>2005-08-01T22:43:00.0-05:00</published><updated>2005-08-01T22:43:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#post"></category><title type="text">Upcoming events</title><content type="html">&lt;div&gt;Wow, August 1 already -- it's hard to believe that midsummer has arrived so soon and the fall conference season is coming up again quickly.&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt;Here are some of the places where I'll be hanging out over the next few months, and what I'll be talking about when I'm there. These events are sure to be fun, especially the InStat hardware event: See, back when I was in college at &lt;a href="http://www.cs.uwaterloo.ca/"&gt;Waterloo&lt;/a&gt;, the engineers would regularly invade our math faculty (yeah, CS was under Math, and having Math as a whole faculty is still pretty unique I think), and there they'd be, parading through our lecture hall aisles wearing hard hats and carrying their mascot while chanting engineering songs. A real disruption in second-year Calculus, let me tell you.&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt;So it makes me wonder what it'll be like to be a lonely software guy talking to a hall full (of hundreds? thousands?) of hardware engineers at FPF. I'm sure they'll be kind. Probably. But it can't hurt to be polite and smile a lot, or else they might start chanting…&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt;
&lt;table border="1" width="100%" cellpadding="4" tabindex="-1" style="TABLE-LAYOUT: fixed; WIDTH: 733px; BORDER-TOP-STYLE: none; BORDER-RIGHT-STYLE: none; BORDER-LEFT-STYLE: none; BORDER-COLLAPSE: collapse; WORD-WRAP: break-word; BORDER-BOTTOM-STYLE: none" class="msoUcTable"&gt;
&lt;colgroup&gt;
&lt;col style="WIDTH: 234px"&gt;&lt;/col&gt;
&lt;col style="WIDTH: 499px"&gt;&lt;/col&gt;&lt;/colgroup&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td bgcolor="#999999" valign="top" style="BORDER-TOP-STYLE: none; BORDER-RIGHT-STYLE: none; BORDER-LEFT-STYLE: none; BORDER-BOTTOM-STYLE: none"&gt;&lt;font color="#ffffcc"&gt;&lt;strong&gt;Where&lt;/strong&gt;&lt;/font&gt;&lt;/td&gt;
&lt;td bgcolor="#999999" valign="top" style="BORDER-TOP-STYLE: none; BORDER-RIGHT-STYLE: none; BORDER-LEFT-STYLE: none; BORDER-BOTTOM-STYLE: none"&gt;&lt;font color="#ffffcc"&gt;&lt;strong&gt;What&lt;/strong&gt;&lt;/font&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;
&lt;td valign="top" style="BORDER-TOP-STYLE: none; BORDER-RIGHT-STYLE: none; BORDER-LEFT-STYLE: none; BORDER-BOTTOM-STYLE: none"&gt;
&lt;p align="left" style="MARGIN-TOP: 0px; FONT-SIZE: 10pt"&gt;&lt;img border="0" align="right" width="69" src="http://www.gotw.ca/images/pdc05.jpg" height="28" /&gt;&lt;a target="_blank" href="http://msdn.microsoft.com/events/pdc/"&gt;&lt;strong&gt;Professional Developer's Conference 2005&lt;/strong&gt;&lt;/a&gt;&lt;br /&gt;September 11-16, 2005&lt;br /&gt;Los Angeles, California, USA&lt;/p&gt;&lt;/td&gt;
&lt;td valign="top" style="BORDER-TOP-STYLE: none; BORDER-RIGHT-STYLE: none; BORDER-LEFT-STYLE: none; BORDER-BOTTOM-STYLE: none"&gt;
&lt;p align="left" style="MARGIN-TOP: 0px; FONT-SIZE: 10pt"&gt;The Future of (Visual) C++&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;
&lt;td valign="top" style="BORDER-TOP-STYLE: none; BORDER-RIGHT-STYLE: none; BORDER-LEFT-STYLE: none; BORDER-BOTTOM-STYLE: none"&gt;
&lt;p align="left" style="MARGIN-TOP: 0px; FONT-SIZE: 10pt"&gt;&lt;img border="0" align="right" width="74" src="http://www.gotw.ca/images/instatfpf.jpg" height="53" /&gt;&lt;font color="#0000ff"&gt;&lt;a target="_blank" href="http://www.in-stat.com/fpf/05/"&gt;&lt;strong&gt;InStat Fall Processor Forum&lt;/strong&gt;&lt;/a&gt;&lt;br /&gt;&lt;/font&gt;October 24-27, 2005&lt;br /&gt;San Jose, California, USA&lt;/p&gt;&lt;/td&gt;
&lt;td valign="top" style="BORDER-TOP-STYLE: none; BORDER-RIGHT-STYLE: none; BORDER-LEFT-STYLE: none; BORDER-BOTTOM-STYLE: none"&gt;
&lt;p align="left" style="MARGIN-TOP: 0px; FONT-SIZE: 10pt"&gt;&lt;font color="#000080"&gt;Keynote: Software and the Concurrency Revolution&lt;/font&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;
&lt;td bgcolor="#ffffcc" valign="top" style="BORDER-TOP-STYLE: none; BORDER-RIGHT-STYLE: none; BORDER-LEFT-STYLE: none; BORDER-BOTTOM-STYLE: none"&gt;&lt;img border="0" align="right" width="76" src="http://www.gotw.ca/images/connections.jpg" height="41" /&gt;&lt;font size="2"&gt;&lt;a href="http://www.cpp-connections.com/"&gt;&lt;strong&gt;C++ Connections&lt;/strong&gt;&lt;/a&gt;&lt;br /&gt;&lt;/font&gt;&lt;font size="2"&gt;November 7-11, 2005&lt;br /&gt;Las Vegas, Nevada, USA&lt;/font&gt;&lt;/td&gt;
&lt;td bgcolor="#ffffcc" valign="top" style="BORDER-TOP-STYLE: none; BORDER-RIGHT-STYLE: none; BORDER-LEFT-STYLE: none; BORDER-BOTTOM-STYLE: none"&gt;
&lt;p style="MARGIN-TOP: 0px; FONT-SIZE: 10pt; MARGIN-BOTTOM: 6px"&gt;&lt;font color="#000080"&gt;My talks include:&lt;/font&gt;&lt;/p&gt;
&lt;p style="MARGIN-TOP: 0px; PADDING-LEFT: 12px; FONT-SIZE: 10pt; MARGIN-BOTTOM: 6px"&gt;&lt;font color="#000080"&gt;Keynote: The Concurrency Landscape and C++0x&lt;/font&gt;&lt;/p&gt;
&lt;p style="MARGIN-TOP: 0px; PADDING-LEFT: 12px; FONT-SIZE: 10pt; MARGIN-BOTTOM: 6px"&gt;&lt;font color="#000080"&gt;Concurrency Abstractions in C++&lt;/font&gt;&lt;/p&gt;
&lt;p style="MARGIN-TOP: 0px; PADDING-LEFT: 12px; FONT-SIZE: 10pt; MARGIN-BOTTOM: 6px"&gt;&lt;font color="#000080"&gt;Half-day tutorial: Generic Types in C++, Java, and .NET: Templates and Generics Side-By-Side (half-day session)&lt;/font&gt;&lt;/p&gt;
&lt;p style="MARGIN-TOP: 0px; FONT-SIZE: 10pt; MARGIN-BOTTOM: 6px"&gt;&lt;font color="#000080"&gt;Plus panel discussions on "The Future of C++," "20 Years of C++ and Going Strong," and more.&lt;/font&gt;&lt;/p&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt;I'm particularly excited about C++ Connections, which I'm helping to organize and which I've blogged about &lt;a href="http://pluralsight.com/blogs/hsutter/archive/2005/03/14/6714.aspx"&gt;before&lt;/a&gt; -- it's been a long time since we've had a conference exclusively about C++.&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt;I look forward to seeing many of you there.&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt; &lt;/div&gt;</content><author><name>herb-sutter</name></author></entry><entry><id>14799</id><published>2005-09-13T20:40:00.0-05:00</published><updated>2005-09-13T20:40:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#post"></category><title type="text">New November article</title><content type="html">&lt;div&gt;I got some interesting mail, so I wrote an article -- hopefully the article is interesting, too. Here's the info and a descriptive blurb:&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div style="PADDING-LEFT: 50px"&gt;&lt;strong&gt;Pointers and Iterators: Off the Deep End&lt;br /&gt;&lt;/strong&gt;&lt;em&gt;(C/C++ Users Journal, 23(11), November 2005).&lt;/em&gt;&lt;/div&gt;
&lt;div style="PADDING-LEFT: 50px"&gt; &lt;/div&gt;
&lt;div style="PADDING-LEFT: 50px"&gt;Don’t even create invalid pointers or iterators; they are undefined and nonportable. Do get a checked STL, turn all the checking on, and use it daily and automatically at least in test builds. You’ll be glad you did.&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt;For a good rant on why to use a checked STL, see also Item 83 of &lt;a href="http://www.gotw.ca/publications/c++cs.htm"&gt;C++ Coding Standards&lt;/a&gt;.&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;

&lt;div&gt; &lt;/div&gt;
&lt;div&gt; &lt;/div&gt;</content><author><name>herb-sutter</name></author></entry><entry><id>14970</id><published>2005-09-22T11:00:00.0-05:00</published><updated>2005-09-22T11:00:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#post"></category><title type="text">C++/CLI is done!</title><content type="html">&lt;div&gt;In December 2003, a new &lt;a href="http://www.ecma-international.org/"&gt;Ecma&lt;/a&gt; committee called TC39/TG5 started work to standardize C++/CLI, a binding between the ISO C++ programming language and the ISO CLI runtime environment. &lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt;On Tuesday, after 11 face-to-face meetings and dozens of teleconference calls, TG5 finished its most recent meeting by voting unanimously to request that TC39 adopt the language specification and submit it to the Ecma general assembly for approval. If approved, C++/CLI will become an Ecma international standard later this year. Following that, the Ecma general assembly would submit it to ISO for consideration as a potential ISO standard.&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt;A little editorial work remains to incorporate edits and clarifications to the text that were approved by TG5 this week, and then the final document will be submitted to TC39 on October 11 and should be publicly available by the end of the year.&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt;At this point I would like to reiterate my own personal thanks to &lt;a href="http://www.research.att.com/~bs/"&gt;Bjarne Stroustrup&lt;/a&gt; for his gracious and insightful comments and suggestions that have improved C++/CLI in both the broad design and the little details, and also to &lt;a href="http://www.dinkumware.com"&gt;Dinkumware&lt;/a&gt;, &lt;a href="http://www.edg.com"&gt;Edison Design Group (EDG)&lt;/a&gt;, &lt;a href="http://www.plumhall.com"&gt;Plum Hall&lt;/a&gt;, &lt;a href="http://www.ibm.com"&gt;IBM&lt;/a&gt;, and the other participants who likewise helped make C++/CLI as good as it is, both before and during the Ecma standards process. Thanks again, everyone!&lt;/div&gt;
&lt;div&gt;&lt;br /&gt; &lt;/div&gt;</content><author><name>herb-sutter</name></author><thr:total>2</thr:total></entry><entry><id>14984</id><published>2005-09-22T14:49:00.0-05:00</published><updated>2005-09-22T14:49:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">il mito Herb Sutter dice che C  /CLI e' uno standard</title><content type="html"></content><author><name>Anonymous</name></author><thr:in-reply-to ref="14970"></thr:in-reply-to></entry><entry><id>32748</id><published>2006-08-01T06:28:00.0-05:00</published><updated>2006-08-01T06:28:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">C  /CLI标准化工作告一段落！[原文发表时间：2005年9月22日]</title><content type="html">C  /CLI?????????,Sutter??ISO C  ???????,????????????????????</content><author><name>Anonymous</name></author><thr:in-reply-to ref="14970"></thr:in-reply-to></entry><entry><id>15903</id><published>2005-10-25T22:59:00.0-05:00</published><updated>2005-10-25T22:59:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#post"></category><title type="text">PDC talk on concurrency now online for viewing</title><content type="html">&lt;div&gt;&lt;font face="Arial, Arial, Helvetica"&gt;The talk I gave at last month's PDC event is &lt;a href="http://microsoft.sitestream.com/PDC05/TLN/TLN309_files/Default.htm#nopreload=1&amp;amp;autostart=1"&gt;now online&lt;/a&gt;.&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Arial, Arial, Helvetica"&gt;&lt;/font&gt; &lt;/div&gt;
&lt;div&gt;&lt;font face="Arial, Arial, Helvetica"&gt;This is the first public talk I've given about my (con)current project, suitably named Concur. This is just a very brief overview and a snapshot of current thinking; expect to hear more over the coming year or two.&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Arial, Arial, Helvetica"&gt;&lt;/font&gt; &lt;/div&gt;
&lt;div&gt;&lt;font face="Arial, Arial, Helvetica"&gt;This talk starts with a brief introduction covers the themes of future versions of Visual C++ and the next ISO C++ standard, and then I spend a few minutes discussing four key language features that are directly applicable to a broad range of uses, from C++/CLI to ISO C++0x to Linq to concurrency -- the four features are "for each", "auto" type declarations, lambda functions and expressions, and the draft C++0x "concepts" feature.&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;&lt;font face="Arial, Arial, Helvetica"&gt;&lt;/font&gt; &lt;/div&gt;
&lt;div&gt;&lt;font face="Arial, Arial, Helvetica"&gt;The bulk of the talk then gives an overview of the Concur project, which aims to:&lt;/font&gt;&lt;/div&gt;
&lt;ul type="disc" style="MARGIN-TOP: 0px; MARGIN-BOTTOM: 0px"&gt;
&lt;li&gt;define higher-level abstractions (above "threads and locks") &lt;/li&gt;
&lt;li&gt;for today’s imperative languages (examples are in C++) &lt;/li&gt;
&lt;li&gt;that evenly support the range of concurrency granularities &lt;/li&gt;
&lt;li&gt;to let developers write correct and efficient concurrent applications &lt;/li&gt;
&lt;li&gt;with lots of latent parallelism (and not lots of latent bugs) &lt;/li&gt;
&lt;li&gt;that can be efficiently mapped to the user’s hardware to reenable the free lunch. &lt;/li&gt;&lt;/ul&gt;&lt;!--mstheme--&gt;&lt;!--msthemelist--&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt;There's more to Concur than I had time to show here, but this is a good appetizer. Enjoy!&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt; &lt;/div&gt;</content><author><name>herb-sutter</name></author></entry><entry><id>15919</id><published>2005-10-27T12:44:00.0-05:00</published><updated>2005-10-27T12:44:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#post"></category><title type="text">September ACM Queue concurrency article now available online</title><content type="html">&lt;div&gt;&lt;a href="http://pluralsight.com/blogs/hsutter/archive/2005/07/25.aspx"&gt;Back in the summer&lt;/a&gt;, I mentioned this article was coming. It's now available online:&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div style="MARGIN-TOP: 0pt; PADDING-LEFT: 50px; MARGIN-BOTTOM: 6pt"&gt;&lt;font size="2"&gt;&lt;a href="http://acmqueue.com/modules.php?name=Content&amp;amp;pa=showpage&amp;amp;pid=332"&gt;&lt;font color="#0000ff"&gt;&lt;strong&gt;Software and the Concurrency Revolution&lt;/strong&gt;&lt;/font&gt;&lt;/a&gt; (with Jim Larus), &lt;br /&gt;&lt;font color="#000080"&gt;&lt;em&gt;ACM Queue&lt;/em&gt;, September 2005.&lt;/font&gt;&lt;br /&gt;The concurrency revolution is primarily a software revolution. Soon all new machines will be multicore, and the difficult problem is programming this hardware so that mainstream applications benefit from the continued exponential growth in CPU performance.&lt;/font&gt;&lt;/div&gt;
&lt;div&gt;Note: If you haven't read &lt;a href="http://www.gotw.ca/publications/concurrency-ddj.htm"&gt;The Free Lunch Is Over&lt;/a&gt; yet, I strongly suggest reading that first; it's the paper that originally coined the terms "the free lunch is over" and "concurrency revolution." Then, if you're interested in the topic (and you should be), &lt;a href="http://www.google.com/search?hl=en&amp;amp;q=%22the+free+lunch+is+over%22&amp;amp;btnG=Google+Search"&gt;Google for the title&lt;/a&gt; to browse the commentary that it has engendered (disclaimer: I don't necessarily agree with all the commentary, but most of it is reasonable).&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt;I just spoke on this topic yesterday at the &lt;a href="http://www.in-stat.com/fpf/05/"&gt;In-Stat Fall Processor Forum&lt;/a&gt;, and I'll have quite a bit more to say about this at &lt;a href="http://www.cpp-connections.com"&gt;C++ Connections&lt;/a&gt; in a couple of weeks where I'm giving a keynote and a regular talk on the concurrency revolution and my Concur project, respectively. (If you haven't registered for C++ Connections yet, this is almost your last chance -- run, don't walk. It's going to be a very cool event.)&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt;By the way, all of the above papers and talks are listed on my &lt;a href="http://www.gotw.ca"&gt;home page&lt;/a&gt;. I revamped it a couple of months ago to put everything essential up front, from new talks and articles to links to recent talks that are now available online (with video, even). It seemed like it would be easier to use this way than the old way, which forced you to dig into News and other pages to get at everything. I hope you find it useful.&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt; &lt;/div&gt;</content><author><name>herb-sutter</name></author><thr:total>1</thr:total></entry><entry><id>15932</id><published>2005-10-28T07:19:00.0-05:00</published><updated>2005-10-28T07:19:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">Interesting Finds</title><content type="html"></content><author><name>Anonymous</name></author><thr:in-reply-to ref="15919"></thr:in-reply-to></entry><entry><id>17588</id><published>2005-12-21T19:09:00.0-05:00</published><updated>2005-12-21T19:09:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#post"></category><title type="text">Coming in March: Stroustrup &amp;amp;amp; Sutter on C++</title><content type="html">&lt;div&gt;In spring 2004, Bjarne and I had a blast doing &lt;a href="http://www.gotw.ca/sands.htm"&gt;our first S&amp;amp;S event together&lt;/a&gt;. So much fun, in fact, that we've decided to do it again!&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt;I'm happy to announce that we're doing it again in 2006. Here's the event info:&lt;/div&gt;&lt;div&gt; &lt;/div&gt;
&lt;div style="PADDING-LEFT: 50px"&gt;&lt;strong&gt;&lt;a href="http://www.gotw.ca/sands2.htm"&gt;Stroustrup &amp;amp; Sutter on C++&lt;/a&gt;&lt;br /&gt;&lt;/strong&gt;March 13-14, 2006&lt;br /&gt;Santa Clara, California, USA&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt;My talks include:&lt;/div&gt;
&lt;ul type="disc" style="MARGIN-TOP: 0px; MARGIN-BOTTOM: 0px"&gt;
&lt;li&gt;The New ISO C++ Libraries&lt;/li&gt;
&lt;li&gt;The Concurrency Landscape, C++0x, and the Concur Project&lt;/li&gt;
&lt;li&gt;Genericity in C++, .NET, and Java&lt;/li&gt;
&lt;li&gt;Error-Safe C++: More Than Just Exception Safety&lt;br /&gt;&lt;/li&gt;&lt;/ul&gt;
&lt;div&gt;See the page for the full details. We hope to see you in Santa Clara this spring!&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt; &lt;/div&gt;</content><author><name>herb-sutter</name></author><thr:total>3</thr:total></entry><entry><id>17589</id><published>2005-12-21T17:29:00.0-05:00</published><updated>2005-12-21T17:29:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">Per gli amanti del C  : Stroustrup </title><content type="html"></content><author><name>Anonymous</name></author><thr:in-reply-to ref="17588"></thr:in-reply-to></entry><entry><id>18250</id><published>2006-01-24T17:14:00.0-05:00</published><updated>2006-01-24T17:14:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">Some talks this spring: Bay area, Oxford, Paris(?), Nice</title><content type="html"></content><author><name>Anonymous</name></author><thr:in-reply-to ref="17588"></thr:in-reply-to></entry><entry><id>45404</id><published>2006-12-21T10:38:00.0-05:00</published><updated>2006-12-21T10:38:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">Some talks this spring: Bay area, Oxford, Paris(?), Nice</title><content type="html"></content><author><name>Anonymous</name></author><thr:in-reply-to ref="17588"></thr:in-reply-to></entry><entry><id>18249</id><published>2006-01-24T20:11:00.0-05:00</published><updated>2006-01-24T20:11:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#post"></category><title type="text">Some talks this spring: Bay area, Oxford, Paris(?), Nice</title><content type="html">&lt;div&gt;As I look at my calendar, I see it's going to be a busy spring. For one thing, the spring 2006 ISO C++ standards meeting will be held in Berlin, Germany, from April 2-7, 2006. For another, I'll be attending several events in California and Europe. &lt;/div&gt;
&lt;div align="left"&gt; &lt;/div&gt;
&lt;div&gt;I've &lt;a href="http://pluralsight.com/blogs/hsutter/archive/2005/12/21/17588.aspx"&gt;already announced&lt;/a&gt; the first event in this list, but since then I've accepted a few more talks, and here's the current list:&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt;
&lt;table border="1" cellpadding="4" tabindex="-1" style="TABLE-LAYOUT: fixed; WIDTH: 662px; BORDER-TOP-STYLE: none; BORDER-RIGHT-STYLE: none; BORDER-LEFT-STYLE: none; BORDER-COLLAPSE: collapse; WORD-WRAP: break-word; BORDER-BOTTOM-STYLE: none" class="msoUcTable"&gt;
&lt;colgroup&gt;
&lt;col style="WIDTH: 239px"&gt;&lt;/col&gt;
&lt;col style="WIDTH: 423px"&gt;&lt;/col&gt;&lt;/colgroup&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td bgcolor="#ffffcc" valign="top" style="BORDER-TOP-STYLE: none; BORDER-RIGHT-STYLE: none; BORDER-LEFT-STYLE: none; BORDER-BOTTOM-STYLE: none"&gt;&lt;font size="2"&gt;&lt;a href="http://www.GotW.ca/sands2.htm"&gt;&lt;font color="#0000ff"&gt;&lt;strong&gt;Stroustrup &amp;amp; Sutter on C++&lt;/strong&gt;&lt;/font&gt;&lt;/a&gt;&lt;font color="#0000ff"&gt;&lt;br /&gt;&lt;/font&gt;&lt;/font&gt;&lt;font size="2"&gt;March 13-14, 2006&lt;br /&gt;Santa Clara, California, USA&lt;/font&gt;&lt;/td&gt;
&lt;td bgcolor="#ffffcc" valign="top" style="BORDER-TOP-STYLE: none; BORDER-RIGHT-STYLE: none; BORDER-LEFT-STYLE: none; BORDER-BOTTOM-STYLE: none"&gt;
&lt;div style="MARGIN-TOP: 0px; FONT-SIZE: 10pt; MARGIN-BOTTOM: 6px"&gt;Herb's talks include:&lt;/div&gt;
&lt;div style="MARGIN-TOP: 0px; PADDING-LEFT: 12px; FONT-SIZE: 10pt; MARGIN-BOTTOM: 6px"&gt;The New ISO C++ Libraries&lt;/div&gt;
&lt;div style="MARGIN-TOP: 0px; PADDING-LEFT: 12px; FONT-SIZE: 10pt; MARGIN-BOTTOM: 6px"&gt;The Concurrency Landscape, C++0x, and the Concur Project&lt;/div&gt;
&lt;div style="MARGIN-TOP: 0px; PADDING-LEFT: 12px; FONT-SIZE: 10pt; MARGIN-BOTTOM: 6px"&gt;Genericity in C++, .NET, and Java&lt;/div&gt;
&lt;div style="MARGIN-TOP: 0px; PADDING-LEFT: 12px; FONT-SIZE: 10pt; MARGIN-BOTTOM: 6px"&gt;Error-Safe C++: More Than Just Exception Safety&lt;/div&gt;
&lt;div style="MARGIN-TOP: 0px; FONT-SIZE: 10pt; MARGIN-BOTTOM: 6px"&gt;Plus panel discussions, including "ask us anything!".&lt;br /&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;div&gt;
&lt;table border="1" width="undefined" cellpadding="4" tabindex="-1" style="TABLE-LAYOUT: fixed; WIDTH: 662px; BORDER-TOP-STYLE: none; BORDER-RIGHT-STYLE: none; BORDER-LEFT-STYLE: none; BORDER-COLLAPSE: collapse; WORD-WRAP: break-word; BORDER-BOTTOM-STYLE: none" class="msoUcTable"&gt;
&lt;colgroup&gt;
&lt;col style="WIDTH: 239px"&gt;&lt;/col&gt;
&lt;col style="WIDTH: 423px"&gt;&lt;/col&gt;&lt;/colgroup&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td valign="top" style="BORDER-TOP-STYLE: none; BORDER-RIGHT-STYLE: none; BORDER-LEFT-STYLE: none; BORDER-BOTTOM-STYLE: none"&gt;
&lt;div align="left" style="MARGIN-TOP: 0px; FONT-SIZE: 10pt"&gt;&lt;a href="http://www.parc.com/events/forum"&gt;&lt;font color="#0000ff"&gt;&lt;strong&gt;Xerox PARC Forum&lt;/strong&gt;&lt;/font&gt;&lt;/a&gt;&lt;br /&gt;March 15, 2006&lt;br /&gt;Palo Alto, California, USA&lt;br /&gt;&lt;/div&gt;&lt;/td&gt;
&lt;td valign="top" style="BORDER-TOP-STYLE: none; BORDER-RIGHT-STYLE: none; BORDER-LEFT-STYLE: none; BORDER-BOTTOM-STYLE: none"&gt;
&lt;div align="left" style="MARGIN-TOP: 0px; FONT-SIZE: 10pt"&gt;Software Directions in the Concurrency Revolution&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;div&gt;
&lt;table border="1" width="undefined" cellpadding="4" tabindex="-1" style="TABLE-LAYOUT: fixed; WIDTH: 662px; BORDER-TOP-STYLE: none; BORDER-RIGHT-STYLE: none; BORDER-LEFT-STYLE: none; BORDER-COLLAPSE: collapse; WORD-WRAP: break-word; BORDER-BOTTOM-STYLE: none" class="msoUcTable"&gt;
&lt;colgroup&gt;
&lt;col style="WIDTH: 239px"&gt;&lt;/col&gt;
&lt;col style="WIDTH: 423px"&gt;&lt;/col&gt;&lt;/colgroup&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td valign="top" style="BORDER-TOP-STYLE: none; BORDER-RIGHT-STYLE: none; BORDER-LEFT-STYLE: none; BORDER-BOTTOM-STYLE: none"&gt;
&lt;div align="left" style="MARGIN-TOP: 0px; FONT-SIZE: 10pt"&gt;&lt;a href="http://www.accu.org/conference"&gt;&lt;font color="#0000ff"&gt;&lt;strong&gt;ACCU 2006&lt;/strong&gt;&lt;/font&gt;&lt;/a&gt;&lt;br /&gt;April 21, 2006&lt;br /&gt;Oxford, United Kingdom&lt;br /&gt;&lt;/div&gt;&lt;/td&gt;
&lt;td valign="top" style="BORDER-TOP-STYLE: none; BORDER-RIGHT-STYLE: none; BORDER-LEFT-STYLE: none; BORDER-BOTTOM-STYLE: none"&gt;
&lt;div align="left" style="MARGIN-TOP: 0px; FONT-SIZE: 10pt; MARGIN-BOTTOM: 6pt"&gt;Keynote: C++0x, Concur, and the Concurrency Revolution&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;div&gt;
&lt;table border="1" width="undefined" cellpadding="4" tabindex="-1" style="TABLE-LAYOUT: fixed; WIDTH: 662px; BORDER-TOP-STYLE: none; BORDER-RIGHT-STYLE: none; BORDER-LEFT-STYLE: none; BORDER-COLLAPSE: collapse; WORD-WRAP: break-word; BORDER-BOTTOM-STYLE: none" class="msoUcTable"&gt;
&lt;colgroup&gt;
&lt;col style="WIDTH: 239px"&gt;&lt;/col&gt;
&lt;col style="WIDTH: 423px"&gt;&lt;/col&gt;&lt;/colgroup&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td valign="top" style="BORDER-TOP-STYLE: none; BORDER-RIGHT-STYLE: none; BORDER-LEFT-STYLE: none; BORDER-BOTTOM-STYLE: none"&gt;
&lt;div align="left" style="MARGIN-TOP: 0px; FONT-SIZE: 10pt"&gt;&lt;strong&gt;&lt;a href="http://www.devconnectionseurope.com/"&gt;&lt;font color="#0000ff"&gt;DevConnections Europe&lt;/font&gt;&lt;/a&gt;&lt;br /&gt;&lt;/strong&gt;April 25, 2006&lt;br /&gt;Nice, France&lt;br /&gt;&lt;/div&gt;&lt;/td&gt;
&lt;td valign="top" style="BORDER-TOP-STYLE: none; BORDER-RIGHT-STYLE: none; BORDER-LEFT-STYLE: none; BORDER-BOTTOM-STYLE: none"&gt;
&lt;div align="left" style="MARGIN-TOP: 0px; FONT-SIZE: 10pt; MARGIN-BOTTOM: 6pt"&gt;Concurrency Abstractions in C++&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
&lt;div&gt;In addition to the above, there might be one more: Some folks in France are trying to arrange for me to give a couple of talks in Paris on Monday, April 24. I'll post more details as/if this gets confirmed -- in the meantime, if you're in the Paris area and are interested in topics about .NET programming (C++/CLI) and/or concurrency (Concur), keep April 24 open and watch this space.&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt;I look forward to seeing you in California and/or Europe!&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt; &lt;/div&gt;</content><author><name>herb-sutter</name></author><thr:total>1</thr:total></entry><entry><id>20759</id><published>2006-03-25T09:33:00.0-05:00</published><updated>2006-03-25T09:33:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">D</title><content type="html"></content><author><name>Anonymous</name></author><thr:in-reply-to ref="18249"></thr:in-reply-to></entry><entry><id>18911</id><published>2006-02-18T22:56:00.0-05:00</published><updated>2006-02-18T22:56:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#post"></category><title type="text">A Design Rationale for C++/CLI</title><content type="html">&lt;div&gt;I thought I should finally get around to writing a design rationale for C++/CLI, to pull together in one place some accurate information about the whats, whys, and hows of these extensions. You can find it at:&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt;  A Design Rationale for C++/CLI&lt;br /&gt;  &lt;a href="http://www.gotw.ca/publications/C++CLIRationale.pdf"&gt;http://www.gotw.ca/publications/C++CLIRationale.pdf&lt;/a&gt;&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt;I've pasted the Preface below. The paper also includes a FAQ covering some common points of interest about C++/CLI. I expect it to be a living document; this is version 1.0.&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt;Enjoy,&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt;Herb&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;h1 style="PADDING-RIGHT: 0in; MARGIN-TOP: 24pt; PADDING-LEFT: 0in; FONT-WEIGHT: normal; FONT-SIZE: 16pt; MARGIN-BOTTOM: 3pt; TEXT-INDENT: 0in"&gt;&lt;strong&gt;Preface&lt;/strong&gt;&lt;/h1&gt;
&lt;div align="justify" style="PADDING-RIGHT: 0.5in; MARGIN-TOP: 0in; PADDING-LEFT: 0.5in; FONT-SIZE: 10pt; MARGIN-BOTTOM: 3pt; LINE-HEIGHT: 13pt"&gt;&lt;font color="#000080"&gt;&lt;em&gt;A multiplicity of libraries, run-time environments, and development environments are essential to support the range of C++ applications. This view guided the design of C++ as early as 1987; in fact, it is older yet. Its roots are in the view of C++ as a general-purpose language&lt;/em&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div align="justify" style="PADDING-RIGHT: 0.5in; MARGIN-TOP: 0in; PADDING-LEFT: 0.5in; FONT-SIZE: 10pt; MARGIN-BOTTOM: 9pt; LINE-HEIGHT: 13pt"&gt;&lt;font color="#000080"&gt;&lt;em&gt;                                                                 — B. Stroustrup (D&amp;amp;E, p. 168)&lt;/em&gt;&lt;/font&gt;&lt;/div&gt;
&lt;div align="justify" style="PADDING-RIGHT: 0in; MARGIN-TOP: 0in; PADDING-LEFT: 0in; FONT-SIZE: 10pt; MARGIN-BOTTOM: 6pt; LINE-HEIGHT: 13pt"&gt;C++/CLI was created to promote C++ use on a major platform, ISO CLI (the standardized subset of .NET). This paper attempts to capture a small but representative sample of the experience gained by a succession of C++ experts who have tried to define a binding between C++ and CLI. A central goal is to explain why pure library extensions are technically insufficient in the cases where they were not used, by considering design alternatives for representative examples that cover most CLI feature areas:&lt;/div&gt;
&lt;div align="justify" style="PADDING-RIGHT: 0in; MARGIN-TOP: 0in; PADDING-LEFT: 27.35pt; FONT-SIZE: 10pt; MARGIN-BOTTOM: 3pt; TEXT-INDENT: -0.2in; LINE-HEIGHT: 13pt"&gt;&lt;strong&gt;CLI types (e.g., ref class, value class):&lt;/strong&gt; Why new type categories are needed, and considerations for choosing the right defaults for CLI types.&lt;/div&gt;
&lt;div align="justify" style="PADDING-RIGHT: 0in; MARGIN-TOP: 0in; PADDING-LEFT: 27.35pt; FONT-SIZE: 10pt; MARGIN-BOTTOM: 3pt; TEXT-INDENT: -0.2in; LINE-HEIGHT: 13pt"&gt;&lt;strong&gt;CLI type features (e.g., property):&lt;/strong&gt; Why new abstractions are needed for some CLI features.&lt;/div&gt;
&lt;div align="justify" style="PADDING-RIGHT: 0in; MARGIN-TOP: 0in; PADDING-LEFT: 27.35pt; FONT-SIZE: 10pt; MARGIN-BOTTOM: 3pt; TEXT-INDENT: -0.2in; LINE-HEIGHT: 13pt"&gt;&lt;strong&gt;CLI heap (e.g., ^, gcnew):&lt;/strong&gt; Why not to reuse the existing * pointer declarator and new.&lt;/div&gt;
&lt;div align="justify" style="PADDING-RIGHT: 0in; MARGIN-TOP: 0in; PADDING-LEFT: 27.35pt; FONT-SIZE: 10pt; MARGIN-BOTTOM: 3pt; TEXT-INDENT: -0.2in; LINE-HEIGHT: 13pt"&gt;&lt;strong&gt;CLI generics (generic):&lt;/strong&gt; Why the new genericity feature is distinct from templates, but compatible and highly integrated with templates.&lt;/div&gt;
&lt;div align="justify" style="PADDING-RIGHT: 0in; MARGIN-TOP: 0in; PADDING-LEFT: 27.35pt; FONT-SIZE: 10pt; MARGIN-BOTTOM: 6pt; TEXT-INDENT: -0.2in; LINE-HEIGHT: 13pt"&gt;&lt;strong&gt;CLI non-features (e.g., template, const):&lt;/strong&gt; Why and how these are made to work on CLI types.&lt;/div&gt;
&lt;div align="justify" style="PADDING-RIGHT: 0in; MARGIN-TOP: 0in; PADDING-LEFT: 0in; FONT-SIZE: 10pt; MARGIN-BOTTOM: 6pt; LINE-HEIGHT: 13pt"&gt;For each case, the paper describes:&lt;/div&gt;
&lt;div align="justify" style="PADDING-RIGHT: 0in; MARGIN-TOP: 0in; PADDING-LEFT: 27.35pt; FONT-SIZE: 10pt; MARGIN-BOTTOM: 3pt; TEXT-INDENT: -0.2in; LINE-HEIGHT: 13pt"&gt;The CLI feature and basic requirements, including representative metadata that must be generated.&lt;/div&gt;
&lt;div align="justify" style="PADDING-RIGHT: 0in; MARGIN-TOP: 0in; PADDING-LEFT: 27.35pt; FONT-SIZE: 10pt; MARGIN-BOTTOM: 3pt; TEXT-INDENT: -0.2in; LINE-HEIGHT: 13pt"&gt;The lower-impact Managed Extensions design, and where it was insufficient.&lt;/div&gt;
&lt;div align="justify" style="PADDING-RIGHT: 0in; MARGIN-TOP: 0in; PADDING-LEFT: 27.35pt; FONT-SIZE: 10pt; MARGIN-BOTTOM: 3pt; TEXT-INDENT: -0.2in; LINE-HEIGHT: 13pt"&gt;The C++/CLI design and rationale.&lt;/div&gt;
&lt;div align="justify" style="PADDING-RIGHT: 0in; MARGIN-TOP: 0in; PADDING-LEFT: 27.35pt; FONT-SIZE: 10pt; MARGIN-BOTTOM: 6pt; TEXT-INDENT: -0.2in; LINE-HEIGHT: 13pt"&gt;Other major design choices that were considered, both in earlier iterations of C++/CLI and in other separate design efforts that didn’t work out and were never publicly available.&lt;/div&gt;
&lt;div&gt;&lt;span style="FONT-SIZE: 10pt"&gt;Finally, note that most of the C++/CLI extensions are needed only when using C++/CLI to &lt;em&gt;author&lt;/em&gt; new CLI types and libraries. In practice, many programmers using a C++/CLI-enabled compiler (currently Visual C++ 2005) are simply taking advantage of the ability to seamlessly &lt;em&gt;use&lt;/em&gt; existing CLI types with their C++ code, which typically requires no extended syntax at all beyond a sprinkling of &lt;/span&gt;&lt;span style="FONT-SIZE: 10pt"&gt;gcnew&lt;/span&gt;&lt;span style="FONT-SIZE: 10pt"&gt; and &lt;/span&gt;&lt;span style="FONT-SIZE: 10pt"&gt;^&lt;/span&gt;&lt;span style="FONT-SIZE: 10pt"&gt;.&lt;/span&gt;&lt;br /&gt; &lt;/div&gt;</content><author><name>herb-sutter</name></author></entry><entry><id>19271</id><published>2006-02-27T21:02:00.0-05:00</published><updated>2006-02-27T21:02:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#post"></category><title type="text">A Design Rationale for C++/CLI, v 1.1</title><content type="html">&lt;font size="2"&gt;
&lt;/font&gt;&lt;div&gt;FYI, I've posted a "1.1" minor update of my C++/CLI design rationale paper. It's at the &lt;a href="http://www.gotw.ca/publications/C++CLIRationale.pdf"&gt;same location&lt;/a&gt;. The main change from the "1.0" version I posted two weeks ago is that the preface and section 1 have been merged and made clearer (realizing that some people won't read past that part). The rest includes minor enhancements such as filling in a few missing details for some of the points discussed. Enjoy,&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt;Herb&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt; &lt;/div&gt;</content><author><name>herb-sutter</name></author><thr:total>1</thr:total></entry><entry><id>19320</id><published>2006-02-28T09:07:00.0-05:00</published><updated>2006-02-28T09:07:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">A Design Rationale for C  /CLI, v 1.1</title><content type="html"></content><author><name>Anonymous</name></author><thr:in-reply-to ref="19271"></thr:in-reply-to></entry><entry><id>20167</id><published>2006-03-16T23:49:00.0-05:00</published><updated>2006-03-16T23:49:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#post"></category><title type="text">Yesterday's PARC talk now online: Software and the Concurrency Revolution</title><content type="html">&lt;div&gt;Yesterday I gave a talk at the Xerox PARC Forum about "Software and the Concurrency Revolution." Just 24 hours later, the &lt;a href="http://www.parc.com/cms/get_article.php?id=533"&gt;video and audio streams are online here&lt;/a&gt;. Now that's service!&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt;If you weren't in the area or able to drop by, you can take it in online. I hope you enjoy the talk.&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt;Note to those who've seen concurrency talks from me before: There is interesting and useful new stuff here. In particular, check out the midway point of the talk, which contains material I've never given publicly before about how to categorize and think about forms of concurrency (thanks to David Callahan for lending me these three slides). For those who haven't seen a Concur talk from me yet in 2006, the part about parallel STL algorithms near the end will also be new since it reflects thinking I did over the winter.&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt;Enjoy,&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt;Herb&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt; &lt;/div&gt;</content><author><name>herb-sutter</name></author><thr:total>3</thr:total></entry><entry><id>20260</id><published>2006-03-19T14:00:00.0-05:00</published><updated>2006-03-19T14:00:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">Slides for PARC talk on concurrency</title><content type="html"></content><author><name>Anonymous</name></author><thr:in-reply-to ref="20167"></thr:in-reply-to></entry><entry><id>20261</id><published>2006-03-19T14:02:00.0-05:00</published><updated>2006-03-19T14:02:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">Slides for PARC talk on concurrency</title><content type="html"></content><author><name>Anonymous</name></author><thr:in-reply-to ref="20167"></thr:in-reply-to></entry><entry><id>20565</id><published>2006-03-23T06:13:00.0-05:00</published><updated>2006-03-23T06:13:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">Herb Sutter on Concurrency</title><content type="html">The Free Lunch Is Over: A Fundamental Turn Toward Concurrency in Software. This is a must-read if you're a software developer or into computer science. There's also a great talk (for your podcasting pleasure) by Herb Sutter on this very...</content><author><name>Anonymous</name></author><thr:in-reply-to ref="20167"></thr:in-reply-to></entry><entry><id>20259</id><published>2006-03-19T16:56:00.0-05:00</published><updated>2006-03-19T16:56:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#post"></category><title type="text">Slides for PARC talk on concurrency</title><content type="html">&lt;div&gt;As &lt;a href="http://pluralsight.com/blogs/hsutter/archive/2006/03/16/20167.aspx"&gt;previously blogged&lt;/a&gt;, this week I gave a &lt;a href="http://www.parc.com/cms/get_article.php?id=533"&gt;PARC Form talk&lt;/a&gt; on concurrency (&lt;a href="mms://216.93.180.194/parc_forum/v1130.wmv"&gt;wmv video&lt;/a&gt;) (&lt;a href="http://www.parc.com/events/forum/media/v1130.mp3"&gt;mp3 audio&lt;/a&gt;).&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt;A number of people have asked that I post the slides, so I've put them online too (&lt;a href="http://gotw.ca/publications/SoftwareAndConcurrencyPARC.pdf"&gt;pdf slides&lt;/a&gt;).&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt;I've also updated my &lt;a href="http://www.gotw.ca"&gt;home page&lt;/a&gt; and &lt;a href="http://www.gotw.ca/presentations.htm"&gt;talks page&lt;/a&gt; with these links.&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt;Enjoy!&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt;Herb&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt; &lt;/div&gt;</content><author><name>herb-sutter</name></author><thr:total>1</thr:total></entry><entry><id>20566</id><published>2006-03-23T06:13:00.0-05:00</published><updated>2006-03-23T06:13:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">Herb Sutter on Concurrency</title><content type="html">The Free Lunch Is Over: A Fundamental Turn Toward Concurrency in Software. This is a must-read if you're a software developer or into computer science. There's also a great talk (for your podcasting pleasure) by Herb Sutter on this very...</content><author><name>Anonymous</name></author><thr:in-reply-to ref="20259"></thr:in-reply-to></entry><entry><id>22936</id><published>2006-05-03T19:19:00.0-05:00</published><updated>2006-05-03T19:19:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#post"></category><title type="text">Highlights of the April 2006 ISO C++ meeting</title><content type="html">&lt;div&gt;The ISO C++ committee met in Berlin from April 2-7, 2006. I thought I'd write a quick note about highlights of what was decided for C++0x:&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt;&lt;strong&gt;How to get meeting minutes&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt;First, how to find out for yourself: The minutes of each meeting are usually available online about 2-3 weeks after the meeting. The easiest way to find WG21 minutes for a given meeting/year is to Google for "wg21 &amp;lt;year&amp;gt; minutes," in this case "wg21 2006 minutes." One of the first results is:&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt;  Minutes of J16 Meeting No. 42/WG21 Meeting No. 37, April 3-7, 2006&lt;br /&gt;  &lt;a href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2006/n1993.html"&gt;http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2006/n1993.html&lt;/a&gt;&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div align="left"&gt;BTW, in general, the easiest way to find any WG21 doc is to Google for "wg21 &amp;lt;doc number&amp;gt;". That's what I always do, because it's quicker than navigating my own hard drive even though I know where the doc is.&lt;/div&gt;
&lt;div align="left"&gt; &lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt;&lt;strong&gt;What got voted into the C++0x working draft&lt;/strong&gt;&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt;At this meeting, five major pieces of work got approved into the draft. That means these features can (and likely will) still get tweaked and changed until the standard is actually finalized and published, but the upshot of being voted into the working paper is that these features are "for real" -- they've been discussed and debated, consensus has been achieved on their specification, actual wording written up in standardese, and a full committee vote passed to stick the standardese into the working paper.&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt;&lt;u&gt;Nearly all of the Library Technical Report (aka TR1)&lt;/u&gt;&lt;/div&gt;
&lt;div&gt;The only part that wasn't voted in was the special mathematical functions, which are of interest principally only to heavy-duty scientists and mathematicians. The actual TR is in the process of publication, but you can find a nearly-final version on the ISO C++ committee website here: &lt;a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2005/n1836.pdf"&gt;N1836, Draft Technical Report on C++ Library Extensions&lt;/a&gt;.&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div align="left"&gt;&lt;u&gt;Auto type deduction&lt;/u&gt;&lt;/div&gt;
&lt;div align="left"&gt;This permits you to write declarations like&lt;/div&gt;
&lt;div align="left"&gt; &lt;/div&gt;
&lt;div align="left"&gt;&lt;strong&gt;  auto x = 3.1415926535;&lt;br /&gt;  auto i = container.begin();&lt;/strong&gt;&lt;/div&gt;
&lt;div align="left"&gt; &lt;/div&gt;
&lt;div align="left"&gt;where the type is deduced from the initializer. So in this case, &lt;strong&gt;x&lt;/strong&gt; has type &lt;strong&gt;double&lt;/strong&gt;, and &lt;strong&gt;i&lt;/strong&gt; has type &lt;strong&gt;map&amp;lt;string,unordered_map&amp;lt;int,tupe&amp;lt;float,string,const int&amp;gt; &amp;gt; &amp;gt;::const_iterator&lt;/strong&gt; or whatever the right type happens to be, without having to spell it out. The paper is: &lt;a href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2006/n1984.pdf"&gt;N1984, Deducing the type of variable from its initializer expression (revision 4)&lt;/a&gt;.&lt;/div&gt;
&lt;div align="left"&gt; &lt;/div&gt;
&lt;div align="left"&gt;&lt;u&gt;Delegating constructors&lt;/u&gt;&lt;/div&gt;
&lt;div align="left"&gt;This proposal was written by me and Francis Glassborow. It's a combined WG21 / C++/CLI proposal, though it was cut from the first edition of C++/CLI; if C++/CLI does add this it will follow this that WG21 has adopted (plus any future tweaks). The paper is: &lt;a href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2006/n1986.pdf"&gt;N1986, Delegating Constructors (revision 3)&lt;/a&gt;.&lt;/div&gt;
&lt;div align="left"&gt; &lt;/div&gt;
&lt;div&gt;&lt;u&gt;Right angle brackets&lt;/u&gt;&lt;/div&gt;
&lt;div&gt;This fixes a tiny but perniciously annoying and embarrassing quirk of C++, and the fix adopted by C++ is the same that C++/CLI specified. Right angle brackets have been fixed so that constructions Like&amp;lt;This&amp;lt;Nested&amp;lt;Template&lt;font color="#339966"&gt;&lt;strong&gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&lt;/strong&gt;&lt;/font&gt; will work sensibly, without having to write the closing right angle brackets with extra whitespace Like&amp;lt;You&amp;lt;Must&amp;lt;Today&lt;strong&gt;&lt;font color="#ff0000"&gt;&amp;gt;  &amp;gt;  &amp;gt;  &amp;gt; &lt;/font&gt;&lt;/strong&gt;which is annoying, embarrassing, and suspected of contributing to dental decay among 18- to 24-year-olds in northeastern Mississippi. To find out more, see the paper: &lt;a href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2005/n1757.html"&gt;N1757, Right Angle Brackets (Revision 2)&lt;/a&gt;.&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt;&lt;u&gt;Extern template&lt;/u&gt;&lt;/div&gt;
&lt;div&gt;The terse paper is: &lt;a href="http://www.open-std.org/JTC1/SC22/WG21/docs/papers/2006/n1987.htm"&gt;N1987, Adding 'extern template' (version 2)&lt;/a&gt;.&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt;&lt;br /&gt;Enjoy! And there's more to come when we meet next, in October 2006 (Portland, OR, USA).&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;
&lt;div&gt;Herb&lt;br /&gt;&lt;/div&gt;
&lt;div&gt; &lt;/div&gt;</content><author><name>herb-sutter</name></author><thr:total>2</thr:total></entry><entry><id>23259</id><published>2006-05-11T12:49:00.0-05:00</published><updated>2006-05-11T12:49:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">April 2006 ISO C   meeting </title><content type="html"></content><author><name>Anonymous</name></author><thr:in-reply-to ref="22936"></thr:in-reply-to></entry><entry><id>32721</id><published>2006-08-01T00:54:00.0-05:00</published><updated>2006-08-01T00:54:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">2006年4月度国际标准化组织C  会议纪要[原文发表时间：2006年5月3日]</title><content type="html">2006?4?????????C  ????</content><author><name>Anonymous</name></author><thr:in-reply-to ref="22936"></thr:in-reply-to></entry><entry><id>29117</id><published>2006-06-26T07:36:00.0-05:00</published><updated>2006-06-26T07:36:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#post"></category><title type="text">Current and upcoming talks</title><content type="html">As I write this I'm sitting in Vail, Colorado, at the IEEE Computer Elements Workshop. It's a room full of top-notch processor designers -- if you've heard of a piece of hardware, from AS/400 to Xenon, likely one of its designers is here in the room.

Later today I'll give a talk on the effect on software of all this parallel hardware coming at us over the next few years, as one of the (or just "the"?) lone software person in the room. Like the talk I gave at InStat (another hardware/processor conference) last fall, it's nice to see the hardware conferences inviting people from software to talk about the effects these hardware trends are having on how we have to write our code. After all, these guys are making some way-cool new chips, all right, and those chips will be even cooler if they're actually programmable!

Later this summer (August), I'll also be giving a talk like this at another parallel hardware conference (also in Colorado, as it happens), this one dedicated to "Multiprocessor System-on-a-Chip," aka MPSoC '06. See http://www.gotw.ca/ for the links. Enjoy!

Herb

</content><author><name>herb-sutter</name></author><thr:total>1</thr:total></entry><entry><id>32706</id><published>2006-07-31T08:39:00.0-05:00</published><updated>2006-07-31T08:39:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">正在和将要参加的几个报告会[原文写作时间：2006年6月26日]</title><content type="html">?????????????</content><author><name>Anonymous</name></author><thr:in-reply-to ref="29117"></thr:in-reply-to></entry><entry><id>31776</id><published>2006-07-12T08:50:00.0-05:00</published><updated>2006-07-12T08:50:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#post"></category><title type="text">New article, upcoming talks</title><content type="html">A quick update: My &lt;a href="www.gotw.ca"&gt;home page&lt;/a&gt; is now updated with a list of upcoming articles and talks. In particular:

&lt;ul&gt;
&lt;li&gt;
    &lt;b&gt;Keynote: Software and the Concurrency Revolution&lt;br /&gt;
      &lt;/b&gt;&lt;font color="#000099"&gt;August 14, 2006&lt;br /&gt;
      &lt;/font&gt;&lt;font color="#0000FF"&gt;&lt;a href="http://tima.imag.fr/mpsoc/"&gt;&lt;b&gt;
	&lt;font color="#0000FF"&gt;MPSoC '06: 6th International Forum on 
	Application-Specific Multi-Processor SoC&lt;/font&gt;&lt;/b&gt;&lt;/a&gt;&lt;/font&gt;&lt;a href="http://tima.imag.fr/mpsoc/"&gt;&lt;font color="#0000FF"&gt;&lt;b&gt; 
	[System on a Chip]&lt;/b&gt;&lt;/font&gt;&lt;/a&gt;&lt;font color="#000099"&gt;, 
	Estes Park, Colorado, USA&lt;/font&gt;
&lt;/li&gt;
&lt;li&gt;
    &lt;b&gt;The Concur Project: Some Experimental Concurrency Abstractions for Imperative 
	Languages&lt;br /&gt;
      &lt;/b&gt;&lt;font color="#000099"&gt;September 20, 2006&lt;br /&gt;
      &lt;/font&gt;&lt;a href="http://www.nwcpp.org/Meetings/2006/09.html"&gt;
	&lt;font color="#0000FF"&gt;&lt;b&gt;Northwest 
    C++ Users Group&lt;/b&gt;&lt;/font&gt;&lt;/a&gt;&lt;font color="#000099"&gt;, Bellevue, Washington, USA&lt;/font&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;b&gt;Guest Editorial: It's (Not) All Been Done&lt;/b&gt;,&lt;br /&gt;
      &lt;font color="#000080"&gt;
      &lt;i&gt;Dr. Dobb's Journal&lt;/i&gt;, 31(9), September 2006.&lt;/font&gt;&lt;br /&gt;
				This is a wonderful time to be a software 
				engineer because it's a new world again: For the first time in 
				the history of computing, mainstream computers are not von 
				Neumann machines and never will be again—they are parallel. We 
				have largely succeeded with the quest to put a computer in every 
				home and purse; now we're effectively going to put a Cray into 
				every den and pocket. That makes this is a time of enormous 
				opportunity, as usual along with a great deal of work, as our 
				industry now undertakes to do for parallel programming what we 
				have already done for generic types, objects, and garbage 
				collection.
&lt;/li&gt;
&lt;/ul&gt;

</content><author><name>herb-sutter</name></author><thr:total>1</thr:total></entry><entry><id>32707</id><published>2006-07-31T08:56:00.0-05:00</published><updated>2006-07-31T08:56:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">最近几个报告会介绍[原文写作时间：2006年7月12日]</title><content type="html">Herb Sutter??????????????,?????????</content><author><name>Anonymous</name></author><thr:in-reply-to ref="31776"></thr:in-reply-to></entry><entry><id>32840</id><published>2006-08-07T13:18:00.0-05:00</published><updated>2006-08-07T13:18:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#post"></category><title type="text">Guest ed online: It's (Not) All Been Done</title><content type="html">&lt;p&gt;I see DDJ has now posted my &lt;a href="http://ddj.com/dept/architect/191800187"&gt;guest editorial "It's (Not) All Been Done"&lt;/a&gt; that I blogged about last month.&lt;/p&gt;

&lt;p&gt;Because they have hard one-page limits on the length of the editorial in the print mag, about 25% got omitted to make it fit. So I've posted &lt;a href="http://www.gotw.ca/publications/guest-ed-200609.htm"&gt;the complete unabridged text&lt;/a&gt; on my site as well. Some of you might find it interesting to see how versions of a piece can get refitted in the production process.&lt;/p&gt;

&lt;p&gt;[humor]I suppose some people of (sniff) questionable taste and habits might even decide that the editors were right to remove the extra flab.[/humor] Seriously, it's possible I should have cut the extra anyway; authors tend to be lousy editors because we too easily fall in love with our own words. But I think it works, so I thought I'd make the slightly longer version available so you can judge for yourself.&lt;/p&gt;

&lt;p&gt;Enjoy,&lt;/p&gt;

&lt;p&gt;Herb&lt;/p&gt;
</content><author><name>herb-sutter</name></author></entry><entry><id>36710</id><published>2006-08-30T13:32:00.0-05:00</published><updated>2006-08-30T13:32:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#post"></category><title type="text">Updated (and new) September talks</title><content type="html">
&lt;p&gt;Two quick updates today: The talk I'm giving in the Seattle area has been moved by one week to September 13 (not 20 as previously posted).
&lt;/p&gt;&lt;ul&gt;
&lt;li&gt;&lt;b&gt;The Concur Project: Some Experimental Concurrency Abstractions for Imperative Languages&lt;br /&gt;&lt;/b&gt;September 13, 2006&lt;br /&gt;&lt;a href="http://www.nwcpp.org/Meetings/2006/09.html"&gt;&lt;b&gt;Northwest C++ Users Group&lt;/b&gt;&lt;/a&gt;, Redmond, Washington, USA&lt;/li&gt;&lt;/ul&gt;
&lt;p&gt;Intel has graciously invited me to speak on concurrency amid a &lt;a href="http://irbseminars.intel-research.net/"&gt;gaggle of luminaries&lt;/a&gt; in their fall seminar series. The talk coordinates are:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;b&gt;Software and the Concurrency Revolution&lt;br /&gt;&lt;/b&gt;September 25, 2006&lt;br /&gt;&lt;b&gt;&lt;a href="http://www.intel-research.net/berkeley/ViewSeminarAbstract.asp?index=601"&gt;Intel Research Programming Systems Seminar Series&lt;/a&gt;&lt;/b&gt;, Berkeley, California, USA&lt;/li&gt;&lt;/ul&gt;
&lt;p&gt;I look forward to seeing some of you at these events. If you're in town, feel free to drop by!&lt;/p&gt;
&lt;p&gt;Best wishes,&lt;/p&gt;
&lt;p&gt;Herb&lt;/p&gt;
&lt;p&gt; &lt;/p&gt;</content><author><name>herb-sutter</name></author><thr:total>1</thr:total></entry><entry><id>36718</id><published>2006-08-30T21:45:00.0-05:00</published><updated>2006-08-30T21:45:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">Interesting Finds: August 30, 2006</title><content type="html"></content><author><name>Anonymous</name></author><thr:in-reply-to ref="36710"></thr:in-reply-to></entry><entry><id>45503</id><published>2006-12-29T15:55:00.0-05:00</published><updated>2006-12-29T15:55:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#post"></category><title type="text">This blog has moved to Live Spaces --&amp;amp;gt; herbsutter.spaces.live.com</title><content type="html">&lt;p&gt;It's time for me to take the plunge: Microsoft seems to have a reasonable blog hosting facility now at &lt;a href="http://spaces.live.com"&gt;Live Spaces&lt;/a&gt;, so I'm going to take the plunge and move over to &lt;a href="http://herbsutter.spaces.live.com"&gt;my new Live Spaces blog&lt;/a&gt; (&lt;a href="http://herbsutter.spaces.live.com"&gt;http://herbsutter.spaces.live.com&lt;/a&gt;). You'll find two posts there already, one an Op/Ed piece about the &lt;a href="http://herbsutter.spaces.live.com/?_c11_BlogPart_blogpart=blogview&amp;amp;_c=BlogPart&amp;amp;partqs=cat%3dOpinion%2b%2526%2bEditorial"&gt;free laptop controversy&lt;/a&gt;, and another announcing &lt;a href="http://herbsutter.spaces.live.com/?_c11_blogpart_blogpart=blogview&amp;amp;_c=blogpart&amp;amp;partqs=cat%3dTalks%2b%2526%2bEvents"&gt;Stroustrup &amp;amp; Sutter #3 this March&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Moving is always a tough decision. I've really enjoyed being hosted here at Pluralsight, and I want to thank the Pluralsight folks very much for providing a space for my blog over the past few years. It's been a blast, and they're a great bunch!&lt;/p&gt;
&lt;p&gt;See you at Spaces, and best wishes to you and yours.&lt;/p&gt;
&lt;p&gt;Herb&lt;/p&gt;</content><author><name>herb-sutter</name></author><thr:total>1</thr:total></entry><entry><id>48357</id><published>2007-09-04T00:24:00.0-05:00</published><updated>2007-09-04T00:24:00.0-05:00</updated><category scheme="http://schemas.google.com/g/2005#kind" term="http://schemas.google.com/blogger/2008/kind#comment"></category><title type="text">Anothr feed track -Sutter's (Online) Mill</title><content type="html">One new subscriber from Anothr Alerts</content><author><name>Anonymous</name></author><thr:in-reply-to ref="45503"></thr:in-reply-to></entry></feed>